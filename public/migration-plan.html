<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Yarny - React + TypeScript Migration Plan</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="/global.css">
  <link rel="stylesheet" href="/docs.css">
  <link rel="stylesheet" href="/footer.css">
  <!-- Privacy-friendly analytics by Plausible -->
  <script async src="https://plausible.io/js/pa-hQCYhFM-nW3tbKDHDR8Xc.js"></script>
  <script>
    window.plausible=window.plausible||function(){(plausible.q=plausible.q||[]).push(arguments)},plausible.init=plausible.init||function(i){plausible.o=i||{}};
    plausible.init()
  </script>
</head>
<body>
  <div class="docs-container">
    <main class="docs-main">
      <div class="sidebar-backdrop"></div>
      <aside class="docs-sidebar">
        <div class="sidebar-header">
          <div class="sidebar-branding">
            <h1>Yarny</h1>
            <p class="docs-subtitle">Your personal writing tool</p>
          </div>
          <a href="/migration-plan/testing-workbook" style="color: var(--color-primary); text-decoration: none; font-weight: var(--font-weight-semibold); display: block; margin-bottom: var(--space-md);">
            Testing Workbook
          </a>
        </div>
        <nav class="sidebar-nav">
          <ul class="sidebar-nav-list">
            <!-- Overview Section -->
            <li class="nav-group">
              <button class="nav-group-header" aria-expanded="true" data-group="overview">
                <span>Overview</span>
                <i class="material-icons nav-group-icon">expand_more</i>
              </button>
              <ul class="nav-group-items" data-group="overview">
                <li><a href="#executive-summary" class="nav-link">Executive Summary</a></li>
                <li><a href="#typescript-react" class="nav-link">Understanding TypeScript + React</a></li>
                <li><a href="#current-analysis" class="nav-link">Current Project Analysis</a></li>
              </ul>
            </li>

            <!-- Strategy & Planning Section -->
            <li class="nav-group">
              <button class="nav-group-header" aria-expanded="true" data-group="strategy">
                <span>Strategy & Planning</span>
                <i class="material-icons nav-group-icon">expand_more</i>
              </button>
              <ul class="nav-group-items" data-group="strategy">
                <li><a href="#preserve-ux-anchors" class="nav-link">Preserve Classic UX Anchors (P1/P2)</a></li>
                <li><a href="#migration-strategy" class="nav-link">Migration Strategy</a></li>
                <li><a href="#library-replacements" class="nav-link">Library Replacements</a></li>
                <li><a href="#mui-theming-strategy" class="nav-link">MUI Theming Strategy (P2)</a></li>
                <li><a href="#effort-estimation" class="nav-link">Effort Estimation</a></li>
              </ul>
            </li>

            <!-- Implementation Section -->
            <li class="nav-group">
              <button class="nav-group-header" aria-expanded="true" data-group="implementation">
                <span>Implementation</span>
                <i class="material-icons nav-group-icon">expand_more</i>
              </button>
              <ul class="nav-group-items" data-group="implementation">
                <li><a href="#implementation-details" class="nav-link">Implementation Details</a></li>
                <li><a href="#state-normalization" class="nav-link">State Normalization (P1)</a></li>
                <li><a href="#custom-implementation" class="nav-link">What Needs Custom Implementation</a></li>
                <li><a href="#fetch-caching" class="nav-link">Fetch/Caching Layer (React Query)</a></li>
                <li><a href="#api-contract" class="nav-link">API Contract Formalization</a></li>
                <li><a href="#netlify-functions-typescript" class="nav-link">Netlify Functions TypeScript Conversion (P1)</a></li>
                <li><a href="#offline-semantics" class="nav-link">Offline/Spotty-Network Semantics (P2)</a></li>
                <li><a href="#timezone-dst" class="nav-link">Timezone/DST for Goals (P2)</a></li>
                <li><a href="#rtl-mixed-script" class="nav-link">Right-to-Left & Mixed-Script (P2)</a></li>
                <li><a href="#memory-budget" class="nav-link">Memory Budget & Long Sessions (P2)</a></li>
                <li><a href="#unload-safety" class="nav-link">Unload Safety (P2)</a></li>
                <li><a href="#observability-light" class="nav-link">Observability Light (P2)</a></li>
                <li><a href="#editor-truth" class="nav-link">Editor Truth & Round-Tripping</a></li>
              </ul>
            </li>

            <!-- Migration Phases Section -->
            <li class="nav-group">
              <button class="nav-group-header" aria-expanded="true" data-group="phases">
                <span>Migration Phases</span>
                <i class="material-icons nav-group-icon">expand_more</i>
              </button>
              <ul class="nav-group-items" data-group="phases">
                <li><a href="#migration-phases" class="nav-link">Migration Phases</a></li>
                <li><a href="#phase-8" class="nav-link">Phase 8: Test Automation</a></li>
              </ul>
            </li>

            <!-- Project Management Section -->
            <li class="nav-group">
              <button class="nav-group-header" aria-expanded="true" data-group="project">
                <span>Project Management</span>
                <i class="material-icons nav-group-icon">expand_more</i>
              </button>
              <ul class="nav-group-items" data-group="project">
                <li><a href="#risk-factors" class="nav-link">Risk Factors</a></li>
                <li><a href="#benefits" class="nav-link">Benefits of Migration</a></li>
                <li><a href="#netlify-config" class="nav-link">Netlify Configuration</a></li>
                <li><a href="#file-structure" class="nav-link">File Structure</a></li>
                <li><a href="#decision-points" class="nav-link">Decision Points</a></li>
                <li><a href="#success-criteria" class="nav-link">Success Criteria</a></li>
                <li><a href="#notes-considerations" class="nav-link">Notes & Considerations</a></li>
                <li><a href="#test-strategy-drive-docs" class="nav-link">Test Strategy: Drive/Docs (P2)</a></li>
                <li><a href="#questions" class="nav-link">Questions to Resolve</a></li>
              </ul>
            </li>

            <!-- Reference Section -->
            <li class="nav-group">
              <button class="nav-group-header" aria-expanded="true" data-group="reference">
                <span>Reference</span>
                <i class="material-icons nav-group-icon">expand_more</i>
              </button>
              <ul class="nav-group-items" data-group="reference">
                <li><a href="#resources" class="nav-link">Resources</a></li>
                <li><a href="#technical-details" class="nav-link">Technical Details</a></li>
                <li><a href="#changelog" class="nav-link">Changelog</a></li>
                <li><a href="#next-steps" class="nav-link">Next Steps</a></li>
              </ul>
            </li>
          </ul>
        </nav>
      </aside>

      <div class="docs-content">
        <nav class="docs-nav">
          <a href="/stories.html" id="storiesNavLink" class="btn-secondary" style="display: none;">My Stories</a>
          <a href="/docs.html" class="btn-secondary">Docs</a>
          <a href="/" id="loginNavLink" class="btn-secondary">Back to Login</a>
        </nav>
        <section class="docs-section" id="executive-summary" style="background: #ECFDF5; border-left: 4px solid #10B981; padding: var(--space-lg); margin-bottom: var(--space-2xl); border-radius: var(--radius-lg);">
          <h2 id="executive-summary-heading" style="margin-top: 0; color: #059669; display: flex; align-items: center; gap: 8px;">
            <i class="material-icons" style="font-size: 24px;">lightbulb</i>
            Executive Summary
          </h2>
          <p style="margin-bottom: 0; color: #047857;">This document outlines the plan and effort estimation for converting the Yarny writing application from vanilla JavaScript to <strong style="color: #047857 !important;">React with TypeScript</strong>, including converting all Netlify Functions to TypeScript.</p>
          <p style="margin-top: var(--space-md); margin-bottom: 0; color: #047857;"><strong style="color: #047857 !important;">Key Finding</strong>: Using third-party React libraries can reduce the Level of Effort (LOE) by <strong style="color: #047857 !important;">40-50%</strong>, making the migration significantly more feasible.</p>
          <p style="margin-top: var(--space-md); margin-bottom: 0; color: #047857;"><strong style="color: #047857 !important;">Technology Stack</strong>: React 18 + TypeScript 5 + Vite (frontend), TypeScript + Netlify Functions (backend)</p>
        </section>

        <section class="docs-section" id="typescript-react">
          <h2 id="understanding-typescript-react">Understanding TypeScript + React</h2>
          
          <h3>They Work Together, Not Separately</h3>
          <p><strong>Important</strong>: TypeScript and React are not alternatives—they work together. Everything in this migration will be built using <strong>React components written in TypeScript</strong>.</p>
          <ul>
            <li><strong>TypeScript</strong> = The programming language (typed JavaScript)</li>
            <li><strong>React</strong> = The UI framework/library for building components</li>
            <li><strong>Result</strong> = React components written in TypeScript (<code>.tsx</code> files)</li>
          </ul>

          <h3>What Gets Built as React Components (TypeScript)</h3>
          <p>All UI components will be React components written in TypeScript:</p>
          <ul>
            <li><strong>Pages</strong>: <code>LoginPage.tsx</code>, <code>StoriesPage.tsx</code>, <code>EditorPage.tsx</code></li>
            <li><strong>Editor Components</strong>: <code>Editor.tsx</code>, <code>StorySidebar.tsx</code>, <code>NotesSidebar.tsx</code>, <code>TipTapEditor.tsx</code></li>
            <li><strong>UI Components</strong>: <code>Modal.tsx</code>, <code>ColorPicker.tsx</code>, <code>ContextMenu.tsx</code>, etc.</li>
            <li><strong>Shared Components</strong>: <code>Header.tsx</code>, <code>Footer.tsx</code></li>
          </ul>

          <h3>What Gets Built as React Hooks (TypeScript)</h3>
          <p>Business logic will be React hooks written in TypeScript:</p>
          <ul>
            <li><strong><code>useDrive.ts</code></strong> - Google Drive API wrapper with TypeScript types</li>
            <li><strong><code>useAuth.ts</code></strong> - Authentication logic with TypeScript types</li>
            <li><strong><code>useStory.ts</code></strong> - Story management with TypeScript types</li>
            <li><strong><code>useGoal.ts</code></strong> - Goal calculation algorithms with TypeScript types</li>
            <li><strong><code>useMobileDetection.ts</code></strong> - Mobile device detection</li>
          </ul>

          <h3>What Gets Built as TypeScript Utilities</h3>
          <p>Pure functions and utilities written in TypeScript (no React):</p>
          <ul>
            <li><strong><code>wordCount.ts</code></strong> - Word counting logic</li>
            <li><strong><code>export.ts</code></strong> - Export functionality</li>
            <li><strong><code>goalCalculation.ts</code></strong> - Goal calculation algorithms</li>
            <li><strong><code>api/drive.ts</code></strong> - Drive API client with TypeScript types</li>
          </ul>

          <h3>What Gets Built as TypeScript State Management</h3>
          <p>State management using Zustand with TypeScript:</p>
          <ul>
            <li><strong><code>store/store.ts</code></strong> - Zustand store with TypeScript interfaces</li>
            <li><strong><code>store/types.ts</code></strong> - TypeScript type definitions for all state structures</li>
          </ul>

          <h3>What Gets Built as TypeScript Netlify Functions</h3>
          <p>All backend Netlify Functions will be converted to TypeScript:</p>
          <ul>
            <li><strong>Authentication Functions</strong>: <code>auth/config.ts</code>, <code>auth/login.ts</code>, <code>auth/register.ts</code>, <code>auth/verify-login.ts</code>, <code>auth/verify-register.ts</code>, <code>auth/storage.ts</code>, <code>verify-google.ts</code>, <code>logout.ts</code></li>
            <li><strong>Drive Functions</strong>: <code>drive-auth.ts</code>, <code>drive-auth-callback.ts</code>, <code>drive-list.ts</code>, <code>drive-read.ts</code>, <code>drive-write.ts</code>, <code>drive-delete-file.ts</code>, <code>drive-delete-story.ts</code>, <code>drive-rename-file.ts</code>, <code>drive-create-folder.ts</code>, <code>drive-get-or-create-yarny-stories.ts</code>, <code>drive-check-comments.ts</code>, <code>drive-client.ts</code></li>
            <li><strong>Utility Functions</strong>: <code>config.ts</code>, <code>uptime-status.ts</code></li>
            <li><strong>Shared Types</strong>: <code>netlify/functions/types.ts</code> - Shared TypeScript types for request/response shapes across all functions</li>
          </ul>

          <h3>Example: React Component in TypeScript</h3>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// File: src/components/editor/Editor.tsx
// This is a React component written in TypeScript

import React from 'react';
import { useStore } from '../../store/store';
import { Group } from '../../store/types';

interface EditorProps {
  storyId: string;
}

export function Editor({ storyId }: EditorProps): JSX.Element {
  const groups = useStore((state) => state.groups);
  const activeSnippetId = useStore((state) => state.project.activeSnippetId);
  
  // Component logic here...
  
  return (
    &lt;div className="editor"&gt;
      {/* JSX here */}
    &lt;/div&gt;
  );
}</code></pre>

          <h3>Example: React Hook in TypeScript</h3>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// File: src/hooks/useDrive.ts
// This is a React hook written in TypeScript

import { useState, useEffect } from 'react';
import { DriveFile } from '../api/drive';

interface UseDriveResult {
  files: DriveFile[];
  loading: boolean;
  error: Error | null;
}

export function useDrive(folderId: string): UseDriveResult {
  const [files, setFiles] = useState&lt;DriveFile[]&gt;([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState&lt;Error | null&gt;(null);
  
  // Hook logic here...
  
  return { files, loading, error };
}</code></pre>

          <h3>Summary</h3>
          <ul>
            <li>✅ <strong>Everything</strong> = React components written in TypeScript</li>
            <li>✅ <strong>UI Components</strong> = React (<code>.tsx</code> files)</li>
            <li>✅ <strong>Business Logic</strong> = React hooks (<code>.ts</code> files)</li>
            <li>✅ <strong>Utilities</strong> = TypeScript functions (<code>.ts</code> files)</li>
            <li>✅ <strong>State</strong> = Zustand with TypeScript types</li>
            <li>✅ <strong>Backend</strong> = Netlify Functions written in TypeScript (<code>.ts</code> files)</li>
          </ul>
          <p><strong>The plan states</strong>: "This migration will use <strong>TypeScript</strong> throughout. All components, hooks, utilities, state management, and backend functions will be written in TypeScript."</p>
        </section>

        <section class="docs-section" id="current-analysis">
          <h2 id="current-project-analysis">Current Project Analysis</h2>
          
          <h3>Codebase Statistics</h3>
          <ul>
            <li><strong>Total JavaScript:</strong> ~8,782 lines across 4 main files</li>
            <li><strong>Largest File:</strong> <code>editor.js</code> - 6,069 lines</li>
            <li><strong>Other Files:</strong>
              <ul>
                <li><code>stories.js</code> - ~1,837 lines</li>
                <li><code>app.js</code> - ~503 lines</li>
                <li><code>drive.js</code> - ~269 lines</li>
              </ul>
            </li>
            <li><strong>Architecture:</strong> Vanilla JavaScript with direct DOM manipulation</li>
            <li><strong>Backend:</strong> Netlify Functions in JavaScript (will be converted to TypeScript)</li>
          </ul>

          <h3>Current Features</h3>
          <ul>
            <li>✅ Plain text editor (contentEditable, minimalist formatting)</li>
            <li>✅ Story/Chapter/Snippet management</li>
            <li>✅ Google Drive integration</li>
            <li>✅ Google Sign-In authentication</li>
            <li>✅ Drag & drop reordering</li>
            <li>✅ Color coding for chapters/snippets (12 accent colors)</li>
            <li>✅ Word count tracking & goals (elastic/strict modes)</li>
            <li>✅ Search functionality</li>
            <li>✅ Export functionality (chapters, outline, people, places, things)</li>
            <li>✅ Notes system (People/Places/Things)</li>
            <li>✅ Multiple modals and UI components</li>
            <li>✅ Context menus</li>
            <li>✅ Real-time save status</li>
            <li>✅ Mobile device detection & warning</li>
            <li>✅ Error logging to localStorage</li>
            <li>✅ Lazy loading of snippet content</li>
            <li>✅ Background loading optimization</li>
            <li>✅ Conflict resolution (Yarny vs Google Docs)</li>
            <li>✅ Comments/tracked changes detection</li>
          </ul>
        </section>

        <section class="docs-section" id="preserve-ux-anchors">
          <h2 id="preserve-ux-anchors-heading">
            Preserve Classic UX Anchors (P1/P2 Priority)
          </h2>
          
          <h3>Overview</h3>
          <p><strong>Why</strong>: These UI elements are recognizable bits from the 2011–2015 screenshots that define Yarny's identity. Preserving them intact avoids the "new app uncanny valley" and maintains user familiarity during migration.</p>
          <p><strong>What</strong>: These specific UI elements must be preserved exactly as they appear in the current app, with identical visual design, behavior, and placement.</p>

          <h3>Elements to Preserve</h3>

          <h4>1. Left-Rail Goal Meter</h4>
          <p><strong>Location</strong>: Left sidebar, below story title and settings button</p>
          <p><strong>Current Implementation</strong>:</p>
          <ul>
            <li>Displays total word count vs. goal (e.g., "0 / 3,000")</li>
            <li>Progress bar showing completion percentage</li>
            <li>Clickable to open goal panel</li>
            <li>Updates in real-time as user writes</li>
          </ul>
          <p><strong>Preservation Requirements</strong>:</p>
          <ul>
            <li>✅ Exact same visual design (font size, colors, spacing, border radius)</li>
            <li>✅ Same placement in left rail header</li>
            <li>✅ Same click behavior (opens goal panel)</li>
            <li>✅ Same real-time update behavior</li>
            <li>✅ Same progress bar styling and animation</li>
          </ul>
          <p><strong>Code Locations</strong>:</p>
          <ul>
            <li><code>editor.html</code> lines 71-76 (HTML structure)</li>
            <li><code>editor.css</code> lines 106-135 (styling)</li>
            <li><code>editor.js</code> lines 974-986 (<code>updateGoalMeter</code> function)</li>
          </ul>
          <p><strong>React Implementation</strong>:</p>
          <ul>
            <li>Create <code>GoalMeter.tsx</code> component in <code>src/components/editor/</code></li>
            <li>Preserve exact CSS classes and styling</li>
            <li>Use same calculation logic (<code>calculateStoryWordCount</code>)</li>
            <li>Maintain click handler to open goal panel</li>
          </ul>

          <h4>2. "Today • N" Chip</h4>
          <p><strong>Location</strong>: Left sidebar, below goal meter</p>
          <p><strong>Current Implementation</strong>:</p>
          <ul>
            <li>Displays "Today" label with daily word count (e.g., "Today • 250")</li>
            <li>Progress bar showing daily progress toward daily target</li>
            <li>Color-coded progress bar (green when ahead, red when behind in strict mode)</li>
            <li>Clickable to open goal panel</li>
            <li>Shows "—" when no goal is set</li>
          </ul>
          <p><strong>Preservation Requirements</strong>:</p>
          <ul>
            <li>✅ Exact same visual design (chip style, padding, border, colors)</li>
            <li>✅ Same placement below goal meter</li>
            <li>✅ Same "Today • N" format with number formatting (e.g., "1,234" with commas)</li>
            <li>✅ Same progress bar styling (2px height, subtle background)</li>
            <li>✅ Same color logic (green/red in strict mode, primary color otherwise)</li>
            <li>✅ Same click behavior (opens goal panel)</li>
            <li>✅ Always visible (even when no goal set, shows "—")</li>
            <li>✅ <strong>Enhanced UX</strong>: Expose "ahead/behind by N words" in chip state (e.g., "Today • 250 (+50 ahead)" or "Today • 150 (-50 behind)") so benefit is visible even when users don't open goal panel</li>
          </ul>
          <p><strong>Code Locations</strong>:</p>
          <ul>
            <li><code>editor.html</code> lines 77-83 (HTML structure)</li>
            <li><code>editor.css</code> lines 137-187 (styling)</li>
            <li><code>editor.js</code> lines 988-1055 (<code>updateTodayChip</code> function)</li>
          </ul>
          <p><strong>React Implementation</strong>:</p>
          <ul>
            <li>Create <code>TodayChip.tsx</code> component in <code>src/components/editor/</code></li>
            <li>Preserve exact CSS classes and styling</li>
            <li>Use same calculation logic (<code>calculateDailyTarget</code>)</li>
            <li>Maintain color logic for strict mode (ahead/behind indicators)</li>
            <li>Format numbers with <code>toLocaleString()</code> for comma separators</li>
          </ul>

          <h4>3. Footer Word/Character Counts</h4>
          <p><strong>Location</strong>: Footer bar, center section</p>
          <p><strong>Current Implementation</strong>:</p>
          <ul>
            <li>Displays "Words: N" and "Characters: N" with separator ("—")</li>
            <li>Updates in real-time as user types</li>
            <li>Shows counts for active snippet only</li>
            <li>Centered in footer bar</li>
            <li>Small font size, secondary text color</li>
          </ul>
          <p><strong>Preservation Requirements</strong>:</p>
          <ul>
            <li>✅ Exact same visual design (font size, color, spacing, separator)</li>
            <li>✅ Same placement in footer center</li>
            <li>✅ Same format ("Words: N — Characters: N")</li>
            <li>✅ Same real-time update behavior</li>
            <li>✅ Same calculation logic (active snippet only)</li>
          </ul>
          <p><strong>Code Locations</strong>:</p>
          <ul>
            <li><code>editor.html</code> lines 185-189 (HTML structure)</li>
            <li><code>editor.css</code> lines 889-898 (styling)</li>
            <li><code>editor.js</code> lines 949-972 (<code>updateFooter</code> function)</li>
          </ul>
          <p><strong>React Implementation</strong>:</p>
          <ul>
            <li>Create <code>Footer.tsx</code> component in <code>src/components/shared/</code></li>
            <li>Preserve exact CSS classes and styling</li>
            <li>Use same calculation logic (active snippet word/char count)</li>
            <li>Update on active snippet change and content changes</li>
          </ul>

          <h4>4. Version Slider Affordance</h4>
          <p><strong>Location</strong>: Footer bar (historical Yarny UI - core affordance)</p>
          <p><strong>Historical Implementation</strong> (2011-2015 Yarny app):</p>
          <ul>
            <li><strong>Core Feature</strong>: The version slider was a fundamental UI affordance in the original Yarny app footer</li>
            <li>Allows users to view/edit different versions of a snippet</li>
            <li>Timeline/history slider or version selector in the footer area</li>
            <li><strong>Note</strong>: This feature may not be present in the current codebase but was a core part of Yarny's historical UX</li>
          </ul>
          <p><strong>Preservation Requirements</strong>:</p>
          <ul>
            <li>✅ If present in current app: Preserve exact design and behavior</li>
            <li>✅ If not present: Document for future implementation to restore this core historical affordance</li>
            <li>✅ Maintain same visual affordance and interaction pattern as original design</li>
            <li>✅ Reference original 2011-2015 UI documentation for specification details</li>
          </ul>
          <p><strong>Investigation Needed</strong>:</p>
          <ul>
            <li>Check reference documentation for original version slider implementation</li>
            <li>Verify if this feature exists in current codebase under different name or in a different location</li>
            <li>Review reference docs (Yarny_UI_Evidence_Book_Annotated_IMAGES.pdf, Yarny_UI_Companion_Notes_and_Spec_Crosswalk.pdf) for version slider specifications</li>
            <li>Document findings and implementation plan for restoration</li>
          </ul>
          <p><strong>React Implementation</strong>:</p>
          <ul>
            <li>If feature exists: Create <code>VersionSlider.tsx</code> component in <code>src/components/shared/</code> (footer area)</li>
            <li>Preserve exact design and interaction patterns from historical UI</li>
            <li>If not present: Document as future feature to restore this core historical affordance</li>
            <li>Anchor specification to original 2011-2015 UI design to ensure it doesn't get lost</li>
          </ul>

          <h3>Implementation Strategy</h3>

          <h4>Phase 1: Document and Audit</h4>
          <ol>
            <li><strong>Audit Current Implementation</strong>:
              <ul>
                <li>Document exact HTML structure for each element</li>
                <li>Document exact CSS styling (colors, spacing, fonts, animations)</li>
                <li>Document exact JavaScript behavior (click handlers, update logic)</li>
                <li>Take screenshots for visual reference</li>
              </ul>
            </li>
            <li><strong>Create Component Specifications</strong>:
              <ul>
                <li>Create detailed specs for each component</li>
                <li>Include pixel-perfect measurements</li>
                <li>Document all state dependencies</li>
                <li>Document all event handlers</li>
              </ul>
            </li>
          </ol>

          <h4>Phase 4: Implement Footer Components</h4>
          <ol>
            <li><strong>Footer Component</strong>:
              <ul>
                <li>Create <code>Footer.tsx</code> with exact styling</li>
                <li>Implement <code>updateFooter</code> logic as hook</li>
                <li>Preserve word/character count display</li>
                <li>Test visual parity with current app</li>
              </ul>
            </li>
          </ol>

          <h4>Phase 5: Implement Goals UI Components</h4>
          <ol>
            <li><strong>Goal Meter Component</strong>:
              <ul>
                <li>Create <code>GoalMeter.tsx</code> with exact styling</li>
                <li>Implement <code>updateGoalMeter</code> logic as hook</li>
                <li>Test visual parity with current app</li>
              </ul>
            </li>
            <li><strong>Today Chip Component</strong>:
              <ul>
                <li>Create <code>TodayChip.tsx</code> with exact styling</li>
                <li>Implement <code>updateTodayChip</code> logic as hook</li>
                <li>Preserve color logic for strict mode</li>
                <li>Test visual parity with current app</li>
              </ul>
            </li>
            <li><strong>Version Slider</strong> (historical core affordance):
              <ul>
                <li>Investigate current implementation status</li>
                <li>Review historical UI documentation for specification</li>
                <li>Create component if feature exists in current codebase</li>
                <li>If not present, document for future restoration of this core historical affordance</li>
                <li>Preserve exact design and behavior from original 2011-2015 UI</li>
              </ul>
            </li>
          </ol>

          <h4>Phase 7: Visual Parity Testing</h4>
          <ol>
            <li><strong>Side-by-Side Comparison</strong> (Required before closing editor phase):
              <ul>
                <li>Deploy React app to <code>/react</code> path</li>
                <li>Compare each element side-by-side with current app</li>
                <li><strong>Perform pixel-diff or side-by-side visual comparison</strong> for goal meter, "Today" chip, and footer counts</li>
                <li>Verify pixel-perfect visual match</li>
                <li>Verify identical behavior</li>
                <li>Document any visual discrepancies and resolve before proceeding</li>
              </ul>
            </li>
            <li><strong>User Testing</strong>:
              <ul>
                <li>Test with users familiar with current app</li>
                <li>Verify no "uncanny valley" effect</li>
                <li>Confirm elements feel identical</li>
              </ul>
            </li>
          </ol>

          <h3>Benefits</h3>
          <ol>
            <li><strong>User Familiarity</strong>: Users won't experience jarring visual changes</li>
            <li><strong>Brand Consistency</strong>: Maintains Yarny's recognizable identity</li>
            <li><strong>Reduced Learning Curve</strong>: No need to relearn UI elements</li>
            <li><strong>Trust</strong>: Preserves elements users rely on daily</li>
          </ol>

          <h3>Success Criteria</h3>
          <ul>
            <li>✅ Goal meter looks and behaves identically to current app</li>
            <li>✅ Today chip looks and behaves identically to current app</li>
            <li>✅ Footer word/character counts look and behave identically to current app</li>
            <li>✅ Version slider (if present) looks and behaves identically to historical/current app, or is documented for future restoration</li>
            <li>✅ <strong>Pixel-diff or side-by-side visual comparison confirms pixel-perfect match</strong> (required before closing editor phase)</li>
            <li>✅ User testing confirms no "uncanny valley" effect</li>
          </ul>

          <h3>LOE</h3>
          <ul>
            <li><strong>Documentation & Audit</strong>: 2-3 hours</li>
            <li><strong>Component Implementation</strong>: 4-6 hours (Goal Meter, Today Chip, Footer)</li>
            <li><strong>Version Slider Investigation & Documentation</strong>: 1-2 hours (investigate current status, document historical specification for future restoration if needed)</li>
            <li><strong>Visual Parity Testing</strong>: 2-3 hours</li>
            <li><strong>Total</strong>: 9-14 hours</li>
          </ul>
        </section>

        <section class="docs-section" id="migration-strategy">
          <h2 id="migration-strategy-heading">Migration Strategy</h2>
          
          <h3>Approach: Incremental Migration</h3>
          <ol>
            <li>Set up React infrastructure alongside existing code</li>
            <li>Migrate page by page (index → stories → editor)</li>
            <li>Use third-party libraries to replace custom implementations</li>
            <li>Maintain feature parity throughout migration</li>
          </ol>

          <h3>Deployment Strategy: Parallel Development</h3>
          <ul>
            <li><strong>New React App:</strong> Deploy to <code>yarny.lindsaybrunner.com/react</code></li>
            <li><strong>Existing App:</strong> Remains live at <code>yarny.lindsaybrunner.com</code> (root)</li>
            <li><strong>Benefits:</strong>
              <ul>
                <li>Keep existing app fully functional during development</li>
                <li>Enable side-by-side testing and comparison</li>
                <li>Allow gradual user migration</li>
                <li>Easy rollback if needed</li>
                <li>Test with real users before full migration</li>
              </ul>
            </li>
          </ul>
        </section>

        <section class="docs-section" id="library-replacements">
          <h2 id="third-party-library-replacements">Third-Party Library Replacements</h2>
          
          <p>This section details exactly which parts of the current codebase can be replaced by proven React libraries, significantly reducing development time and maintenance burden.</p>

          <h3>Replaceable Components & Estimated Savings</h3>
          <table>
            <thead>
              <tr>
                <th>Component</th>
                <th>Current Lines</th>
                <th>Library</th>
                <th>Savings</th>
                <th>What It Replaces</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Text Editor (Plain Text)</td>
                <td>~1,500-2,000</td>
                <td>TipTap (Plain Text Only)</td>
                <td>~1,500-2,000 lines</td>
                <td>All contentEditable handling, text extraction, plain text formatting logic</td>
              </tr>
              <tr>
                <td>Modals (8 total)</td>
                <td>~500-800</td>
                <td>Material UI Dialog</td>
                <td>~500-800 lines</td>
                <td>Story Info, Export, Description Edit, Goal Panel, Rename, Delete, Conflict Resolution, Comments Warning</td>
              </tr>
              <tr>
                <td>Drag & Drop</td>
                <td>~300-400</td>
                <td>@dnd-kit</td>
                <td>~300-400 lines</td>
                <td>All drag event handlers, drop zones, reordering logic for chapters/snippets</td>
              </tr>
              <tr>
                <td>Color Picker</td>
                <td>~150</td>
                <td>react-colorful</td>
                <td>~150 lines</td>
                <td>Custom color picker UI, color selection logic, positioning</td>
              </tr>
              <tr>
                <td>Tabs</td>
                <td>~100</td>
                <td>Material UI Tabs</td>
                <td>~100 lines</td>
                <td>People/Places/Things tab switching, tab state management</td>
              </tr>
              <tr>
                <td>Context Menu</td>
                <td>~150</td>
                <td>Material UI Menu</td>
                <td>~150 lines</td>
                <td>Right-click menu for rename/delete, menu positioning</td>
              </tr>
              <tr>
                <td>Dropdown Menus</td>
                <td>~100</td>
                <td>Material UI Menu</td>
                <td>~100 lines</td>
                <td>Export dropdown menu, positioning, open/close logic</td>
              </tr>
              <tr>
                <td>Forms</td>
                <td>~200</td>
                <td>React Hook Form</td>
                <td>~200 lines</td>
                <td>Form validation, form state, error handling for all modals</td>
              </tr>
              <tr>
                <td>Date Picker</td>
                <td>~50</td>
                <td>Material UI DatePicker</td>
                <td>~50 lines</td>
                <td>Goal deadline date input, date validation</td>
              </tr>
              <tr>
                <td>Tooltips</td>
                <td>~50</td>
                <td>Material UI Tooltip</td>
                <td>~50 lines</td>
                <td>All title attributes and custom tooltip implementations</td>
              </tr>
              <tr>
                <td>Toast Notifications</td>
                <td>~100</td>
                <td>react-hot-toast</td>
                <td>~100 lines</td>
                <td>Save status updates, error notifications, success messages</td>
              </tr>
              <tr>
                <td>Collapsible/Accordion</td>
                <td>~100</td>
                <td>Material UI Accordion</td>
                <td>~100 lines</td>
                <td>Chapter collapse/expand functionality</td>
              </tr>
              <tr>
                <td><strong>TOTAL</strong></td>
                <td><strong>~3,300-4,200</strong></td>
                <td></td>
                <td><strong>~3,300-4,200 lines</strong></td>
                <td><strong>40-50% of codebase</strong></td>
              </tr>
            </tbody>
          </table>

          <h3>Detailed Component Mapping</h3>
          
          <h4>1. Rich Text Editor → TipTap (Constrained to Plain Text)</h4>
          <p><strong>Current Implementation:</strong></p>
          <ul>
            <li><code>editor.js</code>: <code>getEditorTextContent()</code>, <code>setEditorTextContent()</code>, contentEditable event handlers</li>
            <li>Complex text extraction logic handling <code>&lt;br&gt;</code>, <code>&lt;div&gt;</code>, <code>&lt;p&gt;</code> tags</li>
            <li>Line break normalization</li>
            <li>Cursor position management</li>
            <li>Content synchronization with state</li>
            <li><strong>Content Format</strong>: Plain text with line breaks (<code>\n</code>), stored as <code>snippet.body</code> string</li>
            <li><strong>Storage</strong>: Google Docs API (for snippets) or plain text (for notes)</li>
            <li><strong>Conflict Detection</strong>: Compares plain text content and timestamps</li>
          </ul>
          <p><strong>Replacement:</strong></p>
          <ul>
            <li>TipTap configured for <strong>minimalist plain text only</strong> (no rich formatting)</li>
            <li><strong>Format Constraint</strong>: Plain paragraphs and soft line breaks only (matches current model)</li>
            <li><strong>Editor as Truth</strong>: Editor is authoritative while Yarny is open</li>
            <li><strong>Reconciliation</strong>: Check for external changes on window focus, reconcile if needed</li>
            <li><strong>Early Conflict Detection</strong>: Bring conflict detection forward to Phase 1/2</li>
            <li>Type-safe editor API</li>
            <li>Handles cursor management and content synchronization</li>
          </ul>
          <p><strong>Critical Constraints:</strong></p>
          <ul>
            <li><strong>NO rich formatting</strong> (bold, italic, colors, etc.) - Google Docs API doesn't handle arbitrary HTML well</li>
            <li><strong>Plain text only</strong> - matches Yarny's minimalist model</li>
            <li><strong>Paragraph breaks</strong> - use TipTap's paragraph support for <code>\n\n</code> (paragraph breaks)</li>
            <li><strong>Soft line breaks</strong> - use TipTap's line break support for <code>\n</code> (single line breaks)</li>
            <li><strong>Text extraction</strong> - must extract plain text that matches Google Docs API output format</li>
          </ul>
          <p><strong>Code Locations:</strong></p>
          <ul>
            <li><code>editor.js</code> lines ~590-670 (text content extraction)</li>
            <li><code>editor.js</code> lines ~669-738 (editor rendering and content management)</li>
            <li><code>editor.js</code> lines ~1160-1383 (conflict detection and resolution)</li>
            <li>All contentEditable event listeners throughout <code>editor.js</code></li>
          </ul>

          <h4>2. Modals → Material UI Dialog</h4>
          <p><strong>Current Implementation:</strong></p>
          <ul>
            <li>8 separate modal implementations with custom show/hide logic</li>
            <li>Modal overlay management</li>
            <li>Focus trapping</li>
            <li>Escape key handling</li>
            <li>Click-outside-to-close logic</li>
          </ul>
          <p><strong>Replacement:</strong></p>
          <ul>
            <li>Material UI Dialog component handles all modal behavior</li>
            <li>Accessible by default (ARIA, focus management)</li>
            <li>Keyboard navigation built-in</li>
            <li>Can style to match existing design with theme customization</li>
          </ul>
          <p><strong>Code Locations:</strong></p>
          <ul>
            <li><code>editor.html</code> lines 200-571 (all modal HTML structures)</li>
            <li><code>editor.js</code> modal open/close functions throughout</li>
          </ul>

          <h4>3. Drag & Drop → @dnd-kit</h4>
          <p><strong>Current Implementation:</strong></p>
          <ul>
            <li>Native HTML5 drag events (<code>dragstart</code>, <code>dragover</code>, <code>drop</code>, <code>dragend</code>)</li>
            <li>Custom drop zone detection</li>
            <li>Visual feedback during drag</li>
            <li>Reordering logic for groups and snippets</li>
          </ul>
          <p><strong>Replacement:</strong></p>
          <ul>
            <li>@dnd-kit provides sortable list functionality</li>
            <li>Touch device support</li>
            <li>Better performance than native drag events</li>
            <li>Built-in visual feedback</li>
          </ul>
          <p><strong>Code Locations:</strong></p>
          <ul>
            <li><code>editor.js</code> lines ~300, 368-376 (group drag handlers)</li>
            <li><code>editor.js</code> lines ~410, 526-534 (snippet drag handlers)</li>
            <li><code>editor.js</code> lines ~766, 905-910 (notes drag handlers)</li>
            <li>All <code>handleGroupDragStart</code>, <code>handleSnippetDragStart</code>, <code>handleDragOver</code>, etc. functions</li>
          </ul>

          <h4>4. Color Picker → react-colorful</h4>
          <p><strong>Current Implementation:</strong></p>
          <ul>
            <li>Custom color picker UI with 12 color grid</li>
            <li>Positioning logic relative to color chip</li>
            <li>Click-outside-to-close handling</li>
            <li>Color selection and application</li>
          </ul>
          <p><strong>Replacement:</strong></p>
          <ul>
            <li>react-colorful provides pre-built color picker</li>
            <li>Can be styled to match 12-color palette</li>
            <li>Simpler integration</li>
          </ul>
          <p><strong>Code Locations:</strong></p>
          <ul>
            <li><code>editor.js</code> lines 2682-2784 (color picker functions)</li>
            <li><code>editor.html</code> lines 437-442 (color picker HTML)</li>
          </ul>

          <h4>5. Tabs → Material UI Tabs</h4>
          <p><strong>Current Implementation:</strong></p>
          <ul>
            <li>Custom tab switching for People/Places/Things</li>
            <li>Tab state management</li>
            <li>Active tab styling</li>
          </ul>
          <p><strong>Replacement:</strong></p>
          <ul>
            <li>Material UI Tabs handles all tab functionality</li>
            <li>Accessible keyboard navigation</li>
            <li>Built-in active state management</li>
            <li>Can be styled to match existing design</li>
          </ul>
          <p><strong>Code Locations:</strong></p>
          <ul>
            <li><code>editor.html</code> lines 115-139 (tabs HTML)</li>
            <li><code>editor.js</code> tab switching logic</li>
          </ul>

          <h4>6. Context Menu → Material UI Menu</h4>
          <p><strong>Current Implementation:</strong></p>
          <ul>
            <li>Right-click event handling</li>
            <li>Menu positioning</li>
            <li>Rename/Delete menu items</li>
          </ul>
          <p><strong>Replacement:</strong></p>
          <ul>
            <li>Material UI Menu provides full context menu functionality</li>
            <li>Accessible, keyboard navigable</li>
            <li>Proper positioning with anchor positioning</li>
            <li>Can be styled to match existing design</li>
          </ul>
          <p><strong>Code Locations:</strong></p>
          <ul>
            <li><code>editor.html</code> lines 444-448 (context menu HTML)</li>
            <li><code>editor.js</code> context menu show/hide logic</li>
          </ul>

          <h4>7. Forms → React Hook Form</h4>
          <p><strong>Current Implementation:</strong></p>
          <ul>
            <li>Manual form validation</li>
            <li>Form state management</li>
            <li>Error message display</li>
            <li>Used in: Story Info, New Story, Goal Panel, Rename, Description Edit modals</li>
          </ul>
          <p><strong>Replacement:</strong></p>
          <ul>
            <li>React Hook Form handles validation, state, and errors</li>
            <li>TypeScript integration</li>
            <li>Better performance (uncontrolled components)</li>
          </ul>
          <p><strong>Code Locations:</strong></p>
          <ul>
            <li>All modal forms in <code>editor.html</code> and <code>stories.html</code></li>
            <li>Form validation logic in <code>editor.js</code> and <code>stories.js</code></li>
          </ul>

          <h4>8. Date Picker → Material UI DatePicker</h4>
          <p><strong>Current Implementation:</strong></p>
          <ul>
            <li>Native HTML5 date input</li>
            <li>Date validation</li>
            <li>Used in Goal Panel for deadline selection</li>
          </ul>
          <p><strong>Replacement:</strong></p>
          <ul>
            <li>Material UI DatePicker provides better UX</li>
            <li>Date range selection</li>
            <li>Integrated with Material UI theme</li>
            <li>Accessible and keyboard navigable</li>
          </ul>
          <p><strong>Code Locations:</strong></p>
          <ul>
            <li><code>editor.html</code> lines 365-372 (goal deadline input)</li>
            <li><code>stories.html</code> deadline input in new story modal</li>
          </ul>

          <h4>9. Toast Notifications → react-hot-toast</h4>
          <p><strong>Current Implementation:</strong></p>
          <ul>
            <li>Custom save status updates ("Saving...", "Saved at X:XX")</li>
            <li>Manual status element updates</li>
            <li>Status styling and transitions</li>
          </ul>
          <p><strong>Replacement:</strong></p>
          <ul>
            <li>react-hot-toast provides toast notifications</li>
            <li>Auto-dismiss, positioning, animations</li>
            <li>Success/error/info variants</li>
          </ul>
          <p><strong>Code Locations:</strong></p>
          <ul>
            <li><code>editor.js</code> lines 1057-1077 (<code>updateSaveStatus</code> function)</li>
            <li><code>editor.html</code> line 108 (save status element)</li>
          </ul>

          <h4>10. Collapsible/Accordion → Material UI Accordion</h4>
          <p><strong>Current Implementation:</strong></p>
          <ul>
            <li>Custom collapse/expand for chapters</li>
            <li>Collapse state management (localStorage)</li>
            <li>Icon toggling (arrow up/down)</li>
          </ul>
          <p><strong>Replacement:</strong></p>
          <ul>
            <li>Material UI Accordion handles collapse functionality</li>
            <li>Accessible, keyboard navigable</li>
            <li>Built-in state management</li>
            <li>Can be styled to match existing design</li>
          </ul>
          <p><strong>Code Locations:</strong></p>
          <ul>
            <li><code>editor.js</code> lines 217-262 (collapse state management)</li>
            <li><code>editor.js</code> lines 303-316 (collapse button rendering)</li>
            <li><code>editor.js</code> lines 254-262 (<code>toggleGroupCollapse</code> function)</li>
          </ul>

          <h3>Benefits of Using Third-Party Libraries</h3>
          <ol>
            <li><strong>Massive Code Reduction</strong>: ~3,300-4,200 lines of custom code replaced by battle-tested libraries</li>
            <li><strong>Accessibility Built-In</strong>: All Material UI components are fully accessible (ARIA, keyboard nav)</li>
            <li><strong>Consistent Design System</strong>: Material UI provides a cohesive design system that can be customized</li>
            <li><strong>Type Safety</strong>: All recommended libraries have excellent TypeScript support</li>
            <li><strong>Maintenance</strong>: Libraries are maintained by teams, reducing our maintenance burden</li>
            <li><strong>Performance</strong>: Optimized libraries often perform better than custom implementations</li>
            <li><strong>Documentation</strong>: Well-documented libraries with examples and community support</li>
            <li><strong>Bug Fixes</strong>: Libraries fix edge cases we haven't encountered yet</li>
            <li><strong>Future-Proof</strong>: Libraries evolve with React ecosystem</li>
          </ol>

          <h3>Recommended Library Stack</h3>
          <p><strong>Note:</strong> This migration will use <strong>TypeScript</strong> throughout. All components, hooks, utilities, and state management will be written in TypeScript.</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>{
  "dependencies": {
    "react": "^18.x",
    "react-dom": "^18.x",
    "react-router-dom": "^6.x",
    "@tiptap/react": "^2.x",
    "@tiptap/extension-document": "^2.x",
    "@tiptap/extension-paragraph": "^2.x",
    "@tiptap/extension-text": "^2.x",
    "@tiptap/extension-hard-break": "^2.x",
    "@tiptap/extension-history": "^2.x",
    "@tanstack/react-query": "^5.x",
    "@tanstack/react-virtual": "^3.x",
    "@mui/material": "^5.x",
    "@mui/icons-material": "^5.x",
    "@mui/x-date-pickers": "^6.x",
    "@emotion/react": "^11.x",
    "@emotion/styled": "^11.x",
    "@dnd-kit/core": "^6.x",
    "@dnd-kit/sortable": "^8.x",
    "@dnd-kit/utilities": "^3.x",
    "react-colorful": "^5.x",
    "react-hook-form": "^7.x",
    "react-hot-toast": "^2.x",
    "axios": "^1.x",
    "zustand": "^4.x",
    "zod": "^3.x"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.x",
    "vite": "^5.x",
    "typescript": "^5.x",
    "@types/react": "^18.x",
    "@types/react-dom": "^18.x",
    "@types/node": "^20.x"
  }
}</code></pre>

          <h3>Library Selection Rationale</h3>
          
          <h4>Text Editor: <strong>TipTap</strong> (Recommended - Plain Text Only)</h4>
          <ul>
            <li>✅ Modern, extensible, built for React</li>
            <li>✅ <strong>Excellent TypeScript support</strong> - Full type definitions included</li>
            <li>✅ Active community and maintenance</li>
            <li>✅ Handles contentEditable complexity</li>
            <li>✅ Type-safe editor extensions and commands</li>
            <li>✅ Replaces ~1,500-2,000 lines of custom contentEditable code</li>
            <li>✅ <strong>Configured for plain text only</strong> - matches Yarny's minimalist model</li>
            <li>✅ Handles text extraction matching Google Docs API format</li>
            <li>✅ Supports paragraph breaks and soft line breaks (no rich formatting)</li>
            <li><strong>Note</strong>: Will be configured with only Document, Paragraph, Text, HardBreak, History extensions (no Bold, Italic, etc.)</li>
            <li><strong>Alternative</strong>: Slate.js (more complex but powerful, also has TypeScript support)</li>
          </ul>

          <h4>UI Components: <strong>Material UI</strong> (Recommended)</h4>
          <ul>
            <li>✅ Comprehensive component library with consistent design system</li>
            <li>✅ Full keyboard navigation built-in</li>
            <li>✅ ARIA attributes automatically handled</li>
            <li>✅ Highly customizable with theme system - can match existing design</li>
            <li>✅ <strong>Full TypeScript support</strong> - All components are typed</li>
            <li>✅ Replaces ~1,000+ lines of modal, menu, tab, tooltip code</li>
            <li>✅ Provides: Dialog (modals), Menu (dropdowns/context menus), Tabs, Tooltip, Accordion, DatePicker, and many more</li>
            <li>✅ Includes Material Icons library for consistent iconography</li>
            <li>✅ Active development and large community</li>
            <li><strong>Alternative</strong>: Radix UI (unstyled, more minimal) or Headless UI (similar, different API)</li>
          </ul>

          <h4>Drag & Drop: <strong>@dnd-kit</strong> (Recommended)</h4>
          <ul>
            <li>✅ Modern, performant library</li>
            <li>✅ Better than react-beautiful-dnd (which is unmaintained)</li>
            <li>✅ Supports sortable lists out of the box</li>
            <li>✅ Touch device support for tablets</li>
            <li>✅ Replaces ~300-400 lines of native drag event handling</li>
            <li>✅ Handles all the drag/drop logic for chapters and snippets</li>
            <li>✅ Better visual feedback and drop zone detection than native events</li>
          </ul>
        </section>

        <section class="docs-section" id="mui-theming-strategy">
          <h2 id="mui-theming-strategy-heading">MUI Theming Strategy: Keep Brand Look, Use MUI for Plumbing (P2)</h2>
          
          <h3>Overview</h3>
          <p><strong>Principle</strong>: Keep the brand look; let MUI do the plumbing.</p>
          <p><strong>Why</strong>: MUI is ergonomic but visually opinionated. You've already defined a 12-color system and gradient aesthetic; keep that as the design source of truth while using MUI for accessibility and behaviors. The plan already codifies the palette and usage guidelines—excellent.</p>

          <h3>Design Philosophy</h3>
          <ol>
            <li><strong>Brand as Source of Truth</strong>: The existing 12-color categorical accent system and gradient aesthetic are the design foundation. MUI components will be customized to match this palette, not the other way around.</li>
            <li><strong>MUI for Behaviors</strong>: Use MUI components for:
              <ul>
                <li>Accessibility (ARIA attributes, keyboard navigation, focus management)</li>
                <li>Interaction behaviors (modal open/close, menu positioning, form validation)</li>
                <li>Component plumbing (Dialog, Menu, Tabs, Tooltip, Accordion, DatePicker)</li>
                <li>Built-in accessibility features that would be time-consuming to implement from scratch</li>
              </ul>
            </li>
            <li><strong>Customization Over Defaults</strong>: MUI's theme system will be extensively customized to:
              <ul>
                <li>Map the 12-color accent palette to MUI's color system</li>
                <li>Preserve the gradient aesthetic where applicable</li>
                <li>Maintain the existing visual hierarchy and spacing</li>
                <li>Keep the minimalist, clean design language</li>
              </ul>
            </li>
          </ol>

          <h3>Implementation Strategy</h3>
          
          <h4>1. MUI Theme Customization (Start in Phase 1)</h4>
          <p>Create <code>src/theme/theme.ts</code> that maps the brand palette to MUI's theme. <strong>Critical: Include ALL palette tokens and gradient from the start</strong>:</p>
          <pre><code>import { createTheme } from '@mui/material/styles';

// Import the COMPLETE 12-color palette from the Color System section
// Include all variants: base, soft, dark, on-solid for each accent color
const brandColors = {
  primary: '#10B981', // Emerald (matches existing primary)
  primaryLight: '#D1FAE5',
  primaryDark: '#059669',
  
  // All 12 accent colors with all variants (base, soft, dark, on-solid)
  accent: {
    red: { base: '#EF4444', soft: '#FEE2E2', dark: '#991B1B', onSolid: '#FFFFFF' },
    orange: { base: '#F97316', soft: '#FFEDD5', dark: '#9A3412', onSolid: '#FFFFFF' },
    amber: { base: '#F59E0B', soft: '#FEF3C7', dark: '#92400E', onSolid: '#1F2937' },
    yellow: { base: '#EAB308', soft: '#FEF9C3', dark: '#854D0E', onSolid: '#1F2937' },
    lime: { base: '#84CC16', soft: '#ECFCCB', dark: '#365314', onSolid: '#0B1220' },
    emerald: { base: '#10B981', soft: '#D1FAE5', dark: '#065F46', onSolid: '#FFFFFF' },
    teal: { base: '#14B8A6', soft: '#CCFBF1', dark: '#115E59', onSolid: '#FFFFFF' },
    cyan: { base: '#06B6D4', soft: '#CFFAFE', dark: '#155E75', onSolid: '#FFFFFF' },
    blue: { base: '#3B82F6', soft: '#DBEAFE', dark: '#1E40AF', onSolid: '#FFFFFF' },
    indigo: { base: '#6366F1', soft: '#E0E7FF', dark: '#3730A3', onSolid: '#FFFFFF' },
    violet: { base: '#8B5CF6', soft: '#EDE9FE', dark: '#5B21B6', onSolid: '#FFFFFF' },
    fuchsia: { base: '#D946EF', soft: '#FAE8FF', dark: '#86198F', onSolid: '#FFFFFF' },
  },
  
  // Neutral colors (text on soft chips)
  neutrals: {
    ink900: '#0F172A',
    ink700: '#334155',
    ink500: '#64748B',
  },
};

export const theme = createTheme({
  palette: {
    primary: {
      main: brandColors.primary,
      light: brandColors.primaryLight,
      dark: brandColors.primaryDark,
    },
    // Map accent colors to MUI's secondary, error, warning, info, success
    // Or create custom palette extensions
    // Include gradient tokens if applicable
  },
  // Customize component defaults to match brand BEFORE building components
  components: {
    MuiDialog: {
      styleOverrides: {
        paper: {
          // Match existing modal styling - use brand colors
          borderRadius: '8px',
          border: `1px solid ${brandColors.primary}`,
        },
      },
    },
    MuiButton: {
      styleOverrides: {
        root: {
          // Match existing button styling - use brand colors
        },
      },
    },
    // ... customize all MUI components used with brand tokens
  },
});</code></pre>

          <h4>2. Component-Level Styling</h4>
          <p>For components that need exact brand matching:</p>
          <ul>
            <li>Use MUI's <code>sx</code> prop for one-off customizations</li>
            <li>Use <code>styled()</code> API for reusable branded components</li>
            <li>Keep MUI's accessibility and behavior, override only visual styling</li>
          </ul>
          <pre><code>import { Dialog, styled } from '@mui/material';

// Keep MUI Dialog behavior, customize appearance
const BrandedDialog = styled(Dialog)(({ theme }) => ({
  '& .MuiDialog-paper': {
    // Match existing modal design exactly
    borderRadius: '8px',
    // Use brand colors
    border: `1px solid ${theme.palette.primary.main}`,
  },
}));</code></pre>

          <h4>3. Color System Integration</h4>
          <p>The existing 12-color categorical accent system (defined in the Color System section) will be:</p>
          <ul>
            <li><strong>Preserved</strong>: All color variants (base, soft, dark, on-solid) remain as defined</li>
            <li><strong>Mapped</strong>: Integrated into MUI's theme system for consistent usage</li>
            <li><strong>Extended</strong>: Used in MUI components via theme overrides and custom props</li>
          </ul>

          <h4>4. Usage Guidelines</h4>
          <ul>
            <li><strong>Use MUI components</strong> for: Modals (Dialog), Menus, Tabs, Tooltips, Accordions, DatePickers, Forms</li>
            <li><strong>Customize appearance</strong> to match: Existing color palette, spacing, typography, border radius, shadows</li>
            <li><strong>Keep MUI behaviors</strong>: Accessibility, keyboard navigation, focus management, ARIA attributes</li>
            <li><strong>Preserve brand identity</strong>: Visual design remains consistent with existing app</li>
          </ul>

          <h3>Benefits</h3>
          <ol>
            <li><strong>Accessibility Out of the Box</strong>: MUI components provide full keyboard navigation, ARIA attributes, and focus management without custom implementation</li>
            <li><strong>Reduced Code</strong>: ~1,000+ lines of modal, menu, tab code replaced by MUI</li>
            <li><strong>Brand Consistency</strong>: Theme customization ensures visual consistency with existing design</li>
            <li><strong>Maintainability</strong>: MUI's theming system makes it easy to update brand colors globally</li>
            <li><strong>Best of Both Worlds</strong>: Brand look + MUI's proven accessibility and behaviors</li>
          </ol>

          <h3>Implementation Timeline</h3>
          <p>This should be implemented in <strong>Phase 1</strong> (Setup & Infrastructure) - <strong>Critical: Start from day one</strong>:</p>
          <ul>
            <li><strong>Create <code>src/theme/theme.ts</code> with ALL brand color mappings and gradient tokens</strong> - map the complete 12-color accent palette to MUI's theme system from the start</li>
            <li><strong>Set up ThemeProvider in app root immediately</strong> - so all components inherit the brand feel from day one</li>
            <li><strong>Customize MUI component defaults to match existing design</strong> - before building any components, ensure Dialog, Button, Menu, Tabs, etc. match brand styling</li>
            <li>Test theme customization with sample components to verify brand consistency</li>
          </ul>
          <p><strong>Why Start Early</strong>: Starting the theme with palette tokens and gradient from Phase 1 prevents design drift. If MUI's default styling is used first and then customized later, components built early will have the wrong feel. Starting with brand tokens ensures everything inherits the right feel from the beginning.</p>
          <p><strong>LOE</strong>: 4-6 hours (adds time but ensures brand consistency and prevents design drift)</p>
        </section>

        <section class="docs-section" id="effort-estimation">
          <h2 id="effort-estimation-heading">Effort Estimation</h2>
          
          <h3>Original LOE (Without Libraries)</h3>
          <table>
            <thead>
              <tr>
                <th>Task</th>
                <th>Hours</th>
                <th>Complexity</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Editor Component (6,069 lines)</td>
                <td>40-60</td>
                <td>Very High</td>
              </tr>
              <tr>
                <td>State Management Migration</td>
                <td>20-30</td>
                <td>High</td>
              </tr>
              <tr>
                <td>ContentEditable Integration</td>
                <td>15-25</td>
                <td>High</td>
              </tr>
              <tr>
                <td>Stories Page</td>
                <td>12-18</td>
                <td>Medium</td>
              </tr>
              <tr>
                <td>Authentication Flow</td>
                <td>8-12</td>
                <td>Medium</td>
              </tr>
              <tr>
                <td>Google Drive Integration</td>
                <td>8-12</td>
                <td>Medium</td>
              </tr>
              <tr>
                <td>CSS/Styling Updates</td>
                <td>10-15</td>
                <td>Medium</td>
              </tr>
              <tr>
                <td>Docs Page</td>
                <td>4-6</td>
                <td>Low</td>
              </tr>
              <tr>
                <td>Export Functionality</td>
                <td>6-10</td>
                <td>Medium</td>
              </tr>
              <tr>
                <td>Goal Tracking & UI Components</td>
                <td>8-12</td>
                <td>Medium</td>
              </tr>
              <tr>
                <td>React Setup & Configuration</td>
                <td>8-12</td>
                <td>Medium</td>
              </tr>
              <tr>
                <td>Testing & Bug Fixes</td>
                <td>20-30</td>
                <td>High</td>
              </tr>
              <tr>
                <td><strong>TOTAL</strong></td>
                <td><strong>159-220</strong></td>
                <td></td>
              </tr>
            </tbody>
          </table>
          <p><strong>Timeline:</strong> 4-11 weeks (depending on hours/week)</p>

          <h3>Revised LOE (With Third-Party Libraries)</h3>
          <table>
            <thead>
              <tr>
                <th>Task</th>
                <th>Hours</th>
                <th>Savings</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Text Editor (TipTap - Plain Text Only)</td>
                <td>15-25</td>
                <td>25-35 hrs</td>
              </tr>
              <tr>
                <td>UI Components (Material UI)</td>
                <td>10-15</td>
                <td>20-25 hrs</td>
              </tr>
              <tr>
                <td>Drag & Drop (@dnd-kit)</td>
                <td>4-6</td>
                <td>11-14 hrs</td>
              </tr>
              <tr>
                <td>Forms & Inputs (React Hook Form)</td>
                <td>3-4</td>
                <td>5-8 hrs</td>
              </tr>
              <tr>
                <td>State Management</td>
                <td>20-30</td>
                <td>0 hrs</td>
              </tr>
              <tr>
                <td>Stories Page</td>
                <td>8-12</td>
                <td>4-6 hrs</td>
              </tr>
              <tr>
                <td>Authentication Flow</td>
                <td>6-8</td>
                <td>2-4 hrs</td>
              </tr>
              <tr>
                <td>Google Drive Integration</td>
                <td>6-8</td>
                <td>2-4 hrs</td>
              </tr>
              <tr>
                <td>CSS/Styling Updates</td>
                <td>8-10</td>
                <td>2-5 hrs</td>
              </tr>
              <tr>
                <td>Docs Page</td>
                <td>2-3</td>
                <td>2-3 hrs</td>
              </tr>
              <tr>
                <td>Export Functionality</td>
                <td>4-6</td>
                <td>2-4 hrs</td>
              </tr>
              <tr>
                <td>Goal Tracking</td>
                <td>6-8</td>
                <td>2-4 hrs</td>
              </tr>
              <tr>
                <td>React Setup & Configuration</td>
                <td>8-12</td>
                <td>0 hrs (includes TS setup)</td>
              </tr>
              <tr>
                <td>TypeScript Type Definitions</td>
                <td>8-12</td>
                <td>-8-12 hrs (adds time but saves debugging)</td>
              </tr>
              <tr>
                <td>Testing & Bug Fixes</td>
                <td>12-20</td>
                <td>8 hrs (TypeScript catches errors earlier)</td>
              </tr>
              <tr>
                <td><strong>TOTAL</strong></td>
                <td><strong>105-160</strong></td>
                <td><strong>66-87 hrs saved</strong></td>
              </tr>
            </tbody>
          </table>

          <h3>Timeline Estimates</h3>
          <table>
            <thead>
              <tr>
                <th>Scenario</th>
                <th>Hours</th>
                <th>Weeks (40hr)</th>
                <th>Weeks (20hr)</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Optimistic</strong></td>
                <td>67</td>
                <td>1.7</td>
                <td>3.3</td>
              </tr>
              <tr>
                <td><strong>Realistic</strong></td>
                <td>86</td>
                <td>2.1</td>
                <td>4.3</td>
              </tr>
              <tr>
                <td><strong>Pessimistic</strong></td>
                <td>105</td>
                <td>2.6</td>
                <td>5.3</td>
              </tr>
            </tbody>
          </table>
        </section>

        <section class="docs-section" id="implementation-details">
          <h2 id="implementation-details-heading">Implementation Details</h2>
          
          <h3>Modals (8 Total)</h3>
          <ol>
            <li><strong>Story Info Modal</strong> - Edit story title, genre, description, word goal</li>
            <li><strong>Export Filename Modal</strong> - User-provided filename for exports</li>
            <li><strong>Description Edit Modal</strong> - Edit chapter/snippet descriptions</li>
            <li><strong>Goal Panel Modal</strong> - Set writing goals (target, deadline, days, mode)</li>
            <li><strong>Rename Modal</strong> - Rename chapters/snippets</li>
            <li><strong>Delete Confirmation Modal</strong> - Confirm deletion</li>
            <li><strong>Snippet Conflict Resolution Modal</strong> - Resolve Yarny vs Google Docs conflicts</li>
            <li><strong>Comments Warning Modal</strong> - Warn about comments/tracked changes in Google Docs</li>
          </ol>

          <h3>Color System</h3>
          
          <h4>Primaries (Brand)</h4>
          <ul>
            <li><strong>Primary</strong>: <code>#10B981</code></li>
            <li><strong>Primary-light</strong>: <code>#D1FAE5</code></li>
            <li><strong>Primary-dark</strong>: <code>#059669</code></li>
          </ul>

          <h4>12 Categorical Accents (Chapter/Snippet Colors)</h4>
          <p>Each accent color has four variants: base (solid), soft (pale), dark, and on-solid (text color for contrast).</p>
          
          <ol>
            <li><strong>Red</strong>
              <ul>
                <li>Base: <code>#EF4444</code></li>
                <li>Soft: <code>#FEE2E2</code></li>
                <li>Dark: <code>#991B1B</code></li>
                <li>On-solid: <code>#FFFFFF</code></li>
              </ul>
            </li>
            <li><strong>Orange</strong>
              <ul>
                <li>Base: <code>#F97316</code></li>
                <li>Soft: <code>#FFEDD5</code></li>
                <li>Dark: <code>#9A3412</code></li>
                <li>On-solid: <code>#FFFFFF</code></li>
              </ul>
            </li>
            <li><strong>Amber</strong>
              <ul>
                <li>Base: <code>#F59E0B</code></li>
                <li>Soft: <code>#FEF3C7</code></li>
                <li>Dark: <code>#92400E</code></li>
                <li>On-solid: <code>#1F2937</code></li>
              </ul>
            </li>
            <li><strong>Yellow</strong>
              <ul>
                <li>Base: <code>#EAB308</code></li>
                <li>Soft: <code>#FEF9C3</code></li>
                <li>Dark: <code>#854D0E</code></li>
                <li>On-solid: <code>#1F2937</code></li>
              </ul>
            </li>
            <li><strong>Lime</strong>
              <ul>
                <li>Base: <code>#84CC16</code></li>
                <li>Soft: <code>#ECFCCB</code></li>
                <li>Dark: <code>#365314</code></li>
                <li>On-solid: <code>#0B1220</code></li>
              </ul>
            </li>
            <li><strong>Emerald</strong>
              <ul>
                <li>Base: <code>#10B981</code></li>
                <li>Soft: <code>#D1FAE5</code></li>
                <li>Dark: <code>#065F46</code></li>
                <li>On-solid: <code>#FFFFFF</code></li>
              </ul>
            </li>
            <li><strong>Teal</strong>
              <ul>
                <li>Base: <code>#14B8A6</code></li>
                <li>Soft: <code>#CCFBF1</code></li>
                <li>Dark: <code>#115E59</code></li>
                <li>On-solid: <code>#FFFFFF</code></li>
              </ul>
            </li>
            <li><strong>Cyan</strong>
              <ul>
                <li>Base: <code>#06B6D4</code></li>
                <li>Soft: <code>#CFFAFE</code></li>
                <li>Dark: <code>#155E75</code></li>
                <li>On-solid: <code>#FFFFFF</code></li>
              </ul>
            </li>
            <li><strong>Blue</strong>
              <ul>
                <li>Base: <code>#3B82F6</code></li>
                <li>Soft: <code>#DBEAFE</code></li>
                <li>Dark: <code>#1E40AF</code></li>
                <li>On-solid: <code>#FFFFFF</code></li>
              </ul>
            </li>
            <li><strong>Indigo</strong>
              <ul>
                <li>Base: <code>#6366F1</code></li>
                <li>Soft: <code>#E0E7FF</code></li>
                <li>Dark: <code>#3730A3</code></li>
                <li>On-solid: <code>#FFFFFF</code></li>
              </ul>
            </li>
            <li><strong>Violet</strong>
              <ul>
                <li>Base: <code>#8B5CF6</code></li>
                <li>Soft: <code>#EDE9FE</code></li>
                <li>Dark: <code>#5B21B6</code></li>
                <li>On-solid: <code>#FFFFFF</code></li>
              </ul>
            </li>
            <li><strong>Fuchsia</strong>
              <ul>
                <li>Base: <code>#D946EF</code></li>
                <li>Soft: <code>#FAE8FF</code></li>
                <li>Dark: <code>#86198F</code></li>
                <li>On-solid: <code>#FFFFFF</code></li>
              </ul>
            </li>
          </ol>

          <h4>Neutrals (Text on Soft Chips)</h4>
          <ul>
            <li><strong>Ink-900</strong>: <code>#0F172A</code></li>
            <li><strong>Ink-700</strong>: <code>#334155</code></li>
            <li><strong>Ink-500</strong>: <code>#64748B</code></li>
          </ul>

          <h4>Usage Notes</h4>
          <ul>
            <li><strong>Soft</strong>: Use for left-rail "pale chip" backgrounds and subtle tag pills. Pair with Ink-900 text and a 1px border in the base color.</li>
            <li><strong>Base (solid)</strong>: Use for stronger chips, selected rows, or small badges. Use the listed on-solid color to maintain contrast.</li>
            <li><strong>Dark</strong>: Use for hover states, borders, or focus rings for the same accent.</li>
          </ul>

          <h3>Export Types</h3>
          <ol>
            <li><strong>Export All Chapters</strong> - All chapters with optional snippet names</li>
            <li><strong>Export Outline</strong> - Chapter and snippet titles with descriptions</li>
            <li><strong>Export All People</strong> - All person snippets</li>
            <li><strong>Export All Places</strong> - All place snippets</li>
            <li><strong>Export All Things</strong> - All thing snippets</li>
          </ol>
          <p><strong>Note on Large Exports</strong>: For "Export All" operations on large stories (25+ chapters, 200+ snippets), consider batching on the server (Netlify Function) to avoid client-side rate limits and improve reliability. Show progress toast during server-side batch exports, with Drive links to completed exports as they land.</p>

          <h3>Goal System Features</h3>
          <ul>
            <li><strong>Target</strong>: Total word count goal</li>
            <li><strong>Deadline</strong>: Target completion date</li>
            <li><strong>Writing Days</strong>: Selectable days of week (Mon-Sun)</li>
            <li><strong>Mode</strong>:
              <ul>
                <li>Elastic: Rebalances daily targets based on progress</li>
                <li>Strict: Fixed daily targets regardless of progress</li>
              </ul>
            </li>
            <li><strong>Days Off</strong>: Comma-separated dates to exclude</li>
            <li><strong>Midnight Rollover</strong>: Handles day boundary crossings</li>
          </ul>

          <h3>Code Statistics</h3>
          <ul>
            <li><strong>Total Functions</strong>: ~987 functions across all JS files</li>
            <li><strong>Error Logging</strong>: Custom system with localStorage persistence</li>
            <li><strong>Background Loading</strong>: Optimized batch loading with throttled updates</li>
          </ul>
        </section>

        <section class="docs-section" id="state-normalization">
          <h2 id="state-normalization-heading">
            State Normalization (P1 Priority)
          </h2>

          <h3>Overview</h3>
          <p><strong>Why</strong>: Moving to React is the perfect moment to stop passing giant nested objects around. Normalized state keeps renders cheap, enables virtualized lists later, and makes the codebase more maintainable.</p>
          <p><strong>What</strong>: Model all entities (stories, groups, snippets, notes, tags, goals) keyed by id in the Zustand store. Use selectors to derive views (e.g., left-rail lists). This keeps renders cheap and enables virtualized lists later.</p>

          <h3>Implementation Strategy</h3>

          <h4>1. Normalized Store Structure</h4>
          <p>All entities will be stored in normalized form (keyed by id) in the Zustand store:</p>
          <pre><code>// src/store/types.ts
export interface AppState {
  // Normalized entities - keyed by id
  stories: Record&lt;string, Story&gt;;
  groups: Record&lt;string, Group&gt;;
  snippets: Record&lt;string, Snippet&gt;;
  notes: Record&lt;string, Note&gt;; // People, Places, Things
  tags: Record&lt;string, Tag&gt;;
  goals: Record&lt;string, Goal&gt;;
  
  // Denormalized views - derived via selectors
  project: {
    storyId: string | null;
    groupIds: string[]; // Ordered list of group ids
    snippetIds: string[]; // Ordered list of snippet ids
    activeSnippetId: string | null;
    activeRightTab: 'people' | 'places' | 'things';
    filters: {
      search: string;
    };
  };
  
  // UI state
  collapsedGroups: Set&lt;string&gt;;
  editing: {
    savingState: 'idle' | 'saving' | 'saved';
    lastSavedAt: string | null;
  };
}</code></pre>

          <h4>2. Memoized Selectors for Derived Views</h4>
          <p>Create <strong>memoized selectors</strong> to derive views from normalized state. Memoization prevents unnecessary re-renders when unrelated entities change:</p>
          <pre><code>// src/store/selectors.ts
import { useStore } from './store';
import { useMemo } from 'react';

// Get groups as array (for left-rail list) - MEMOIZED
export function useGroupsList() {
  const groupIds = useStore((state) => state.project.groupIds);
  const groups = useStore((state) => state.groups);
  
  return useMemo(() => {
    return groupIds
      .map((id) => groups[id])
      .filter(Boolean); // Filter out any missing groups
  }, [groupIds, groups]);
}

// Get snippets for a specific group - MEMOIZED
export function useGroupSnippets(groupId: string) {
  const group = useStore((state) => state.groups[groupId]);
  const snippets = useStore((state) => state.snippets);
  
  return useMemo(() => {
    if (!group) return [];
    return group.snippetIds
      .map((id) => snippets[id])
      .filter(Boolean);
  }, [group, snippets]);
}

// Get active snippet ONLY - for editor viewport (pure component)
export function useActiveSnippet() {
  const activeSnippetId = useStore((state) => state.project.activeSnippetId);
  const snippet = useStore((state) => 
    activeSnippetId ? state.snippets[activeSnippetId] : null
  );
  
  // Only re-render when active snippet changes, not when other snippets update
  return useMemo(() => snippet, [snippet]);
}

// Get filtered groups (for search)
export function useFilteredGroups() {
  return useStore((state) => {
    const { project, groups } = state;
    const search = project.filters.search.toLowerCase();
    if (!search) {
      return project.groupIds.map((id) => groups[id]).filter(Boolean);
    }
    return project.groupIds
      .map((id) => groups[id])
      .filter((group) => {
        if (!group) return false;
        // Search in group title
        if (group.title.toLowerCase().includes(search)) return true;
        // Search in group snippets
        return group.snippetIds.some((snippetId) => {
          const snippet = state.snippets[snippetId];
          if (!snippet) return false;
          return (
            snippet.title.toLowerCase().includes(search) ||
            snippet.body.toLowerCase().includes(search)
          );
        });
      });
  });
}

// Get notes by type (People, Places, Things)
export function useNotesByType(type: 'person' | 'place' | 'thing') {
  return useStore((state) => {
    return Object.values(state.notes).filter((note) => note.kind === type);
  });
}</code></pre>

          <h4>3. Order Persistence in Drive Metadata</h4>
          <p><strong>Critical</strong>: Order (groupIds/snippetIds) is a <strong>first-class field</strong> that must be persisted in Drive metadata. This ensures:</p>
          <ul>
            <li>Reorders survive concurrent edits (order changes are persisted independently of content)</li>
            <li>Order doesn't revert after background loads (order is stored in Drive, not just in-memory state)</li>
            <li>Order is authoritative source of truth (Drive metadata determines display order)</li>
          </ul>
          <p><strong>Implementation</strong>:</p>
          <ul>
            <li>Store order in Drive metadata files (e.g., <code>story.json</code> contains <code>groupIds</code> array, <code>chapter.json</code> contains <code>snippetIds</code> array)</li>
            <li>When reordering chapters/snippets, update both in-memory state AND Drive metadata</li>
            <li>On load, read order from Drive metadata first, then populate entities</li>
            <li>Order changes trigger Drive write operations (not just in-memory updates)</li>
          </ul>
          <p><strong>Drive Metadata Structure</strong>:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// story.json in Drive
{
  "id": "story-1",
  "title": "My Story",
  "groupIds": ["group-1", "group-2", "group-3"], // ORDER IS PERSISTED HERE
  // ... other story fields
}

// chapter.json in Drive
{
  "id": "group-1",
  "title": "Chapter 1",
  "snippetIds": ["snippet-1", "snippet-2", "snippet-3"], // ORDER IS PERSISTED HERE
  // ... other chapter fields
}</code></pre>

          <h4>4. Benefits of Normalization + Memoized Selectors</h4>
          <ol>
            <li><strong>Cheap Renders</strong>: Components only re-render when their specific entities change, not when unrelated entities update
              <ul>
                <li><strong>Editor viewport as pure component</strong>: Only subscribes to active snippet's slice, not entire state tree</li>
                <li><strong>Memoized selectors</strong>: Prevent unnecessary recalculations when unrelated entities change</li>
              </ul>
            </li>
            <li><strong>Virtualized Lists</strong>: Normalized structure makes it easy to implement virtual scrolling for long lists later</li>
            <li><strong>Single Source of Truth</strong>: Each entity exists once in the store, eliminating duplication</li>
            <li><strong>Efficient Updates</strong>: Updating a single entity doesn't require re-rendering entire lists</li>
            <li><strong>Type Safety</strong>: TypeScript ensures we access entities correctly via selectors</li>
            <li><strong>Prevents State Churn</strong>: Normalized structure + memoized selectors prevent cascading re-renders during typing</li>
          </ol>

          <h4>4. Migration from Current Structure</h4>
          <p><strong>Before (nested objects)</strong>:</p>
          <pre><code>// ❌ DON'T DO THIS
const state = {
  groups: [
    {
      id: '1',
      title: 'Chapter 1',
      snippets: [
        { id: '1-1', title: 'Snippet 1', body: '...' },
        { id: '1-2', title: 'Snippet 2', body: '...' },
      ],
    },
  ],
};</code></pre>

          <p><strong>After (normalized)</strong>:</p>
          <pre><code>// ✅ DO THIS
const state = {
  groups: {
    '1': { id: '1', title: 'Chapter 1', snippetIds: ['1-1', '1-2'] },
  },
  snippets: {
    '1-1': { id: '1-1', title: 'Snippet 1', body: '...', groupId: '1' },
    '1-2': { id: '1-2', title: 'Snippet 2', body: '...', groupId: '1' },
  },
  project: {
    groupIds: ['1'],
  },
};

// Use selector to get groups as array
const groupsList = useGroupsList(); // Returns array of groups</code></pre>

          <h3>Implementation Timeline</h3>
          <p>This should be implemented in <strong>Phase 1</strong> (Setup & Infrastructure) as it's foundational:</p>
          <ul>
            <li>Define normalized state structure in <code>src/store/types.ts</code></li>
            <li>Create Zustand store with normalized entities</li>
            <li>Create <strong>memoized selectors</strong> in <code>src/store/selectors.ts</code> (including <code>useActiveSnippet</code> for pure editor component)</li>
            <li>Update all components to use selectors instead of direct state access</li>
            <li>Ensure editor viewport only subscribes to active snippet's slice (pure component pattern)</li>
          </ul>
          <p><strong>LOE</strong>: 4-6 hours (adds time but saves significant debugging, prevents state churn, and enables future optimizations)</p>
        </section>

        <section class="docs-section" id="custom-implementation">
          <h2 id="what-needs-custom-implementation">What Needs Custom Implementation</h2>
          <p>These areas cannot be replaced with libraries and require custom React code:</p>

          <h3>1. State Management Architecture</h3>
          <ul>
            <li><strong>Current</strong>: Global <code>state</code> object with direct mutations and nested structures</li>
            <li><strong>React + TypeScript</strong>: Zustand with TypeScript interfaces and <strong>normalized state structure</strong></li>
            <li><strong>Complexity</strong>: High</li>
            <li><strong>Lines</strong>: ~500-800 lines of state logic + type definitions + selectors</li>
            <li><strong>TypeScript</strong>: Will create interfaces for all state structures (Group, Snippet, Project, Goal, etc.)</li>
            <li><strong>Normalization</strong>: All entities (stories, groups, snippets, notes, tags, goals) keyed by id in the store; selectors derive views (e.g., left-rail lists)</li>
            <li><strong>Benefits</strong>: Keeps renders cheap, enables virtualized lists later, single source of truth</li>
          </ul>

          <h3>2. Google Drive Integration</h3>
          <ul>
            <li><strong>Current</strong>: API calls in <code>drive.js</code></li>
            <li><strong>React + TypeScript</strong>: Convert to React Query hooks using TanStack Query for ALL Drive I/O operations</li>
            <li><strong>Complexity</strong>: Medium</li>
            <li><strong>Status</strong>: Backend already works, just needs React Query wrapper</li>
            <li><strong>TypeScript</strong>: Will create interfaces for API responses and request parameters</li>
            <li><strong>Critical</strong>: ALL Drive operations (read, write, list, delete, rename, check comments, etc.) MUST use React Query, not ad-hoc useEffect hooks</li>
            <li><strong>Benefits</strong>: Automatic deduplication, retries, stale-while-revalidate, cache invalidation, loading/error states</li>
          </ul>

          <h3>3. Word Counting Logic</h3>
          <ul>
            <li><strong>Current</strong>: <code>countWords()</code> function</li>
            <li><strong>React</strong>: Can be reused as-is or converted to hook</li>
            <li><strong>Complexity</strong>: Low</li>
            <li><strong>Lines</strong>: ~50-100 lines</li>
          </ul>

          <h3>4. Goal Calculation Algorithms</h3>
          <ul>
            <li><strong>Current</strong>: Complex date/word calculation logic</li>
            <li><strong>React</strong>: Convert to hooks (<code>useGoal</code>, <code>useDailyTarget</code>)</li>
            <li><strong>Complexity</strong>: Medium-High</li>
            <li><strong>Lines</strong>: ~200-300 lines</li>
          </ul>

          <h3>5. Export Functionality</h3>
          <ul>
            <li><strong>Current</strong>: Custom export logic for chapters/outline/notes</li>
            <li><strong>React</strong>: Convert to utility functions or hooks</li>
            <li><strong>Complexity</strong>: Medium-High</li>
            <li><strong>Lines</strong>: ~300-400 lines (includes chunking logic)</li>
            <li><strong>Details</strong>:
              <ul>
                <li>Exports to Google Docs format</li>
                <li>Supports 5 export types (chapters, outline, people, places, things)</li>
                <li>Optional snippet name inclusion</li>
                <li>User-provided filenames</li>
                <li><strong>Chunked writes for large chapters</strong>: When a chapter contains many snippets (50+), split export into multiple batchUpdate requests to avoid Google Docs API body size limits</li>
                <li><strong>Batch size calculation</strong>: Estimate request size and chunk accordingly (typically ~100KB per batchUpdate request)</li>
                <li><strong>Progress indication</strong>: Show progress during chunked exports</li>
              </ul>
            </li>
          </ul>

          <h3>6. Search/Filtering Logic</h3>
          <ul>
            <li><strong>Current</strong>: Inline filtering in render functions</li>
            <li><strong>React</strong>: Convert to <code>useMemo</code> hooks</li>
            <li><strong>Complexity</strong>: Low-Medium</li>
            <li><strong>Lines</strong>: ~100-150 lines</li>
            <li><strong>Details</strong>:
              <ul>
                <li>Searches group titles, snippet titles, and snippet body content</li>
                <li>Case-insensitive matching</li>
              </ul>
            </li>
          </ul>

          <h3>7. Authentication Flow</h3>
          <ul>
            <li><strong>Current</strong>: Google Sign-In SDK integration</li>
            <li><strong>React</strong>: Convert to context + hooks</li>
            <li><strong>Complexity</strong>: Medium</li>
            <li><strong>Lines</strong>: ~200-300 lines</li>
            <li><strong>Details</strong>:
              <ul>
                <li>48-hour session expiration</li>
                <li>Token validation</li>
                <li>Auto-redirect logic</li>
                <li>Dev mode bypass for localhost</li>
              </ul>
            </li>
          </ul>

          <h3>8. Lazy Loading Logic</h3>
          <ul>
            <li><strong>Current</strong>: Background loading of snippet content</li>
            <li><strong>React</strong>: Convert to React Query with prefetching and background refetching</li>
            <li><strong>Complexity</strong>: Medium</li>
            <li><strong>Lines</strong>: ~300-400 lines</li>
            <li><strong>Details</strong>:
              <ul>
                <li>Loads active snippet first, then background loads remaining</li>
                <li>Uses React Query's <code>prefetchQuery</code> and <code>useQueries</code> for batch loading</li>
                <li>React Query handles throttling and prevents duplicate requests automatically</li>
                <li>Prevents UI blocking with React Query's built-in background refetching</li>
                <li><strong>Note</strong>: This is part of the broader React Query strategy for ALL Drive I/O</li>
              </ul>
            </li>
          </ul>

          <h3>9. Mobile Detection</h3>
          <ul>
            <li><strong>Current</strong>: User agent and touch detection</li>
            <li><strong>React</strong>: Convert to custom hook (<code>useMobileDetection</code>)</li>
            <li><strong>Complexity</strong>: Low</li>
            <li><strong>Lines</strong>: ~50 lines</li>
            <li><strong>Details</strong>: Shows warning message for mobile devices</li>
          </ul>

          <h3>10. Error Logging System</h3>
          <ul>
            <li><strong>Current</strong>: Custom localStorage-based error logging</li>
            <li><strong>React</strong>: Can reuse or convert to error boundary + logging service</li>
            <li><strong>Complexity</strong>: Low-Medium</li>
            <li><strong>Lines</strong>: ~100 lines</li>
            <li><strong>Details</strong>:
              <ul>
                <li>Logs errors to localStorage (max 50)</li>
                <li>Captures console errors, unhandled rejections</li>
                <li>Exposes <code>viewYarnyErrors()</code> function</li>
              </ul>
            </li>
          </ul>

          <h3>11. Midnight Rollover Handling</h3>
          <ul>
            <li><strong>Current</strong>: Handles goal calculation across day boundaries</li>
            <li><strong>React</strong>: Convert to hook with date change detection</li>
            <li><strong>Complexity</strong>: Medium</li>
            <li><strong>Lines</strong>: ~100-150 lines</li>
            <li><strong>Details</strong>: Recalculates daily targets when crossing midnight</li>
          </ul>

          <h3>12. Goal Calculation Modes</h3>
          <ul>
            <li><strong>Current</strong>: Elastic (rebalances) vs Strict (fixed) modes</li>
            <li><strong>React</strong>: Convert to hook with mode-specific logic</li>
            <li><strong>Complexity</strong>: Medium</li>
            <li><strong>Lines</strong>: ~200-300 lines</li>
            <li><strong>Details</strong>:
              <ul>
                <li>Elastic: Adjusts daily targets based on progress</li>
                <li>Strict: Fixed daily targets</li>
                <li>Writing days selection (Mon-Sun)</li>
                <li>Days off support</li>
              </ul>
            </li>
          </ul>
        </section>

        <section class="docs-section" id="fetch-caching">
          <h2 id="fetch-caching-heading">Fetch/Caching Layer with TanStack Query (P1 Priority)</h2>
          
          <h3>Overview</h3>
          <p><strong>Why</strong>: Multiple components will read/write the same Drive resources. Manual <code>useEffect</code> trees are brittle and lead to duplicate API calls, no automatic retry logic, manual cache management, inconsistent loading/error states, and race conditions.</p>
          <p><strong>What</strong>: Adopt <strong>TanStack Query (React Query)</strong> as the fetch/caching layer for ALL Drive I/O operations. This provides automatic deduplication, retries, stale-while-revalidate, cache invalidation, loading/error states, and background refetching.</p>

          <h3>Drive Operations Covered</h3>
          <p>ALL of these operations MUST use React Query (not ad-hoc useEffect):</p>
          <ol>
            <li>✅ <strong>List files/folders</strong> - <code>useDriveFiles()</code></li>
            <li>✅ <strong>Read file content</strong> - <code>useDriveFile()</code>, <code>useDriveFilesBatch()</code></li>
            <li>✅ <strong>Write/update file</strong> - <code>useWriteDriveFile()</code> mutation</li>
            <li>✅ <strong>Delete file</strong> - <code>useDeleteDriveFile()</code> mutation</li>
            <li>✅ <strong>Rename file</strong> - <code>useRenameDriveFile()</code> mutation</li>
            <li>✅ <strong>Check comments/changes</strong> - <code>useDriveComments()</code></li>
            <li>✅ <strong>Create folder</strong> - <code>useCreateFolder()</code> mutation</li>
            <li>✅ <strong>Get/create Yarny Stories folder</strong> - <code>useYarnyStoriesFolder()</code></li>
            <li>✅ <strong>Background/lazy loading</strong> - <code>prefetchQuery()</code> and <code>useQueries()</code></li>
          </ol>

          <h3>Benefits</h3>
          <ol>
            <li><strong>No Duplicate Requests</strong>: Multiple components reading the same file share one request</li>
            <li><strong>Automatic Retries</strong>: Failed requests retry automatically with exponential backoff</li>
            <li><strong>Visibility-Based Gating</strong>: Only refetch/prefetch when tab is visible (prevents request storms in background tabs)</li>
            <li><strong>Rate Limit Handling</strong>: Exponential backoff with jitter for 429 responses, prevents quota exhaustion</li>
            <li><strong>Stale-While-Revalidate</strong>: Show cached data immediately, update in background</li>
            <li><strong>Cache Invalidation</strong>: Mutations automatically invalidate related queries</li>
            <li><strong>Loading States</strong>: Built-in <code>isLoading</code>, <code>isFetching</code>, <code>isError</code> states</li>
            <li><strong>Background Refetching</strong>: Keep data fresh without blocking UI (only when tab is visible)</li>
            <li><strong>Optimistic Updates</strong>: Can implement optimistic UI updates for better UX</li>
            <li><strong>Type Safety</strong>: Full TypeScript support with typed queries and mutations</li>
          </ol>

          <h3>Implementation Timeline</h3>
          <p>This should be implemented in <strong>Phase 1</strong> (Setup & Infrastructure) alongside API contract formalization:</p>
          <ul>
            <li>Install <code>@tanstack/react-query</code></li>
            <li>Set up <code>QueryClient</code> and <code>QueryClientProvider</code></li>
            <li>Create <code>useDriveQueries.ts</code> with all Drive operation hooks</li>
            <li>Update all components to use React Query hooks instead of direct API calls</li>
            <li>Replace lazy loading logic with React Query prefetching</li>
          </ul>
          <p><strong>LOE:</strong> 6-8 hours (adds time but saves significant debugging and provides better UX)</p>
        </section>

        <section class="docs-section" id="api-contract">
          <h2 id="api-contract-heading">API Contract Formalization (P1 Priority)</h2>
          
          <h3>Overview</h3>
          <p><strong>Why</strong>: TypeScript on the client is only half the story. We need a typed boundary with runtime validation so Drive/Docs responses don't surprise us during the migration. This reduces "works in dev, breaks in prod" bugs during the cut-over.</p>
          <p><strong>What</strong>: Define a minimal "API contract" (types + runtime validation) for every endpoint we hit (auth, Drive metadata, snapshot list). Keep it central and use it consistently.</p>

          <h3>Implementation Strategy</h3>
          
          <h4>1. Centralized API Contract Module</h4>
          <p>Create <code>src/api/contract.ts</code> that defines:</p>
          <ul>
            <li><strong>TypeScript types</strong> for all request/response shapes</li>
            <li><strong>Zod schemas</strong> for runtime validation</li>
            <li><strong>Single source of truth</strong> for all API contracts</li>
          </ul>
          <p><strong>Why Zod?</strong></p>
          <ul>
            <li>TypeScript-first schema validation</li>
            <li>Automatic type inference from schemas</li>
            <li>Small bundle size (~8KB)</li>
            <li>Excellent error messages</li>
            <li>Can generate TypeScript types from schemas</li>
          </ul>

          <h4>2. API Client Wrapper</h4>
          <p>Create <code>src/api/client.ts</code> that:</p>
          <ul>
            <li>Provides typed functions for each endpoint</li>
            <li>Automatically validates requests and responses using Zod</li>
            <li>Handles errors consistently</li>
            <li>Provides type-safe API calls throughout the app</li>
          </ul>

          <h4>3. File Structure</h4>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>src/api/
├── contract.ts      # Type definitions + Zod schemas for all endpoints
├── client.ts       # Typed API client functions
└── types.ts        # Shared TypeScript types (if needed)</code></pre>

          <h3>Endpoints to Cover</h3>
          
          <h4>Authentication Endpoints</h4>
          <ul>
            <li><code>POST /.netlify/functions/verify-google</code> - Verify Google ID token</li>
            <li><code>POST /.netlify/functions/logout</code> - Clear session</li>
            <li><code>GET /.netlify/functions/config</code> - Get Google Client ID</li>
          </ul>

          <h4>Drive Integration Endpoints</h4>
          <ul>
            <li><code>GET /.netlify/functions/drive-list</code> - List files/folders</li>
            <li><code>POST /.netlify/functions/drive-read</code> - Read file content</li>
            <li><code>POST /.netlify/functions/drive-write</code> - Write/update file</li>
            <li><code>POST /.netlify/functions/drive-check-comments</code> - Check for comments/tracked changes</li>
            <li><code>POST /.netlify/functions/drive-create-folder</code> - Create folder</li>
            <li><code>POST /.netlify/functions/drive-delete-story</code> - Delete story folder</li>
            <li><code>GET /.netlify/functions/drive-get-or-create-yarny-stories</code> - Get or create Yarny Stories folder</li>
            <li><code>POST /.netlify/functions/drive-delete-file</code> - Delete file</li>
            <li><code>POST /.netlify/functions/drive-rename-file</code> - Rename file</li>
            <li><code>GET /.netlify/functions/drive-auth</code> - Initiate Drive OAuth (redirect)</li>
            <li><code>GET /.netlify/functions/drive-auth-callback</code> - OAuth callback (redirect)</li>
          </ul>

          <h4>Status Endpoints</h4>
          <ul>
            <li><code>GET /.netlify/functions/uptime-status</code> - Get uptime status</li>
          </ul>

          <h3>Example Implementation</h3>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/api/contract.ts
import { z } from 'zod';

// Request/Response schemas using Zod
export const VerifyGoogleRequestSchema = z.object({
  token: z.string().min(1),
});

export const VerifyGoogleResponseSchema = z.object({
  verified: z.boolean(),
  user: z.string().email(),
  name: z.string().optional(),
  picture: z.string().url().optional(),
  token: z.string(),
});

// Infer TypeScript types from schemas
export type VerifyGoogleRequest = z.infer&lt;typeof VerifyGoogleRequestSchema&gt;;
export type VerifyGoogleResponse = z.infer&lt;typeof VerifyGoogleResponseSchema&gt;;

// Drive file metadata schema
export const DriveFileSchema = z.object({
  id: z.string(),
  name: z.string(),
  mimeType: z.string(),
  modifiedTime: z.string().optional(),
  size: z.string().optional(),
  trashed: z.boolean().optional(),
});

export const DriveListResponseSchema = z.object({
  files: z.array(DriveFileSchema),
  nextPageToken: z.string().optional(),
});

export type DriveFile = z.infer&lt;typeof DriveFileSchema&gt;;
export type DriveListResponse = z.infer&lt;typeof DriveListResponseSchema&gt;;

// Drive read request/response
export const DriveReadRequestSchema = z.object({
  fileId: z.string().min(1),
});

export const DriveReadResponseSchema = z.object({
  id: z.string(),
  name: z.string(),
  mimeType: z.string(),
  modifiedTime: z.string().optional(),
  content: z.string(),
});

export type DriveReadRequest = z.infer&lt;typeof DriveReadRequestSchema&gt;;
export type DriveReadResponse = z.infer&lt;typeof DriveReadResponseSchema&gt;;

// Drive write request/response
export const DriveWriteRequestSchema = z.object({
  fileId: z.string().optional(),
  fileName: z.string().min(1),
  content: z.string(),
  parentFolderId: z.string().optional(),
  mimeType: z.string().default('text/plain'),
});

export const DriveWriteResponseSchema = z.object({
  id: z.string(),
  name: z.string(),
  modifiedTime: z.string().optional(),
});

export type DriveWriteRequest = z.infer&lt;typeof DriveWriteRequestSchema&gt;;
export type DriveWriteResponse = z.infer&lt;typeof DriveWriteResponseSchema&gt;;

// Error response schema (common across all endpoints)
export const ApiErrorResponseSchema = z.object({
  error: z.string(),
  message: z.string().optional(),
  requiresReauth: z.boolean().optional(),
});

export type ApiErrorResponse = z.infer&lt;typeof ApiErrorResponseSchema&gt;;</code></pre>

          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/api/client.ts
import axios from 'axios';
import { z } from 'zod';
import {
  VerifyGoogleRequestSchema,
  VerifyGoogleResponseSchema,
  DriveListResponseSchema,
  DriveReadRequestSchema,
  DriveReadResponseSchema,
  DriveWriteRequestSchema,
  DriveWriteResponseSchema,
  ApiErrorResponseSchema,
  type VerifyGoogleRequest,
  type VerifyGoogleResponse,
  type DriveListResponse,
  type DriveReadRequest,
  type DriveReadResponse,
  type DriveWriteRequest,
  type DriveWriteResponse,
} from './contract';

const API_BASE = '/.netlify/functions';

// Configure axios defaults
axios.defaults.withCredentials = true;

// Generic API call helper with validation
async function apiCall&lt;TRequest, TResponse&gt;(
  endpoint: string,
  request: TRequest,
  requestSchema: z.ZodSchema&lt;TRequest&gt;,
  responseSchema: z.ZodSchema&lt;TResponse&gt;,
  method: 'GET' | 'POST' = 'POST'
): Promise&lt;TResponse&gt; {
  // Validate request
  const validatedRequest = requestSchema.parse(request);

  try {
    const response = await (method === 'GET'
      ? axios.get(`${API_BASE}${endpoint}`, { params: validatedRequest })
      : axios.post(`${API_BASE}${endpoint}`, validatedRequest));

    // Validate response
    const validatedResponse = responseSchema.parse(response.data);
    return validatedResponse;
  } catch (error) {
    if (axios.isAxiosError(error) && error.response) {
      // Try to parse error response
      const errorData = ApiErrorResponseSchema.safeParse(error.response.data);
      if (errorData.success) {
        throw new Error(errorData.data.error);
      }
      throw new Error(error.response.data?.error || 'API request failed');
    }
    if (error instanceof z.ZodError) {
      // Validation error - this is a contract violation
      console.error('API contract violation:', error.errors);
      throw new Error(`Invalid API response: ${error.errors.map(e => e.message).join(', ')}`);
    }
    throw error;
  }
}

// Typed API functions
export async function verifyGoogle(
  request: VerifyGoogleRequest
): Promise&lt;VerifyGoogleResponse&gt; {
  return apiCall(
    '/verify-google',
    request,
    VerifyGoogleRequestSchema,
    VerifyGoogleResponseSchema
  );
}

export async function listDriveFiles(
  folderId?: string,
  pageToken?: string
): Promise&lt;DriveListResponse&gt; {
  const params = { folderId, pageToken };
  // For GET requests, we'll handle validation differently
  const response = await axios.get(`${API_BASE}/drive-list`, { params });
  return DriveListResponseSchema.parse(response.data);
}

export async function readDriveFile(
  request: DriveReadRequest
): Promise&lt;DriveReadResponse&gt; {
  return apiCall(
    '/drive-read',
    request,
    DriveReadRequestSchema,
    DriveReadResponseSchema
  );
}

export async function writeDriveFile(
  request: DriveWriteRequest
): Promise&lt;DriveWriteResponse&gt; {
  return apiCall(
    '/drive-write',
    request,
    DriveWriteRequestSchema,
    DriveWriteResponseSchema
  );
}

// ... additional endpoint functions</code></pre>

          <h3>Benefits</h3>
          <ol>
            <li><strong>Type Safety</strong>: Compile-time checking ensures we use correct request/response shapes</li>
            <li><strong>Runtime Validation</strong>: Zod catches shape mismatches at runtime, preventing "works in dev, breaks in prod" issues</li>
            <li><strong>Centralized Contracts</strong>: Single source of truth makes it easy to update when endpoints change</li>
            <li><strong>Better Error Messages</strong>: Zod provides clear validation error messages</li>
            <li><strong>Self-Documenting</strong>: Types serve as inline documentation</li>
            <li><strong>Migration Safety</strong>: During cut-over, validation ensures backend changes don't break the frontend silently</li>
          </ol>

          <h3>Implementation Timeline</h3>
          <p>This should be implemented in <strong>Phase 1</strong> (Setup & Infrastructure) as it's foundational:</p>
          <ul>
            <li>Create <code>src/api/contract.ts</code> with all endpoint schemas</li>
            <li>Create <code>src/api/client.ts</code> with typed API functions</li>
            <li>Update hooks (<code>useDrive</code>, <code>useAuth</code>) to use the typed client</li>
            <li>Add <code>zod</code> to dependencies</li>
          </ul>
          <p><strong>LOE:</strong> 4-6 hours (adds time but saves debugging during migration)</p>

          <h3>Dependencies</h3>
          <p>Add to <code>package.json</code>:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>{
  "dependencies": {
    "zod": "^3.x"
  }
}</code></pre>
        </section>

        <section class="docs-section" id="netlify-functions-typescript">
          <h2 id="netlify-functions-typescript-heading">Netlify Functions TypeScript Conversion (P1 Priority)</h2>
          
          <h3>Overview</h3>
          <p><strong>Why</strong>: Converting Netlify Functions to TypeScript provides end-to-end type safety between frontend and backend, ensures API contracts are enforced at compile time, and reduces runtime errors from mismatched request/response shapes.</p>
          <p><strong>What</strong>: Convert all Netlify Functions from JavaScript to TypeScript, add type annotations to all handlers, create shared types module, and ensure type safety across the entire stack.</p>

          <h3>Implementation Strategy</h3>
          
          <h4>1. TypeScript Configuration for Netlify Functions</h4>
          <p>Create <code>netlify/functions/tsconfig.json</code> for Netlify Functions:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "lib": ["ES2020"],
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "outDir": "./dist",
    "rootDir": ".",
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": ["./**/*.ts"],
  "exclude": ["node_modules", "dist"]
}</code></pre>

          <h4>2. Shared Types Module</h4>
          <p>Create <code>netlify/functions/types.ts</code> with shared types for all functions:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// netlify/functions/types.ts
import { Handler } from '@netlify/functions';

// Netlify Function handler types
export interface NetlifyHandler extends Handler {
  (event: NetlifyEvent, context: NetlifyContext): Promise&lt;NetlifyResponse&gt;;
}

export interface NetlifyEvent {
  httpMethod: string;
  path: string;
  headers: Record&lt;string, string&gt;;
  queryStringParameters: Record&lt;string, string&gt; | null;
  body: string | null;
  isBase64Encoded: boolean;
  multiValueHeaders?: Record&lt;string, string[]&gt;;
  multiValueQueryStringParameters?: Record&lt;string, string[]&gt; | null;
}

export interface NetlifyContext {
  requestId: string;
  functionName: string;
  functionVersion: string;
  invokedFunctionArn: string;
  memoryLimitInMB: string;
  awsRequestId: string;
  logGroupName: string;
  logStreamName: string;
  getRemainingTimeInMillis: () =&gt; number;
  done: (error?: Error, result?: any) =&gt; void;
  fail: (error: Error | string) =&gt; void;
  succeed: (messageOrObject: any) =&gt; void;
}

export interface NetlifyResponse {
  statusCode: number;
  headers?: Record&lt;string, string&gt;;
  body: string;
  isBase64Encoded?: boolean;
  multiValueHeaders?: Record&lt;string, string[]&gt;;
}

// Shared request/response types (aligned with frontend API contract)
export interface VerifyGoogleRequest {
  token: string;
}

export interface VerifyGoogleResponse {
  verified: boolean;
  user: string;
  name?: string;
  picture?: string;
  token: string;
}

export interface DriveListRequest {
  folderId?: string;
  pageToken?: string;
}

export interface DriveListResponse {
  files: DriveFile[];
  nextPageToken?: string;
}

export interface DriveFile {
  id: string;
  name: string;
  mimeType: string;
  modifiedTime?: string;
  size?: string;
  trashed?: boolean;
}

export interface DriveReadRequest {
  fileId: string;
}

export interface DriveReadResponse {
  id: string;
  name: string;
  mimeType: string;
  modifiedTime?: string;
  content: string;
}

export interface DriveWriteRequest {
  fileId?: string;
  fileName: string;
  content: string;
  parentFolderId?: string;
  mimeType?: string;
}

export interface DriveWriteResponse {
  id: string;
  name: string;
  modifiedTime?: string;
}

// Error response type
export interface ApiErrorResponse {
  error: string;
  message?: string;
  requiresReauth?: boolean;
}

// Helper function to create typed responses
export function createResponse&lt;T&gt;(
  statusCode: number,
  data: T,
  headers?: Record&lt;string, string&gt;
): NetlifyResponse {
  return {
    statusCode,
    headers: {
      'Content-Type': 'application/json',
      ...headers,
    },
    body: JSON.stringify(data),
  };
}

// Helper function to create error responses
export function createErrorResponse(
  statusCode: number,
  error: string,
  message?: string,
  requiresReauth?: boolean
): NetlifyResponse {
  return createResponse&lt;ApiErrorResponse&gt;(statusCode, {
    error,
    message,
    requiresReauth,
  });
}</code></pre>

          <h4>3. Example: Converting a Function to TypeScript</h4>
          <p><strong>Before (JavaScript)</strong>:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// netlify/functions/drive-read.js
exports.handler = async (event, context) =&gt; {
  const { fileId } = JSON.parse(event.body);
  
  try {
    const content = await readDriveFile(fileId);
    return {
      statusCode: 200,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(content),
    };
  } catch (error) {
    return {
      statusCode: 500,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ error: error.message }),
    };
  }
};</code></pre>

          <p><strong>After (TypeScript)</strong>:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// netlify/functions/drive-read.ts
import type { NetlifyHandler, DriveReadRequest, DriveReadResponse } from './types';
import { createResponse, createErrorResponse } from './types';
import { readDriveFile } from './drive-client';

export const handler: NetlifyHandler = async (event, context) =&gt; {
  // Validate request body
  if (!event.body) {
    return createErrorResponse(400, 'Missing request body');
  }

  let request: DriveReadRequest;
  try {
    request = JSON.parse(event.body);
  } catch (error) {
    return createErrorResponse(400, 'Invalid JSON in request body');
  }

  // Validate required fields
  if (!request.fileId) {
    return createErrorResponse(400, 'Missing required field: fileId');
  }

  try {
    const content = await readDriveFile(request.fileId);
    const response: DriveReadResponse = {
      id: content.id,
      name: content.name,
      mimeType: content.mimeType,
      modifiedTime: content.modifiedTime,
      content: content.content,
    };
    return createResponse&lt;DriveReadResponse&gt;(200, response);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    return createErrorResponse(500, 'Failed to read file', errorMessage);
  }
};</code></pre>

          <h4>4. Build Configuration</h4>
          <p>Update <code>netlify.toml</code> to compile TypeScript functions:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>[build]
  command = "npm run build"
  functions = "netlify/functions/dist"

[build.environment]
  NODE_VERSION = "20"</code></pre>

          <p>Add build script to <code>package.json</code>:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>{
  "scripts": {
    "build:functions": "tsc -p netlify/functions/tsconfig.json",
    "build": "npm run build:functions && vite build"
  }
}</code></pre>

          <h4>5. Type Alignment with Frontend</h4>
          <p>Ensure backend types in <code>netlify/functions/types.ts</code> align with frontend API contract in <code>src/api/contract.ts</code>. Consider:</p>
          <ul>
            <li><strong>Option 1</strong>: Share types via a shared package (if monorepo)</li>
            <li><strong>Option 2</strong>: Keep types in sync manually (documented in API contract section)</li>
            <li><strong>Option 3</strong>: Generate backend types from frontend Zod schemas (advanced)</li>
          </ul>
          <p>For v1, <strong>Option 2</strong> is recommended - keep types manually aligned and document the relationship.</p>

          <h3>Functions to Convert</h3>
          
          <h4>Authentication Functions (8 files)</h4>
          <ul>
            <li><code>auth/config.ts</code></li>
            <li><code>auth/login.ts</code></li>
            <li><code>auth/register.ts</code></li>
            <li><code>auth/storage.ts</code></li>
            <li><code>auth/verify-login.ts</code></li>
            <li><code>auth/verify-register.ts</code></li>
            <li><code>verify-google.ts</code></li>
            <li><code>logout.ts</code></li>
          </ul>

          <h4>Drive Functions (13 files)</h4>
          <ul>
            <li><code>drive-auth.ts</code></li>
            <li><code>drive-auth-callback.ts</code></li>
            <li><code>drive-check-comments.ts</code></li>
            <li><code>drive-client.ts</code> (shared utility)</li>
            <li><code>drive-create-folder.ts</code></li>
            <li><code>drive-delete-file.ts</code></li>
            <li><code>drive-delete-story.ts</code></li>
            <li><code>drive-get-or-create-yarny-stories.ts</code></li>
            <li><code>drive-list.ts</code></li>
            <li><code>drive-read.ts</code></li>
            <li><code>drive-rename-file.ts</code></li>
            <li><code>drive-write.ts</code></li>
          </ul>

          <h4>Utility Functions (2 files)</h4>
          <ul>
            <li><code>config.ts</code></li>
            <li><code>uptime-status.ts</code></li>
          </ul>

          <p><strong>Total</strong>: 23 function files + 1 shared types file = 24 TypeScript files</p>

          <h3>Benefits</h3>
          <ol>
            <li><strong>End-to-End Type Safety</strong>: TypeScript ensures frontend and backend types match at compile time</li>
            <li><strong>Better IDE Support</strong>: Autocomplete and type checking in function handlers</li>
            <li><strong>Catch Errors Early</strong>: Type mismatches caught during development, not runtime</li>
            <li><strong>Self-Documenting</strong>: Types serve as inline documentation for function contracts</li>
            <li><strong>Refactoring Safety</strong>: TypeScript ensures changes don't break function signatures</li>
            <li><strong>Consistent Error Handling</strong>: Typed error responses ensure consistent API error shapes</li>
          </ol>

          <h3>Implementation Timeline</h3>
          <p>This should be implemented in <strong>Phase 2</strong> (Authentication, Router & API Contract) alongside API contract formalization:</p>
          <ul>
            <li>Set up TypeScript configuration for Netlify Functions</li>
            <li>Create shared types module</li>
            <li>Convert all functions to TypeScript</li>
            <li>Test all functions with TypeScript compilation</li>
            <li>Ensure types align with frontend API contract</li>
          </ul>
          <p><strong>LOE:</strong> 8-12 hours (includes TypeScript setup, converting 23 function files, type annotations, and testing)</p>

          <h3>Dependencies</h3>
          <p>Add to <code>package.json</code>:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>{
  "devDependencies": {
    "@netlify/functions": "^2.x",
    "@types/node": "^20.x",
    "typescript": "^5.x"
  }
}</code></pre>
          <p><strong>Note</strong>: <code>@netlify/functions</code> provides TypeScript types for Netlify Function handlers.</p>
        </section>

        <section class="docs-section" id="offline-semantics">
          <h2 id="offline-semantics-heading">Offline/Spotty-Network Semantics (P2 Priority)</h2>
          
          <h3>Overview</h3>
          <p><strong>Why</strong>: Network connectivity issues (offline, spotty WiFi, flapping connections) are common in real-world usage. Users need clear feedback about save status, queued operations, and when the app is read-only vs. editable. React Query's retry/backoff and cache staleness policies must be tied to visible UX indicators.</p>
          <p><strong>What</strong>: Define explicit UX behavior for network states: queued saves, read-only mode, offline banners, and "Saved at..." indicator behavior tied to React Query's retry/backoff and cache staleness.</p>

          <h3>Network State Detection</h3>
          <p>Use React Query's <code>useIsFetching</code>, <code>useIsMutating</code>, and browser <code>navigator.onLine</code> API to detect network state:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/hooks/useNetworkStatus.ts
import { useIsFetching, useIsMutating } from '@tanstack/react-query';
import { useState, useEffect } from 'react';

export interface NetworkStatus {
  isOnline: boolean;
  isFetching: boolean;
  isMutating: boolean;
  hasPendingMutations: boolean;
  lastSavedAt: string | null;
  saveState: 'idle' | 'saving' | 'saved' | 'queued' | 'error';
}

export function useNetworkStatus(): NetworkStatus {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  const isFetching = useIsFetching() > 0;
  const isMutating = useIsMutating() > 0;
  
  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);
    
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  
  // Determine save state based on network and mutation status
  const saveState: NetworkStatus['saveState'] = 
    !isOnline ? 'queued' :
    isMutating ? 'saving' :
    'idle';
  
  return {
    isOnline,
    isFetching,
    isMutating,
    hasPendingMutations: isMutating,
    lastSavedAt: null, // Will be set by save hook
    saveState,
  };
}</code></pre>

          <h3>UX Behavior Definitions</h3>
          
          <h4>1. Queued Saves (Offline/Network Error)</h4>
          <p><strong>When</strong>: User edits while offline or network request fails (after retries exhausted)</p>
          <p><strong>Behavior</strong>:</p>
          <ul>
            <li><strong>Editor remains editable</strong>: User can continue typing and editing</li>
            <li><strong>Save state indicator</strong>: Shows "Queued" or "Waiting for connection..." instead of "Saved at X:XX"</li>
            <li><strong>Save queue</strong>: Mutations are queued in React Query's mutation queue (automatic via React Query)</li>
            <li><strong>Auto-retry on reconnect</strong>: When network returns, React Query automatically retries queued mutations</li>
            <li><strong>Visual indicator</strong>: Offline banner appears at top of editor (non-blocking, dismissible)</li>
          </ul>
          <p><strong>Implementation</strong>:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// In Editor component
const { isOnline, saveState } = useNetworkStatus();
const writeMutation = useWriteDriveFile();

// Show queued state in save indicator
{saveState === 'queued' && (
  &lt;div className="save-status queued"&gt;
    Waiting for connection... ({queuedCount} changes queued)
  &lt;/div&gt;
)}

// Offline banner
{!isOnline && (
  &lt;div className="offline-banner"&gt;
    You're offline. Changes will be saved when connection is restored.
  &lt;/div&gt;
)}</code></pre>

          <h4>2. Read-Only Mode (Stale Cache)</h4>
          <p><strong>When</strong>: Network is offline AND cache is stale (data older than <code>staleTime</code>)</p>
          <p><strong>Behavior</strong>:</p>
          <ul>
            <li><strong>Editor remains editable</strong>: User can type, but see warning that changes may conflict</li>
            <li><strong>Cache staleness indicator</strong>: Show "Using cached data" or "Last synced: X:XX" in footer</li>
            <li><strong>Read-only warning</strong>: If cache is very stale (&gt; 10 minutes), show warning: "You're viewing cached data. Some changes may not be saved."</li>
            <li><strong>Auto-refresh on reconnect</strong>: When network returns, React Query automatically refetches stale data</li>
          </ul>
          <p><strong>Implementation</strong>:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// Check cache staleness
const { data: file, dataUpdatedAt, isStale } = useDriveFile(fileId);

// Show staleness warning
{isStale && !isOnline && (
  &lt;div className="stale-cache-warning"&gt;
    Using cached data. Last synced: {new Date(dataUpdatedAt).toLocaleTimeString()}
  &lt;/div&gt;
)}</code></pre>

          <h4>3. Offline Banner</h4>
          <p><strong>When</strong>: <code>navigator.onLine === false</code> or network request fails with no retries remaining</p>
          <p><strong>Behavior</strong>:</p>
          <ul>
            <li><strong>Non-blocking</strong>: Banner appears at top of editor, doesn't block editing</li>
            <li><strong>Dismissible</strong>: User can dismiss banner (but it reappears if still offline)</li>
            <li><strong>Auto-dismiss</strong>: Banner disappears when network returns</li>
            <li><strong>Message</strong>: "You're offline. Changes will be saved when connection is restored."</li>
            <li><strong>Visual style</strong>: Subtle background color (e.g., amber/yellow), not red/error</li>
          </ul>
          <p><strong>Implementation</strong>:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/components/shared/OfflineBanner.tsx
export function OfflineBanner() {
  const { isOnline } = useNetworkStatus();
  const [dismissed, setDismissed] = useState(false);
  
  if (isOnline || dismissed) return null;
  
  return (
    &lt;div className="offline-banner"&gt;
      &lt;span&gt;You're offline. Changes will be saved when connection is restored.&lt;/span&gt;
      &lt;button onClick={() => setDismissed(true)}&gt;Dismiss&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

          <h4>4. "Saved at..." Indicator Behavior</h4>
          <p><strong>When</strong>: Save operation completes (success or queued)</p>
          <p><strong>Behavior</strong>:</p>
          <ul>
            <li><strong>Online + successful save</strong>: Show "Saved at X:XX" (current time)</li>
            <li><strong>Offline + queued</strong>: Show "Queued - will save when online" (no timestamp)</li>
            <li><strong>Network error + retrying</strong>: Show "Saving... (retrying)" with retry count</li>
            <li><strong>Network error + exhausted</strong>: Show "Queued - will save when online" (no timestamp)</li>
            <li><strong>Stale cache</strong>: Show "Last synced: X:XX" instead of "Saved at X:XX"</li>
          </ul>
          <p><strong>Implementation</strong>:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/components/editor/SaveStatus.tsx
export function SaveStatus() {
  const { isOnline, saveState, lastSavedAt } = useNetworkStatus();
  const writeMutation = useWriteDriveFile();
  
  if (saveState === 'saving') {
    return &lt;div className="save-status saving"&gt;Saving...&lt;/div&gt;;
  }
  
  if (saveState === 'queued') {
    return &lt;div className="save-status queued"&gt;Queued - will save when online&lt;/div&gt;;
  }
  
  if (saveState === 'saved' && lastSavedAt) {
    return &lt;div className="save-status saved"&gt;Saved at {new Date(lastSavedAt).toLocaleTimeString()}&lt;/div&gt;;
  }
  
  return null;
}</code></pre>

          <h4>5. React Query Integration</h4>
          <p><strong>Tie UX to React Query's retry/backoff and cache staleness</strong>:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/lib/react-query.ts (update existing config)
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes - data is fresh for 5 min
      gcTime: 10 * 60 * 1000, // 10 minutes - keep in cache for 10 min
      retry: retryWithBackoff, // Custom retry with visibility gating
      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
      refetchOnWindowFocus: false,
      refetchOnReconnect: true, // Auto-refetch when network reconnects
      // Network-aware: Don't retry if offline
      networkMode: 'online', // Only run queries when online
    },
    mutations: {
      retry: (failureCount, error) => {
        // Don't retry if offline
        if (!navigator.onLine) {
          return false; // Queue mutation instead
        }
        
        // Retry once on failure (excluding 4xx errors except 429)
        if (axios.isAxiosError(error)) {
          const status = error.response?.status;
          if (status && status >= 400 && status < 500 && status !== 429) {
            return false;
          }
          
          if (status === 429 && failureCount < 1) {
            return true;
          }
        }
        
        return failureCount < 1;
      },
      // Queue mutations when offline (React Query handles this automatically)
      networkMode: 'online', // Only run mutations when online, queue when offline
    },
  },
});</code></pre>

          <h3>Smoke Tests</h3>
          <p>Add to smoke test checklist:</p>
          <p><strong>L. Offline/Spotty-Network Semantics</strong>:</p>
          <ul>
            <li>[ ] <strong>Go offline</strong>: Disable network → Edit snippet → Verify editor remains editable</li>
            <li>[ ] <strong>Offline banner</strong>: Verify offline banner appears at top of editor</li>
            <li>[ ] <strong>Queued save</strong>: Verify save status shows "Queued - will save when online"</li>
            <li>[ ] <strong>Reconnect</strong>: Re-enable network → Verify queued saves automatically retry and complete</li>
            <li>[ ] <strong>Save status on reconnect</strong>: Verify "Saved at X:XX" appears after successful save</li>
            <li>[ ] <strong>Stale cache warning</strong>: Go offline → Wait 5+ minutes → Verify "Using cached data" warning appears</li>
            <li>[ ] <strong>Network flapping</strong>: Rapidly toggle network on/off → Verify save queue handles multiple toggles correctly</li>
            <li>[ ] <strong>Retry exhaustion</strong>: Simulate network error with no retries → Verify mutation is queued (not lost)</li>
            <li>[ ] <strong>Multiple queued saves</strong>: Go offline → Make multiple edits → Reconnect → Verify all saves complete in order</li>
            <li>[ ] <strong>Cache staleness</strong>: Load snippet → Go offline → Wait 10+ minutes → Verify "Last synced: X:XX" appears instead of "Saved at X:XX"</li>
          </ul>

          <h3>Implementation Timeline</h3>
          <p>This should be implemented in <strong>Phase 6</strong> (Lazy Loading & Exports) alongside auto-save functionality:</p>
          <ul>
            <li>Create <code>useNetworkStatus</code> hook</li>
            <li>Create <code>OfflineBanner</code> component</li>
            <li>Update <code>SaveStatus</code> component to handle offline/queued states</li>
            <li>Update React Query config with network-aware settings</li>
            <li>Add smoke tests for offline scenarios</li>
          </ul>
          <p><strong>LOE</strong>: 4-6 hours (includes network status hook, offline banner, save status updates, and smoke tests)</p>
        </section>

        <section class="docs-section" id="timezone-dst">
          <h2 id="timezone-dst-heading">Timezone/DST for "Goals that Think" (P2 Priority)</h2>
          
          <h3>Overview</h3>
          <p><strong>Why</strong>: Daily rollover and "Today" calculations must use the user's actual timezone to prevent confusion for travelers and night-owls. DST boundaries (spring forward/fall back) can cause "Today" to bounce around if not handled correctly.</p>
          <p><strong>What</strong>: Specify that daily rollover uses the user's IANA timezone (<code>Intl.DateTimeFormat().resolvedOptions().timeZone</code>) and test DST boundaries explicitly.</p>

          <h3>Implementation Strategy</h3>
          
          <h4>1. Timezone Detection</h4>
          <p>Use browser's IANA timezone identifier:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/utils/timezone.ts
export function getUserTimezone(): string {
  return Intl.DateTimeFormat().resolvedOptions().timeZone;
}

// Example: "America/New_York", "Europe/London", "Asia/Tokyo"</code></pre>

          <h4>2. Daily Rollover Calculation</h4>
          <p>Use timezone-aware date calculations for goal rollover:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/hooks/useGoal.ts
import { getUserTimezone } from '../utils/timezone';

export function useDailyTarget() {
  const timezone = getUserTimezone();
  
  // Get current date in user's timezone
  const getTodayInTimezone = (): Date => {
    const now = new Date();
    // Use Intl.DateTimeFormat to get date string in user's timezone
    const formatter = new Intl.DateTimeFormat('en-US', {
      timeZone: timezone,
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
    });
    const parts = formatter.formatToParts(now);
    const year = parseInt(parts.find(p => p.type === 'year')!.value);
    const month = parseInt(parts.find(p => p.type === 'month')!.value) - 1;
    const day = parseInt(parts.find(p => p.type === 'day')!.value);
    
    // Create date at midnight in user's timezone
    return new Date(Date.UTC(year, month, day));
  };
  
  // Calculate if we've crossed midnight in user's timezone
  const hasCrossedMidnight = (lastDate: Date): boolean => {
    const today = getTodayInTimezone();
    const lastDay = new Date(lastDate);
    lastDay.setHours(0, 0, 0, 0);
    
    return today.getTime() !== lastDay.getTime();
  };
}</code></pre>

          <h4>3. DST Boundary Testing</h4>
          <p>Test DST transitions explicitly:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/utils/timezone.test.ts
describe('DST Boundary Handling', () => {
  it('handles spring forward (loses hour)', () => {
    // Test date: March 10, 2024 2:00 AM EST → 3:00 AM EDT (spring forward)
    // Verify "Today" doesn't bounce around
  });
  
  it('handles fall back (gains hour)', () => {
    // Test date: November 3, 2024 2:00 AM EDT → 1:00 AM EST (fall back)
    // Verify "Today" doesn't bounce around
  });
  
  it('handles timezone changes for travelers', () => {
    // Simulate user traveling from EST to PST
    // Verify "Today" updates correctly based on new timezone
  });
});</code></pre>

          <h3>Smoke Tests</h3>
          <p>Add to smoke test checklist:</p>
          <p><strong>M. Timezone/DST Handling</strong>:</p>
          <ul>
            <li>[ ] <strong>Daily rollover</strong>: Verify "Today" chip updates at midnight in user's timezone (not UTC)</li>
            <li>[ ] <strong>Spring forward</strong>: Test DST spring forward boundary → Verify "Today" doesn't bounce around</li>
            <li>[ ] <strong>Fall back</strong>: Test DST fall back boundary → Verify "Today" doesn't bounce around</li>
            <li>[ ] <strong>Timezone change</strong>: Change system timezone → Verify "Today" updates correctly</li>
            <li>[ ] <strong>Traveler scenario</strong>: Simulate timezone change (EST → PST) → Verify goal calculations update correctly</li>
          </ul>

          <h3>Implementation Timeline</h3>
          <p>This should be implemented in <strong>Phase 5</strong> (Library Features & Goals UI) alongside goal calculation logic:</p>
          <ul>
            <li>Add timezone detection utility</li>
            <li>Update goal calculation hooks to use IANA timezone</li>
            <li>Add DST boundary tests</li>
            <li>Test with various timezones</li>
          </ul>
          <p><strong>LOE</strong>: 2-3 hours (includes timezone detection, DST boundary testing, and smoke tests)</p>
        </section>

        <section class="docs-section" id="rtl-mixed-script">
          <h2 id="rtl-mixed-script-heading">Right-to-Left (RTL) & Mixed-Script Paste (P2 Priority)</h2>
          
          <h3>Overview</h3>
          <p><strong>Why</strong>: Users may paste content with RTL scripts (Arabic, Hebrew) or mixed-script content. Caret movement, word counting, and paste stripping must behave correctly for RTL content.</p>
          <p><strong>What</strong>: Add one RTL snippet (Arabic/Hebrew) to the test corpus and assert caret movement, word counting, and paste stripping behave correctly. No architecture change—just tests.</p>

          <h3>Implementation Strategy</h3>
          
          <h4>1. Test Corpus Addition</h4>
          <p>Add RTL test snippet to small project (<code>test-small</code>):</p>
          <p><strong>RTL Test Snippet</strong>:</p>
          <ul>
            <li><strong>Title</strong>: "RTL Test Snippet"</li>
            <li><strong>Content</strong>: Mix of Arabic/Hebrew text with English</li>
            <li><strong>Purpose</strong>: Test caret movement, word counting, paste stripping</li>
          </ul>
          <p>Example content:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>This is English text. هذا نص عربي. This is more English. זה טקסט בעברית.</code></pre>

          <h4>2. Test Assertions</h4>
          <p><strong>Caret Movement</strong>:</p>
          <ul>
            <li>Verify caret moves correctly in RTL text (right-to-left direction)</li>
            <li>Verify caret moves correctly when switching between LTR and RTL text</li>
            <li>Verify selection works correctly in RTL text</li>
          </ul>
          <p><strong>Word Counting</strong>:</p>
          <ul>
            <li>Verify word count includes RTL words correctly</li>
            <li>Verify word boundaries are detected correctly in RTL text</li>
            <li>Verify mixed-script content (English + Arabic + Hebrew) counts words correctly</li>
          </ul>
          <p><strong>Paste Stripping</strong>:</p>
          <ul>
            <li>Verify rich text paste with RTL content is stripped to plain text</li>
            <li>Verify RTL formatting (bold, italic) is removed but text content is preserved</li>
            <li>Verify mixed-script paste (LTR + RTL) is handled correctly</li>
          </ul>

          <h3>Smoke Tests</h3>
          <p>Add to smoke test checklist:</p>
          <p><strong>N. RTL & Mixed-Script Handling</strong>:</p>
          <ul>
            <li>[ ] <strong>RTL caret movement</strong>: Type in Arabic/Hebrew snippet → Verify caret moves right-to-left correctly</li>
            <li>[ ] <strong>Mixed-script caret</strong>: Type in mixed English/Arabic/Hebrew snippet → Verify caret switches direction correctly</li>
            <li>[ ] <strong>RTL word counting</strong>: Verify word count includes RTL words correctly in test snippet</li>
            <li>[ ] <strong>RTL paste stripping</strong>: Paste rich text with RTL content → Verify formatting stripped, text preserved</li>
            <li>[ ] <strong>Mixed-script paste</strong>: Paste mixed LTR/RTL content → Verify handled correctly</li>
          </ul>

          <h3>Implementation Timeline</h3>
          <p>This should be implemented in <strong>Phase 4</strong> (Editor - Tri-Pane Shell & Plain Text Round-Trip) alongside round-trip testing:</p>
          <ul>
            <li>Add RTL test snippet to test corpus</li>
            <li>Add RTL assertions to smoke tests</li>
            <li>Test caret movement, word counting, paste stripping</li>
          </ul>
          <p><strong>LOE</strong>: 1-2 hours (includes adding RTL snippet to corpus and smoke test assertions)</p>
        </section>

        <section class="docs-section" id="memory-budget">
          <h2 id="memory-budget-heading">Memory Budget & Long Sessions (P2 Priority)</h2>
          
          <h3>Overview</h3>
          <p><strong>Why</strong>: All-day sessions on large projects can cause memory to balloon if cached snippet bodies are never evicted. We need a simple memory guard to cap cached snippet bodies.</p>
          <p><strong>What</strong>: Cap cached snippet bodies to N most-recent, evict the rest. This prevents memory bloat during long sessions.</p>
          <p><strong>Memory Budget Target & Eviction Rule</strong> (Documented for Ship Checklist):</p>
          <ul>
            <li><strong>Target</strong>: Cache limited to <strong>50 most-recent snippet bodies</strong> (configurable via <code>DEFAULT_MAX_CACHED_SNIPPETS = 50</code>)</li>
            <li><strong>Eviction Rule</strong>: <strong>LRU (Least Recently Used)</strong> - When cache exceeds 50 snippet bodies, evict the oldest (least recently used) snippet bodies until cache is at or below target</li>
            <li><strong>Active Snippet Protection</strong>: Active snippet is <strong>never evicted</strong>, even if cache is full (ensures active snippet always available for editing)</li>
            <li><strong>Enforcement</strong>: Cache size checked and eviction triggered when snippet content is loaded or cached</li>
          </ul>

          <h3>Implementation Strategy</h3>
          
          <h4>1. Memory Guard Configuration</h4>
          <p>Create memory budget configuration:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/config/memory.ts
const DEFAULT_MAX_CACHED_SNIPPETS = 50; // Keep 50 most-recent snippet bodies in memory

interface MemoryConfig {
  maxCachedSnippets: number; // Maximum number of snippet bodies to keep in memory
}

const STORAGE_KEY = 'yarny-memory-config';

export function getMemoryConfig(): MemoryConfig {
  try {
    const stored = localStorage.getItem(STORAGE_KEY);
    if (stored) {
      const parsed = JSON.parse(stored);
      return {
        maxCachedSnippets: parsed.maxCachedSnippets ?? DEFAULT_MAX_CACHED_SNIPPETS,
      };
    }
  } catch (err) {
    console.warn('Failed to load memory config from localStorage', err);
  }
  
  return {
    maxCachedSnippets: DEFAULT_MAX_CACHED_SNIPPETS,
  };
}</code></pre>

          <h4>2. LRU Eviction for Snippet Bodies</h4>
          <p>Implement LRU (Least Recently Used) eviction in React Query cache:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/lib/react-query.ts (update existing config)
import { QueryClient } from '@tanstack/react-query';
import { getMemoryConfig } from '../config/memory';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000,
      gcTime: 10 * 60 * 1000,
      // Memory guard: Evict oldest snippet bodies when cache exceeds limit
      gcTime: (query) => {
        const config = getMemoryConfig();
        // Count snippet body queries
        const snippetQueries = queryClient.getQueryCache().getAll().filter(
          (q) => q.queryKey[0] === 'drive' && q.queryKey[1] === 'file'
        );
        
        if (snippetQueries.length > config.maxCachedSnippets) {
          // Evict oldest (least recently used) queries
          const sorted = snippetQueries.sort((a, b) => 
            (a.state.dataUpdatedAt || 0) - (b.state.dataUpdatedAt || 0)
          );
          const toEvict = sorted.slice(0, snippetQueries.length - config.maxCachedSnippets);
          toEvict.forEach((q) => queryClient.removeQueries({ queryKey: q.queryKey }));
        }
        
        return 10 * 60 * 1000; // Default gcTime
      },
    },
  },
});</code></pre>

          <h4>3. Active Snippet Protection</h4>
          <p>Always keep active snippet in memory (never evict):</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// In eviction logic, exclude active snippet
const activeSnippetId = useStore.getState().project.activeSnippetId;
const toEvict = sorted
  .filter((q) => {
    // Don't evict active snippet
    const fileId = q.queryKey[2] as string;
    const snippet = Object.values(useStore.getState().snippets).find(
      (s) => s.driveFileId === fileId
    );
    return snippet?.id !== activeSnippetId;
  })
  .slice(0, snippetQueries.length - config.maxCachedSnippets);</code></pre>

          <h3>Smoke Tests</h3>
          <p>Add to smoke test checklist:</p>
          <p><strong>O. Memory Budget & Long Sessions</strong>:</p>
          <ul>
            <li>[ ] <strong>Memory guard</strong>: Open large project (test-large) → Make 100+ snippet switches → Verify memory doesn't balloon</li>
            <li>[ ] <strong>LRU eviction</strong>: Verify oldest snippet bodies are evicted when cache exceeds limit</li>
            <li>[ ] <strong>Active snippet protection</strong>: Verify active snippet is never evicted, even if cache is full</li>
            <li>[ ] <strong>Long session</strong>: Keep app open for 4+ hours, make many edits → Verify memory stays bounded</li>
          </ul>

          <h3>Implementation Timeline</h3>
          <p>This should be implemented in <strong>Phase 6</strong> (Lazy Loading & Exports) alongside lazy loading:</p>
          <ul>
            <li>Add memory budget configuration</li>
            <li>Implement LRU eviction for snippet bodies</li>
            <li>Protect active snippet from eviction</li>
            <li>Add smoke tests</li>
          </ul>
          <p><strong>LOE</strong>: 2-3 hours (includes memory guard implementation and smoke tests)</p>
        </section>

        <section class="docs-section" id="unload-safety">
          <h2 id="unload-safety-heading">Unload Safety (P2 Priority)</h2>
          
          <h3>Overview</h3>
          <p><strong>Why</strong>: With optimistic saves/mutations, we need a clear rule for window/tab close while <code>isSaving</code>. Users need predictable behavior when closing the app during saves.</p>
          <p><strong>What</strong>: Define the rule for window/tab close while <code>isSaving</code>: allow close after queueing to cache, or prompt. Tie to "Saved/Saving" indicator so it's predictable.</p>

          <h3>Implementation Strategy</h3>
          
          <h4>1. Unload Handler</h4>
          <p>Create unload safety handler:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/hooks/useUnloadSafety.ts
import { useEffect, useRef } from 'react';
import { useIsMutating } from '@tanstack/react-query';
import { useStore } from '../store/store';

export function useUnloadSafety() {
  const isMutating = useIsMutating() > 0;
  const savingState = useStore((state) => state.editing.savingState);
  const hasPendingMutations = useRef(false);
  
  useEffect(() => {
    hasPendingMutations.current = isMutating || savingState === 'saving';
  }, [isMutating, savingState]);
  
  useEffect(() => {
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      // If mutations are queued to cache, allow close (React Query will retry on next open)
      if (hasPendingMutations.current && savingState === 'queued') {
        // Queued saves are safe to close - they're in React Query's mutation queue
        return; // Allow close
      }
      
      // If actively saving, prompt user
      if (hasPendingMutations.current && savingState === 'saving') {
        e.preventDefault();
        e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
        return e.returnValue;
      }
    };
    
    window.addEventListener('beforeunload', handleBeforeUnload);
    return () => window.removeEventListener('beforeunload', handleBeforeUnload);
  }, [savingState]);
}</code></pre>

          <h4>2. Save Status Indicator Integration</h4>
          <p>Tie unload behavior to save status indicator:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/components/editor/SaveStatus.tsx
export function SaveStatus() {
  const { saveState, lastSavedAt } = useNetworkStatus();
  useUnloadSafety(); // Integrate unload safety
  
  // Save status indicator shows current state
  // Unload handler uses same state to determine behavior
  if (saveState === 'saving') {
    return &lt;div className="save-status saving"&gt;Saving... (don't close yet)&lt;/div&gt;;
  }
  
  if (saveState === 'queued') {
    return &lt;div className="save-status queued"&gt;Saved locally at {new Date(lastSavedAt).toLocaleTimeString()} (safe to close)&lt;/div&gt;;
  }
  
  // ... rest of component
}</code></pre>

          <h4>3. React Query Mutation Queue Persistence</h4>
          <p>Ensure React Query's mutation queue persists to cache:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/lib/react-query.ts
export const queryClient = new QueryClient({
  defaultOptions: {
    mutations: {
      // Persist mutation queue to localStorage for unload safety
      onMutate: async (variables) => {
        // Queue mutation to localStorage cache
        const queue = JSON.parse(localStorage.getItem('yarny-mutation-queue') || '[]');
        queue.push({
          type: 'write',
          variables,
          timestamp: Date.now(),
        });
        localStorage.setItem('yarny-mutation-queue', JSON.stringify(queue));
      },
      onSuccess: () => {
        // Remove from queue on success
        const queue = JSON.parse(localStorage.getItem('yarny-mutation-queue') || '[]');
        // Remove completed mutation
        // ...
      },
    },
  },
});</code></pre>

          <h3>Behavior Rules</h3>
          <ol>
            <li><strong>Queued saves (offline/cached)</strong>: Allow close without prompt - mutations are queued to cache and will retry on next open</li>
            <li><strong>Active saves (in-flight)</strong>: Prompt user before close - "You have unsaved changes. Are you sure you want to leave?"</li>
            <li><strong>Saved state</strong>: Allow close without prompt - all changes are saved</li>
          </ol>

          <h3>Smoke Tests</h3>
          <p>Add to smoke test checklist:</p>
          <p><strong>P. Unload Safety</strong>:</p>
          <ul>
            <li>[ ] <strong>Queued save close</strong>: Go offline → Make edits → Close tab → Verify no prompt, changes queued</li>
            <li>[ ] <strong>Active save close</strong>: Make edits → Close tab while saving → Verify prompt appears</li>
            <li>[ ] <strong>Saved state close</strong>: Make edits → Wait for save → Close tab → Verify no prompt</li>
            <li>[ ] <strong>Mutation queue persistence</strong>: Go offline → Make edits → Close tab → Reopen → Verify queued mutations retry</li>
          </ul>

          <h3>Implementation Timeline</h3>
          <p>This should be implemented in <strong>Phase 6</strong> (Lazy Loading & Exports) alongside auto-save functionality:</p>
          <ul>
            <li>Create <code>useUnloadSafety</code> hook</li>
            <li>Integrate with save status indicator</li>
            <li>Add mutation queue persistence</li>
            <li>Add smoke tests</li>
          </ul>
          <p><strong>LOE</strong>: 2-3 hours (includes unload handler, mutation queue persistence, and smoke tests)</p>
        </section>

        <section class="docs-section" id="observability-light">
          <h2 id="observability-light-heading">Observability Light (P2 Priority)</h2>
          
          <h3>Overview</h3>
          <p><strong>Why</strong>: During migration, we need visibility into migration risks (save latency, conflict hits, retry counts) to validate the performance budgets we've written down. A tiny, privacy-respecting heartbeat helps catch issues early.</p>
          <p><strong>What</strong>: Consider a tiny, privacy-respecting heartbeat for only migration risks (save latency, conflict hits, retry counts) behind a debug flag. It'll help validate the budgets you wrote down.</p>

          <h3>Implementation Strategy</h3>
          
          <h4>1. Debug Flag Configuration</h4>
          <p>Create debug flag for observability:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/config/debug.ts
const DEBUG_FLAG = 'yarny-debug-observability';

export function isObservabilityEnabled(): boolean {
  // Enable via localStorage: localStorage.setItem('yarny-debug-observability', 'true')
  return localStorage.getItem(DEBUG_FLAG) === 'true';
}</code></pre>

          <h4>2. Observability Metrics</h4>
          <p>Track only migration risks:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/utils/observability.ts
interface ObservabilityMetrics {
  saveLatency: number[]; // Array of save latencies (ms)
  conflictHits: number; // Count of conflict detections
  retryCounts: number[]; // Array of retry counts per request
  timestamp: number; // Last update timestamp
}

const METRICS_KEY = 'yarny-observability-metrics';
const MAX_METRICS = 100; // Keep last 100 data points

export function recordSaveLatency(latency: number): void {
  if (!isObservabilityEnabled()) return;
  
  const metrics = getMetrics();
  metrics.saveLatency.push(latency);
  if (metrics.saveLatency.length > MAX_METRICS) {
    metrics.saveLatency.shift(); // Remove oldest
  }
  metrics.timestamp = Date.now();
  localStorage.setItem(METRICS_KEY, JSON.stringify(metrics));
}

export function recordConflictHit(): void {
  if (!isObservabilityEnabled()) return;
  
  const metrics = getMetrics();
  metrics.conflictHits++;
  metrics.timestamp = Date.now();
  localStorage.setItem(METRICS_KEY, JSON.stringify(metrics));
}

export function recordRetryCount(retryCount: number): void {
  if (!isObservabilityEnabled()) return;
  
  const metrics = getMetrics();
  metrics.retryCounts.push(retryCount);
  if (metrics.retryCounts.length > MAX_METRICS) {
    metrics.retryCounts.shift(); // Remove oldest
  }
  metrics.timestamp = Date.now();
  localStorage.setItem(METRICS_KEY, JSON.stringify(metrics));
}

function getMetrics(): ObservabilityMetrics {
  try {
    const stored = localStorage.getItem(METRICS_KEY);
    if (stored) {
      return JSON.parse(stored);
    }
  } catch (err) {
    console.warn('Failed to load observability metrics', err);
  }
  
  return {
    saveLatency: [],
    conflictHits: 0,
    retryCounts: [],
    timestamp: Date.now(),
  };
}

export function getMetricsSummary(): {
  avgSaveLatency: number;
  maxSaveLatency: number;
  conflictHits: number;
  avgRetryCount: number;
} {
  const metrics = getMetrics();
  
  return {
    avgSaveLatency: metrics.saveLatency.length > 0
      ? metrics.saveLatency.reduce((a, b) => a + b, 0) / metrics.saveLatency.length
      : 0,
    maxSaveLatency: metrics.saveLatency.length > 0
      ? Math.max(...metrics.saveLatency)
      : 0,
    conflictHits: metrics.conflictHits,
    avgRetryCount: metrics.retryCounts.length > 0
      ? metrics.retryCounts.reduce((a, b) => a + b, 0) / metrics.retryCounts.length
      : 0,
  };
}</code></pre>

          <h4>3. Integration Points</h4>
          <p>Integrate observability into key operations:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// In save hook
const startTime = Date.now();
await writeMutation.mutateAsync(data);
const latency = Date.now() - startTime;
recordSaveLatency(latency);

// In conflict detection
if (conflict) {
  recordConflictHit();
}

// In React Query retry handler
recordRetryCount(failureCount);</code></pre>

          <h4>4. Debug View</h4>
          <p>Add debug view (only when flag enabled):</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/components/debug/ObservabilityPanel.tsx
export function ObservabilityPanel() {
  if (!isObservabilityEnabled()) return null;
  
  const summary = getMetricsSummary();
  
  return (
    &lt;div className="observability-panel"&gt;
      &lt;h3&gt;Migration Risk Metrics&lt;/h3&gt;
      &lt;div&gt;Avg Save Latency: {summary.avgSaveLatency.toFixed(0)}ms&lt;/div&gt;
      &lt;div&gt;Max Save Latency: {summary.maxSaveLatency}ms&lt;/div&gt;
      &lt;div&gt;Conflict Hits: {summary.conflictHits}&lt;/div&gt;
      &lt;div&gt;Avg Retry Count: {summary.avgRetryCount.toFixed(1)}&lt;/div&gt;
      &lt;button onClick={() => {
        localStorage.removeItem(METRICS_KEY);
        window.location.reload();
      }}&gt;Clear Metrics&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

          <h3>Privacy Considerations</h3>
          <ul>
            <li><strong>Local-only</strong>: All metrics stored in localStorage, never sent to server</li>
            <li><strong>Opt-in</strong>: Only enabled via debug flag (not enabled by default)</li>
            <li><strong>No PII</strong>: No user data, only performance metrics</li>
            <li><strong>Clearable</strong>: User can clear metrics at any time</li>
          </ul>

          <h3>Smoke Tests</h3>
          <p>Add to smoke test checklist:</p>
          <p><strong>Q. Observability</strong>:</p>
          <ul>
            <li>[ ] <strong>Debug flag</strong>: Enable observability flag → Make edits → Verify metrics recorded</li>
            <li>[ ] <strong>Save latency</strong>: Verify save latency metrics are recorded correctly</li>
            <li>[ ] <strong>Conflict hits</strong>: Trigger conflict → Verify conflict hit recorded</li>
            <li>[ ] <strong>Retry counts</strong>: Trigger retry → Verify retry count recorded</li>
            <li>[ ] <strong>Metrics summary</strong>: Verify metrics summary displays correctly</li>
            <li>[ ] <strong>Privacy</strong>: Verify metrics never sent to server, only stored locally</li>
          </ul>

          <h3>Implementation Timeline</h3>
          <p>This should be implemented in <strong>Phase 7</strong> (Accessibility, Performance & Polish) alongside performance testing:</p>
          <ul>
            <li>Create observability utilities</li>
            <li>Integrate into save, conflict, retry operations</li>
            <li>Add debug panel (optional)</li>
            <li>Add smoke tests</li>
          </ul>
          <p><strong>LOE</strong>: 2-3 hours (includes observability utilities, integration, and smoke tests)</p>
        </section>

        <section class="docs-section" id="editor-truth">
          <h2 id="editor-truth-heading">Editor Truth and Google Docs Round-Tripping (P1 Priority)</h2>
          
          <h3>Overview</h3>
          <p><strong>Why</strong>: TipTap is a great editor, but Google Docs is the storage of record. The Google Docs API doesn't speak arbitrary HTML; even if you keep content plain-text, small mismatches can creep in during round-tripping between the editor and Google Docs.</p>
          <p><strong>What</strong>: For v1 React migration, constrain TipTap formatting to Yarny's minimalist model (plain paragraphs, soft line-breaks) and establish clear rules for editor authority and reconciliation.</p>

          <h3>Design Decisions</h3>
          
          <h4>1. Format Constraint: Plain Text Only</h4>
          <p><strong>Decision</strong>: TipTap will be configured to support <strong>only plain text</strong> - no rich formatting (bold, italic, colors, etc.).</p>
          <p><strong>Why</strong>:</p>
          <ul>
            <li>Google Docs API doesn't handle arbitrary HTML well</li>
            <li>Current Yarny model is minimalist (plain text with line breaks)</li>
            <li>Reduces round-tripping issues and format mismatches</li>
            <li>Simpler implementation for v1</li>
          </ul>
          <p><strong>Implementation</strong>:</p>
          <ul>
            <li>Use TipTap's <code>Document</code> extension (required)</li>
            <li>Use <code>Paragraph</code> extension for paragraph breaks (<code>\n\n</code>)</li>
            <li>Use <code>HardBreak</code> extension for soft line breaks (<code>\n</code>)</li>
            <li><strong>Disable</strong> all formatting extensions (Bold, Italic, Heading, etc.)</li>
            <li>Configure TipTap to extract plain text that matches Google Docs API output</li>
          </ul>

          <h4>2. Editor as Truth While Open</h4>
          <p><strong>Decision</strong>: While Yarny is open and a snippet is being edited, <strong>the editor is authoritative</strong>. Changes made in Google Docs while Yarny is open are ignored until the user switches snippets or closes Yarny.</p>
          <p><strong>Why</strong>:</p>
          <ul>
            <li>Prevents conflicts while actively editing</li>
            <li>Better UX - user's current edits take precedence</li>
            <li>Matches current behavior (editor content is saved to Drive, overwriting Drive version)</li>
          </ul>

          <h4>3. Reconciliation on Window Focus</h4>
          <p><strong>Decision</strong>: When the window regains focus, check if any open snippets were modified externally in Google Docs. If so, reconcile the changes.</p>
          <p><strong>Why</strong>:</p>
          <ul>
            <li>User might have edited in Google Docs in another tab/window</li>
            <li>Need to detect and handle external changes</li>
            <li>Better than only checking on snippet switch (catches changes sooner)</li>
          </ul>

          <h4>4. Conflict Detection</h4>
          <p><strong>Decision</strong>: Set up conflict detection infrastructure early (Phase 1), implement hooks and UI in Phase 5 (not later).</p>
          <p><strong>Why</strong>:</p>
          <ul>
            <li>Conflict detection infrastructure (text extraction utilities) is foundational</li>
            <li>Need to test round-tripping early (Phase 4)</li>
            <li><strong>Conflict resolution modal must be in Phase 5</strong> to catch Editor/Docs mismatch issues early before they compound</li>
            <li>Testing cross-edits (opening Doc in Google Docs while Yarny is idle) requires conflict modal to be functional</li>
          </ul>
          
          <p><strong>Implementation</strong>:</p>
          <ul>
            <li>Phase 1: Create text extraction utilities matching Google Docs format</li>
            <li>Phase 4: Test round-tripping with TipTap editor</li>
            <li><strong>Phase 5</strong>: Implement conflict detection hooks and conflict resolution UI (moved from Phase 6)</li>
            <li>Use React Query to check file metadata</li>
            <li>Compare timestamps and content</li>
            <li>Show conflict resolution modal (reuse existing UI patterns)</li>
            <li>Test cross-edits: Open Doc in Google Docs while Yarny is idle, make edits, return to Yarny and verify conflict detection</li>
          </ul>

          <h3>Round-Tripping Flow</h3>
          <ol>
            <li><strong>Load from Drive</strong>: Google Docs content → Plain text → TipTap editor</li>
            <li><strong>Edit in TipTap</strong>: User edits → TipTap onChange → Plain text → State update</li>
            <li><strong>Save to Drive</strong>: Plain text → Google Docs API → Google Docs updated</li>
            <li><strong>Reconciliation</strong>: On focus/switch, check if Drive changed → Compare plain text → Resolve if different</li>
          </ol>

          <h3>Implementation Timeline</h3>
          <p>This spans multiple phases:</p>
          <ul>
            <li><strong>Phase 1</strong>: Set up TipTap with plain text configuration, create text extraction utilities with newline normalization</li>
            <li><strong>Phase 2</strong>: Implement reconciliation on window focus, add cross-tab coordination hook</li>
            <li><strong>Phase 4</strong>: Integrate TipTap editor with IME composition handling, round-trip testing with format normalization tests</li>
            <li><strong>Phase 5</strong>: Create conflict detection hooks, conflict resolution UI and modal (moved from Phase 6 to catch Editor/Docs mismatch issues early)</li>
            <li><strong>Phase 5</strong>: Test cross-edits (open Doc in Google Docs while Yarny is idle, make edits, return to Yarny)</li>
            <li><strong>Phase 5</strong>: Test cross-tab conflicts (two Yarny tabs editing same snippet)</li>
            <li><strong>Phase 4/5</strong>: Add CJK and emoji test snippets to test corpus</li>
          </ul>
          <p><strong>LOE:</strong> 12-18 hours (includes TipTap configuration with IME handling, conflict detection, reconciliation, cross-tab coordination, format normalization, and comprehensive testing)</p>

          <h3>Dependencies</h3>
          <p>Already included in recommended stack:</p>
          <ul>
            <li><code>@tiptap/react</code> - Editor framework</li>
            <li>Individual TipTap extensions (Document, Paragraph, Text, HardBreak, History) - configured separately</li>
          </ul>
          <p><strong>Note</strong>: Individual extensions are used instead of starter-kit to maintain strict plain text configuration and exclude all formatting capabilities.</p>
        </section>

        <section class="docs-section" id="migration-phases">
          <h2 id="migration-phases-heading">Migration Phases</h2>
          
          <h3>Phase 1: Setup & Infrastructure (Week 1)</h3>
          <ul>
            <li>Set up React + TypeScript + Vite build system</li>
            <li>Configure TypeScript (tsconfig.json)</li>
            <li>Set up type definitions for all libraries</li>
            <li>Set up Netlify build configuration</li>
            <li>Install and configure all libraries</li>
            <li><strong>Set up TanStack Query (React Query) with QueryClient and QueryClientProvider</strong></li>
            <li><strong>Create React Query hooks for ALL Drive I/O operations (<code>src/hooks/useDriveQueries.ts</code>)</strong></li>
            <li><strong>Configure TipTap for plain text only (no rich formatting)</strong></li>
            <li><strong>Create text extraction utilities matching Google Docs format</strong></li>
            <li>Create base component structure with TypeScript</li>
            <li><strong>Set up normalized state management (Zustand) with TypeScript types</strong></li>
            <li><strong>Create normalized state structure in <code>src/store/types.ts</code> (all entities keyed by id)</strong></li>
            <li><strong>Create selectors in <code>src/store/selectors.ts</code> to derive views (e.g., left-rail lists)</strong></li>
            <li><strong>Set up MUI theme customization (<code>src/theme/theme.ts</code>) with brand color mappings</strong></li>
            <li><strong>Customize MUI component defaults to match existing design</strong></li>
            <li><strong>Set up ThemeProvider in app root</strong></li>
            <li><strong>Create test corpus folder structure (<code>Yarny Test Corpus</code> in Drive)</strong></li>
            <li><strong>Populate small project with sample data</strong></li>
            <li><strong>Document smoke test checklist</strong></li>
          </ul>
          <p><strong>LOE:</strong> 30-42 hours (includes TypeScript setup, type definitions, React Query setup, TipTap plain text configuration, state normalization, MUI theming, and test corpus setup)</p>
          <p><strong>Phase 1 Risk Checkpoint</strong>: Re-rate risks for Editor/Docs round-trip, Drive quotas, performance at large scale. Verify React Query and Zod are fully implemented per definition of done.</p>

          <h3>Phase 2: Authentication, Router & API Contract (Week 1-2)</h3>
          <ul>
            <li>Configure React Router with TypeScript</li>
            <li>Set up routing structure with loaders</li>
            <li><strong>Implement route loaders that prefetch Drive API data using React Query</strong>
              <ul>
                <li>Stories route loader: prefetch Yarny Stories folder and stories list</li>
                <li>Editor route loader: prefetch Yarny Stories folder and project.json</li>
                <li>Add route-level loading states and error boundaries</li>
              </ul>
            </li>
            <li><strong>Create API contract module (<code>src/api/contract.ts</code>) with Zod schemas</strong></li>
            <li><strong>Create typed API client (<code>src/api/client.ts</code>)</strong></li>
            <li><strong>Convert Netlify Functions to TypeScript</strong>:
              <ul>
                <li>Set up TypeScript configuration for Netlify Functions</li>
                <li>Create shared types module (<code>netlify/functions/types.ts</code>)</li>
                <li>Convert authentication functions to TypeScript (<code>auth/*.ts</code>, <code>verify-google.ts</code>, <code>logout.ts</code>)</li>
                <li>Convert Drive functions to TypeScript (<code>drive-*.ts</code>, <code>drive-client.ts</code>)</li>
                <li>Convert utility functions to TypeScript (<code>config.ts</code>, <code>uptime-status.ts</code>)</li>
                <li>Add type annotations to all function handlers</li>
                <li>Update function exports to use TypeScript types</li>
                <li>Test all functions with TypeScript compilation</li>
              </ul>
            </li>
            <li>Convert login page to React</li>
            <li>Integrate Google Sign-In SDK</li>
            <li>Create Auth context/provider</li>
            <li>Handle auth state and redirects</li>
            <li><strong>Implement reconciliation on window focus (<code>src/hooks/useWindowFocusReconciliation.ts</code>)</strong></li>
            <li>Test authentication flow</li>
          </ul>
          <p><strong>LOE:</strong> 20-28 hours (includes router setup, API contract formalization, Netlify Functions TypeScript conversion, and reconciliation hook implementation)</p>
          <p><strong>Phase 2 Risk Checkpoint</strong>: Re-rate risks for Editor/Docs round-trip, Drive quotas, performance at large scale. Verify API contract formalization is complete.</p>

          <h3>Phase 3: Stories Page with Virtualization Stub (Week 2)</h3>
          <ul>
            <li>Convert stories list to React components</li>
            <li>Implement search/filtering</li>
            <li>Add modals (new story, delete confirmation)</li>
            <li>Integrate with Drive API hooks</li>
            <li><strong>Stub virtualized list capability (set up <code>@tanstack/react-virtual</code> infrastructure, even if not used yet)</strong></li>
            <li>Test story management</li>
          </ul>
          <p><strong>LOE:</strong> 10-14 hours (includes virtualization infrastructure setup)</p>
          <p><strong>Phase 3 Risk Checkpoint</strong>: Re-rate risks for Editor/Docs round-trip, Drive quotas, performance at large scale.</p>

          <h3>Phase 4: Editor - Tri-Pane Shell & Plain Text Round-Trip (Week 2-3)</h3>
          <ul>
            <li>Set up three-column layout (Story/Editor/Notes)</li>
            <li>Convert story list sidebar</li>
            <li>Convert notes sidebar with tabs</li>
            <li><strong>Implement footer word/character counts first</strong></li>
            <li><strong>Implement save status display</strong></li>
            <li><strong>Set up TipTap editor with plain text configuration and IME composition handling</strong></li>
            <li><strong>Integrate TipTap with conflict detection</strong></li>
            <li><strong>Implement editor as truth (authoritative while open)</strong></li>
            <li>Basic editor functionality</li>
            <li><strong>Test round-tripping with Google Docs</strong></li>
            <li><strong>Run smoke tests on small project (test-small) after TipTap integration</strong></li>
            <li><strong>Validate round-tripping with small project</strong></li>
            <li><strong>Populate medium project (test-medium)</strong></li>
            <li><strong>Classic UX anchors visual parity check</strong>: Perform pixel-diff or side-by-side visual comparison for goal meter, "Today" chip, and footer counts before closing phase</li>
          </ul>
          <p><strong>LOE:</strong> 24-33 hours (includes TipTap integration, conflict detection integration, round-trip testing, smoke test execution, and footer/save status implementation)</p>
          <p><strong>Phase 4 Risk Checkpoint</strong>: Re-rate risks for Editor/Docs round-trip, Drive quotas, performance at large scale. Verify classic UX anchors pass visual parity check (pixel-diff or side-by-side comparison).</p>

          <h3>Phase 5: Library Features & Goals UI (Week 3-4)</h3>
          <ul>
            <li>Implement drag & drop with @dnd-kit</li>
            <li>Color picker integration</li>
            <li>Context menus</li>
            <li>All modals (story info, rename, delete, etc.) using Material UI Dialog</li>
            <li>Tabs implementation using Material UI Tabs</li>
            <li><strong>Implement Goals UI: Goal Meter (left-rail) and Goal Panel modal at parity with alpha plan</strong></li>
            <li><strong>Implement "Today • N" chip with progress bar</strong></li>
            <li>Word count updates</li>
            <li><strong>Create conflict detection hooks (<code>src/hooks/useConflictDetection.ts</code>)</strong></li>
            <li><strong>Conflict resolution UI and modal (moved from Phase 6 to catch Editor/Docs mismatch issues early)</strong></li>
            <li><strong>Test cross-edits: Open Doc in Google Docs while Yarny is idle, make edits, return to Yarny and verify conflict detection works</strong></li>
            <li><strong>Test cross-tab conflicts (two Yarny tabs editing same snippet)</strong></li>
          </ul>
          <p><strong>LOE:</strong> 25-35 hours (includes Goals UI implementation with chip and panel, plus conflict resolution modal)</p>
          <p><strong>Phase 5 Risk Checkpoint</strong>: Re-rate risks for Editor/Docs round-trip, Drive quotas, performance at large scale. Verify conflict resolution modal is functional and cross-edit testing passes.</p>

          <h3>Phase 6: Lazy Loading & Exports (Week 4)</h3>
          <ul>
            <li>Lazy loading logic using React Query prefetching and <code>useQueries</code></li>
            <li>Auto-save functionality using React Query mutations</li>
            <li>Export functionality</li>
            <li><strong>Run full smoke test suite on small and medium projects</strong></li>
            <li><strong>Validate all operations work correctly (including conflict resolution from Phase 5)</strong></li>
            <li><strong>Populate large project (test-large)</strong></li>
          </ul>
          <p><strong>LOE:</strong> 12-17 hours (Note: Conflict resolution moved to Phase 5; lazy loading is simplified with React Query's built-in prefetching; includes smoke test execution)</p>
          <p><strong>Phase 6 Risk Checkpoint</strong>: Re-rate risks for Editor/Docs round-trip, Drive quotas, performance at large scale. Verify export chunking works correctly for large chapters.</p>

          <h3>Phase 7: Accessibility, Performance & Polish (Week 4-5)</h3>
          <ul>
            <li>Accessibility audit and fixes</li>
            <li>Cross-browser testing</li>
            <li><strong>Run full smoke test suite on all three project sizes (test-small, test-medium, test-large)</strong></li>
            <li><strong>Performance testing with large project (test-large)</strong></li>
            <li>Performance optimization (virtualization activation if needed, memoization review)</li>
            <li><strong>Regression testing before production deployment</strong></li>
            <li>Bug fixes</li>
            <li>Mobile responsiveness check</li>
            <li>Documentation updates</li>
          </ul>
          <p><strong>LOE:</strong> 19-31 hours (includes smoke test execution on all test corpus projects, accessibility pass, and performance touches)</p>
          <p><strong>Phase 7 Risk Checkpoint</strong>: Final risk assessment before production deployment. Re-rate all risks and verify mitigation strategies are effective.</p>

          <h3 id="phase-8">Phase 8: Test Automation (Week 5-6)</h3>
          <p><strong>Goal</strong>: Automate as many tests from the testing workbook as possible to reduce manual testing burden and enable continuous regression testing.</p>
          <p><strong>Strategy</strong>: Use Playwright for end-to-end testing with mocked Google Drive API, plus React Testing Library for component-level tests. Focus on automating functional tests that don't require subjective human judgment.</p>

          <h4>Test Categorization</h4>
          <p>Based on analysis of the testing workbook, tests fall into three categories:</p>
          <ol>
            <li><strong>Fully Automatable (60-70% of tests)</strong>:
              <ul>
                <li>API contract validation (can use Zod schemas)</li>
                <li>State management operations (CRUD operations)</li>
                <li>Data persistence and round-trips</li>
                <li>Word count calculations</li>
                <li>Goal calculations (elastic/strict modes)</li>
                <li>Search functionality</li>
                <li>Export operations (verify file creation, content structure)</li>
                <li>Conflict detection logic</li>
                <li>Format normalization (line endings, NBSPs)</li>
                <li>Session persistence</li>
                <li>Error handling and edge cases</li>
                <li>Performance metrics (time to first edit, time to switch snippet)</li>
              </ul>
            </li>
            <li><strong>Partially Automatable (20-25% of tests)</strong>:
              <ul>
                <li>UI rendering and layout (can automate visual regression with pixel-diff)</li>
                <li>Modal open/close behavior</li>
                <li>Drag & drop operations</li>
                <li>Keyboard navigation</li>
                <li>Focus management</li>
                <li>Loading states</li>
                <li>Error message display</li>
              </ul>
            </li>
            <li><strong>Requires Human Testing (10-15% of tests)</strong>:
              <ul>
                <li>Subjective UX evaluation ("looks and behaves identically to original")</li>
                <li>Visual design parity (colors, spacing, typography - though pixel-diff can help)</li>
                <li>Accessibility with screen readers (requires human verification)</li>
                <li>Mobile device warning (requires actual device or emulator)</li>
                <li>Cross-browser visual consistency</li>
                <li>IME composition (Japanese/Chinese/Korean) - can be partially automated but needs human verification</li>
              </ul>
            </li>
          </ol>

          <h4>Implementation Plan</h4>
          <p><strong>A. Set Up Testing Infrastructure</strong>:</p>
          <ul>
            <li>Install Playwright (<code>@playwright/test</code>)</li>
            <li>Install React Testing Library (<code>@testing-library/react</code>, <code>@testing-library/jest-dom</code>)</li>
            <li>Install Vitest for unit tests (<code>vitest</code>)</li>
            <li>Set up test configuration files</li>
            <li>Create test utilities and helpers</li>
            <li>Set up mock Google Drive API server (using MSW - Mock Service Worker)</li>
            <li>Create test data fixtures matching test corpus structure</li>
          </ul>

          <p><strong>B. Component-Level Tests (React Testing Library)</strong>:</p>
          <ul>
            <li>Test all modal components (open, close, form submission)</li>
            <li>Test context menus (open, select options)</li>
            <li>Test color picker (select colors, verify state)</li>
            <li>Test goal meter calculations (elastic/strict modes)</li>
            <li>Test word count calculations</li>
            <li>Test search functionality (filtering, highlighting)</li>
            <li>Test drag & drop operations (using <code>@testing-library/user-event</code>)</li>
            <li>Test keyboard shortcuts</li>
            <li>Test form validations</li>
          </ul>

          <p><strong>C. Integration Tests (React Testing Library + MSW)</strong>:</p>
          <ul>
            <li>Test API contract validation (Zod schemas)</li>
            <li>Test state management operations (create, read, update, delete stories/chapters/snippets/notes)</li>
            <li>Test Google Drive sync (mocked API calls)</li>
            <li>Test conflict detection logic</li>
            <li>Test format normalization</li>
            <li>Test session persistence (localStorage/cookies)</li>
            <li>Test error handling (network errors, API errors, rate limiting)</li>
          </ul>

          <p><strong>D. End-to-End Tests (Playwright)</strong>:</p>
          <ul>
            <li>Test authentication flow (mocked Google Sign-In)</li>
            <li>Test story management (create, edit, delete, refresh)</li>
            <li>Test editor operations (open snippet, edit, save, auto-save)</li>
            <li>Test chapter/snippet management (create, rename, delete, reorder)</li>
            <li>Test color coding (assign colors to chapters/snippets)</li>
            <li>Test search (chapters, snippets, content)</li>
            <li>Test goals (set goal, verify calculations, elastic/strict modes)</li>
            <li>Test notes (People/Places/Things CRUD operations)</li>
            <li>Test export operations (verify file creation, content structure)</li>
            <li>Test conflict resolution (simulate external edits, verify conflict modal)</li>
            <li>Test round-tripping (edit in Yarny → verify in Drive → edit in Drive → verify in Yarny)</li>
            <li>Test performance budgets (time to first edit ≤300ms hot path, ≤1.5s cold path)</li>
            <li>Test visibility-based request gating (hidden tabs don't make requests)</li>
            <li>Test rate limiting handling (simulate 429 errors, verify exponential backoff)</li>
          </ul>

          <p><strong>E. Visual Regression Tests (Playwright + Pixel-Diff)</strong>:</p>
          <ul>
            <li>Set up visual regression testing with <code>@playwright/test</code> screenshot comparison</li>
            <li>Test classic UX anchors (goal meter, "Today • N" chip, footer counts) - compare against reference screenshots</li>
            <li>Test modal layouts</li>
            <li>Test responsive layouts</li>
            <li>Test color coding display</li>
            <li>Test loading states</li>
            <li>Test error states</li>
          </ul>

          <p><strong>F. Performance Tests (Playwright)</strong>:</p>
          <ul>
            <li>Test time to first edit (hot path: ≤300ms, cold path: ≤1.5s)</li>
            <li>Test time to switch snippet (hot path: ≤300ms, cold path: ≤1.5s)</li>
            <li>Test large story performance (25+ chapters, 200+ snippets)</li>
            <li>Test lazy loading behavior</li>
            <li>Test virtualization thresholds (verify virtualization activates at configured thresholds)</li>
          </ul>

          <p><strong>G. Test Data Management</strong>:</p>
          <ul>
            <li>Create test corpus fixtures (small, medium, large projects)</li>
            <li>Create test data generators for edge cases</li>
            <li>Set up test data reset utilities</li>
            <li>Document test data structure</li>
          </ul>

          <p><strong>H. CI/CD Integration</strong>:</p>
          <ul>
            <li>Set up GitHub Actions workflow for test execution</li>
            <li>Configure test execution on PR and main branch</li>
            <li>Set up test result reporting</li>
            <li>Configure visual regression test failure notifications</li>
          </ul>

          <h4>Test Coverage Goals</h4>
          <ul>
            <li><strong>Component Tests</strong>: 80%+ coverage of UI components</li>
            <li><strong>Integration Tests</strong>: 90%+ coverage of business logic (hooks, utilities, state management)</li>
            <li><strong>E2E Tests</strong>: 70%+ coverage of user workflows (automated tests from workbook)</li>
            <li><strong>Visual Regression</strong>: 100% coverage of classic UX anchors and critical UI elements</li>
          </ul>

          <h4>Mock Strategy</h4>
          <p><strong>Google Drive API Mocking</strong>:</p>
          <ul>
            <li>Use MSW (Mock Service Worker) to intercept Drive API calls</li>
            <li>Create mock handlers for all Drive operations (list, read, write, delete, rename, create folder, check comments)</li>
            <li>Support test scenarios: success, errors, rate limiting, conflicts</li>
            <li>Enable test data manipulation without real Drive API calls</li>
          </ul>

          <p><strong>Google Sign-In Mocking</strong>:</p>
          <ul>
            <li>Mock Google Identity Services (GSI) authentication flow</li>
            <li>Simulate successful sign-in, token refresh, sign-out</li>
            <li>Support test scenarios: valid tokens, expired tokens, invalid tokens</li>
          </ul>

          <h4>Test Execution Strategy</h4>
          <p><strong>Local Development</strong>:</p>
          <ul>
            <li>Run component and integration tests during development (<code>npm run test:watch</code>)</li>
            <li>Run E2E tests before committing (<code>npm run test:e2e</code>)</li>
            <li>Run visual regression tests before release (<code>npm run test:visual</code>)</li>
          </ul>

          <p><strong>CI/CD Pipeline</strong>:</p>
          <ul>
            <li>Run all tests on PR creation/update</li>
            <li>Run full test suite on merge to main</li>
            <li>Block PR merge if tests fail</li>
            <li>Generate test coverage reports</li>
          </ul>

          <p><strong>Pre-Release</strong>:</p>
          <ul>
            <li>Run full test suite (component + integration + E2E + visual)</li>
            <li>Run performance tests</li>
            <li>Compare against baseline metrics</li>
            <li>Generate test report</li>
          </ul>

          <h4>Manual Testing Remaining</h4>
          <p>After automation, manual testing focuses on:</p>
          <ul>
            <li><strong>Subjective UX evaluation</strong>: Does it "feel" like the original app?</li>
            <li><strong>Visual design parity</strong>: Side-by-side comparison with original app</li>
            <li><strong>Accessibility</strong>: Screen reader testing, keyboard-only navigation</li>
            <li><strong>Cross-browser</strong>: Visual consistency across Chrome, Firefox, Safari, Edge</li>
            <li><strong>IME composition</strong>: Japanese/Chinese/Korean input (can be partially automated but needs human verification)</li>
            <li><strong>Mobile device warning</strong>: Actual device testing</li>
            <li><strong>Edge cases</strong>: Unusual user behaviors, error recovery</li>
          </ul>

          <h4>Benefits</h4>
          <ol>
            <li><strong>Faster Feedback</strong>: Automated tests run in minutes vs. hours of manual testing</li>
            <li><strong>Regression Prevention</strong>: Catch bugs before they reach production</li>
            <li><strong>Confidence in Refactoring</strong>: Automated tests enable safe code changes</li>
            <li><strong>Documentation</strong>: Tests serve as living documentation of expected behavior</li>
            <li><strong>Continuous Testing</strong>: Tests run on every PR and deployment</li>
            <li><strong>Reduced Manual Burden</strong>: 60-70% of tests automated, freeing human testers for subjective evaluation</li>
          </ol>

          <h4>LOE Breakdown</h4>
          <ul>
            <li><strong>Infrastructure Setup</strong>: 8-12 hours (Playwright, React Testing Library, MSW, test configuration)</li>
            <li><strong>Component Tests</strong>: 12-18 hours (modal, context menu, color picker, goal meter, word count, search, drag & drop)</li>
            <li><strong>Integration Tests</strong>: 10-15 hours (API contract, state management, Drive sync, conflict detection, format normalization)</li>
            <li><strong>E2E Tests</strong>: 20-30 hours (authentication, story management, editor, chapters/snippets, goals, notes, export, conflict resolution, round-tripping, performance)</li>
            <li><strong>Visual Regression Tests</strong>: 6-10 hours (classic UX anchors, modals, responsive layouts, loading/error states)</li>
            <li><strong>Test Data Management</strong>: 4-6 hours (fixtures, generators, reset utilities)</li>
            <li><strong>CI/CD Integration</strong>: 4-6 hours (GitHub Actions, reporting, notifications)</li>
          </ul>

          <p><strong>Total LOE</strong>: 64-97 hours (8-12 days)</p>

          <h4>Timeline</h4>
          <ul>
            <li><strong>Week 5</strong>: Infrastructure setup, component tests, integration tests</li>
            <li><strong>Week 6</strong>: E2E tests, visual regression tests, CI/CD integration, documentation</li>
          </ul>

          <h4>Success Criteria</h4>
          <ul>
            <li>60%+ of testing workbook tests are automated</li>
            <li>All critical user workflows have E2E test coverage</li>
            <li>All classic UX anchors have visual regression tests</li>
            <li>Performance budgets are validated automatically</li>
            <li>Tests run in CI/CD pipeline on every PR</li>
            <li>Test coverage reports are generated and tracked</li>
            <li>Manual testing checklist is updated to reflect automated tests</li>
          </ul>

          <p><strong>Phase 8 Risk Checkpoint</strong>: Verify test automation coverage meets goals, CI/CD integration works correctly, and manual testing burden is reduced.</p>
        </section>

        <section class="docs-section" id="risk-factors">
          <h2 id="risk-factors-heading">Risk Factors</h2>
          
          <h3>Risk Register Cadence</h3>
          <p><strong>Process</strong>: At the end of each migration phase, conduct a risk checkpoint to re-rate the following critical risks:</p>
          <ol>
            <li><strong>Editor/Docs Mismatch & Round-Tripping</strong> - Verify round-trip testing passes, conflict detection works, format normalization is correct</li>
            <li><strong>Drive Quotas</strong> - Verify visibility-based gating prevents request storms, rate limit handling works correctly</li>
            <li><strong>Performance at Large Scale</strong> - Verify performance with large projects (test-large), virtualization thresholds are appropriate, memoization is effective</li>
          </ol>
          <p><strong>Checkpoint Activities</strong>:</p>
          <ul>
            <li>Review risk mitigation strategies implemented in the phase</li>
            <li>Test critical paths with test corpus (small, medium, large projects)</li>
            <li>Re-rate risk level (High/Medium/Low) based on current status</li>
            <li>Update mitigation strategies if needed</li>
            <li>Document any new risks discovered</li>
            <li>Verify definition of done criteria are met</li>
          </ul>
          <p><strong>Checkpoint Schedule</strong>:</p>
          <ul>
            <li><strong>Phase 1</strong>: Verify React Query and Zod are fully implemented (definition of done)</li>
            <li><strong>Phase 2</strong>: Verify API contract formalization is complete</li>
            <li><strong>Phase 3</strong>: Baseline risk assessment before editor work begins</li>
            <li><strong>Phase 4</strong>: Critical checkpoint - verify classic UX anchors pass visual parity check (pixel-diff or side-by-side comparison)</li>
            <li><strong>Phase 5</strong>: Verify conflict resolution modal is functional and cross-edit testing passes</li>
            <li><strong>Phase 6</strong>: Verify export chunking works correctly for large chapters</li>
            <li><strong>Phase 7</strong>: Final risk assessment before production deployment</li>
            <li><strong>Phase 8</strong>: Verify test automation coverage meets goals, CI/CD integration works correctly, and manual testing burden is reduced</li>
          </ul>
          
          <hr style="margin: var(--space-xl) 0; border: none; border-top: 1px solid rgba(255, 255, 255, 0.1);">
          
          <h3>High Risk</h3>
          <ul>
            <li><strong>Editor/Docs Mismatch & Round-Tripping</strong>
              <ul>
                <li><strong>Risk</strong>: Plain text editor integration and Google Docs round-tripping may have edge cases, format mismatches, or conflicts</li>
                <li><strong>Mitigation Strategies</strong>:
                  <ul>
                    <li><strong>Lock down formatting scope for v1</strong>: TipTap configured for plain text only (no rich formatting) - Document, Paragraph, Text, HardBreak, History extensions only</li>
                    <li><strong>Test cross-edits early</strong>: Test by opening a Doc in Google Docs while Yarny is idle, making edits, then returning to Yarny to verify conflict detection works correctly</li>
                    <li><strong>Conflict modal in Phase 5</strong>: Ensure conflict resolution modal is implemented in Phase 5 (not later) to catch issues early</li>
                    <li><strong>Round-trip testing</strong>: Test editing in Yarny → saving → editing in Google Docs → switching snippets in Yarny → verify no format loss</li>
                    <li><strong>Google Docs newline semantics</strong>: Google Docs API normalizes carriage returns (<code>\r\n</code> → <code>\n</code>) and may collapse trailing spaces. Test with mixed <code>\n</code>/<code>\r\n</code>, non-breaking spaces (NBSPs), and trailing spaces. Normalize text extraction to match Docs' behavior.</li>
                    <li><strong>IME composition handling</strong>: Japanese/Chinese/Korean IME composition fires change events differently. Respect <code>compositionstart</code>/<code>compositionend</code> events to prevent premature word count updates and save debouncing during composition.</li>
                  </ul>
                </li>
                <li><strong>Contingency</strong>: Allow extra 5-10 hours for editor edge cases, round-trip testing, and conflict resolution refinement</li>
              </ul>
            </li>
            <li><strong>State Churn Causing Re-renders</strong>
              <ul>
                <li><strong>Risk</strong>: React re-renders may be slower than vanilla JS, especially with frequent state updates during typing</li>
                <li><strong>Mitigation Strategies</strong>:
                  <ul>
                    <li><strong>Normalized store + memoized selectors</strong>: All entities keyed by id in Zustand store; use memoized selectors to derive views (prevents unnecessary re-renders when unrelated entities change)</li>
                    <li><strong>Treat editor viewport as "pure" component</strong>: Editor component should only subscribe to the active snippet's slice of state, not the entire state tree</li>
                    <li><strong>Memoize list rows</strong>: Use <code>React.memo</code> for expensive list components (GroupRow, SnippetRow) with custom comparison functions</li>
                    <li><strong>Memoize callbacks</strong>: Use <code>useCallback</code> for event handlers passed to child components to prevent re-render cascades</li>
                  </ul>
                </li>
                <li><strong>Contingency</strong>: Profile with React DevTools, add additional memoization if needed</li>
              </ul>
            </li>
            <li><strong>State Management Migration</strong> - Complex state object with many interdependencies. Mitigation: Use Zustand for simpler migration path than Redux, normalize state structure from the start. Contingency: Incremental migration, test thoroughly.</li>
            <li><strong>Performance with Large Stories</strong> - React re-renders may be slower than vanilla JS. Mitigation: Use React.memo, useMemo, useCallback strategically, virtualize long lists when needed. Contingency: Profile and optimize as needed.</li>
          </ul>

          <h3>Medium Risk</h3>
          <ul>
            <li><strong>Cross-Tab Yarny Conflicts</strong>
              <ul>
                <li><strong>Risk</strong>: Two Yarny tabs editing the same snippet simultaneously can cause data loss or conflicts</li>
                <li><strong>Mitigation Strategies</strong>:
                  <ul>
                    <li><strong>Cross-tab detection</strong>: Use <code>BroadcastChannel</code> API or <code>localStorage</code> heartbeat to detect when multiple Yarny tabs are open</li>
                    <li><strong>Read-only mode for inactive tabs</strong>: When a snippet is being edited in one tab, mark it as read-only in other tabs with a visual indicator</li>
                    <li><strong>Tab coordination</strong>: Broadcast snippet edit state across tabs; inactive tabs show "Editing in another tab" message</li>
                    <li><strong>Storage heartbeat</strong>: Each tab broadcasts its active snippet ID and timestamp; tabs detect conflicts and coordinate access</li>
                  </ul>
                </li>
                <li><strong>Implementation</strong>: Add <code>src/hooks/useCrossTabCoordination.ts</code> hook using BroadcastChannel API</li>
                <li><strong>Contingency</strong>: Fall back to localStorage events if BroadcastChannel is unavailable</li>
                <li><strong>Status</strong>: Medium risk - requires careful coordination but prevents data loss</li>
              </ul>
            </li>
            <li><strong>Google Drive API Integration</strong> - React hooks may need different error handling. Mitigation: Backend already works, converting to TypeScript provides type safety. Status: Low risk, TypeScript conversion adds safety without changing functionality.</li>
            <li><strong>Feature Parity</strong> - Missing features during migration. Mitigation: Create feature checklist, test each feature.</li>
            <li><strong>Design Drift with MUI</strong>
              <ul>
                <li><strong>Risk</strong>: MUI's default styling may cause visual drift from existing brand design</li>
                <li><strong>Mitigation Strategies</strong>:
                  <ul>
                    <li><strong>Start theme with palette tokens and gradient from Phase 1</strong>: Create <code>src/theme/theme.ts</code> with all 12-color accent palette and gradient tokens mapped to MUI's theme system from the very start</li>
                    <li><strong>Brand as source of truth</strong>: Existing 12-color categorical accent system and gradient aesthetic are the design foundation - MUI components will be customized to match this palette, not the other way around</li>
                    <li><strong>Theme provider in app root</strong>: Set up ThemeProvider in Phase 1 so all components inherit the brand feel from day one</li>
                    <li><strong>Customize component defaults early</strong>: Match MUI component defaults (Dialog, Button, Menu, Tabs, etc.) to existing design in Phase 1, before building components</li>
                  </ul>
                </li>
                <li><strong>Contingency</strong>: Can adjust theme customization incrementally, but starting early prevents drift</li>
              </ul>
            </li>
            <li><strong>CSS/Styling Migration</strong> - Styling may break during migration. Mitigation: Use CSS modules or styled-components for isolation, start with brand palette in MUI theme from Phase 1.</li>
          </ul>

          <h3>Low Risk</h3>
          <ul>
            <li><strong>Build Configuration</strong> - Netlify build may need adjustments. Mitigation: Netlify has good React support, standard config. Status: Well-documented, low risk.</li>
            <li><strong>Third-Party Library Issues</strong> - Libraries may have bugs or incompatibilities. Mitigation: Use well-maintained, popular libraries. Status: All recommended libraries are stable.</li>
          </ul>
        </section>

        <section class="docs-section" id="benefits">
          <h2 id="benefits-of-migration">Benefits of Migration</h2>
          
          <h3>Development Benefits</h3>
          <ol>
            <li><strong>Reduced Code</strong>: ~3,300-4,200 lines replaced by libraries</li>
            <li><strong>Better Maintainability</strong>: React's component model is easier to maintain</li>
            <li><strong>Type Safety</strong>: TypeScript provides compile-time error checking and better IDE support</li>
            <li><strong>Developer Experience</strong>: Hot reload, better tooling, autocomplete, refactoring support</li>
            <li><strong>Easier Testing</strong>: React Testing Library makes testing easier, TypeScript catches errors before runtime</li>
            <li><strong>Better Documentation</strong>: TypeScript types serve as inline documentation</li>
            <li><strong>Safer Refactoring</strong>: TypeScript ensures changes don't break existing code</li>
          </ol>

          <h3>User Benefits</h3>
          <ol>
            <li><strong>Better Accessibility</strong>: Material UI components are fully accessible</li>
            <li><strong>Improved Performance</strong>: React optimizations (memoization, etc.)</li>
            <li><strong>Better UX</strong>: Polished interactions from proven libraries</li>
            <li><strong>Future Features</strong>: Easier to add new features in React</li>
          </ol>

          <h3>Business Benefits</h3>
          <ol>
            <li><strong>Faster Development</strong>: Future features will be faster to build</li>
            <li><strong>Easier Hiring</strong>: More developers know React than vanilla JS</li>
            <li><strong>Ecosystem</strong>: Access to React ecosystem of tools and libraries</li>
            <li><strong>Long-term Maintainability</strong>: React is a stable, long-term choice</li>
          </ol>
        </section>

        <section class="docs-section" id="netlify-config">
          <h2 id="netlify-configuration">Netlify Configuration</h2>
          
          <h3>Current Setup</h3>
          <ul>
            <li>✅ Netlify Functions already configured</li>
            <li>✅ Build settings in <code>netlify.toml</code></li>
            <li>✅ Redirects configured</li>
            <li>✅ Existing app served from <code>public/</code> directory</li>
          </ul>

          <h3>Deployment Strategy: Parallel Paths</h3>
          <p>The React app will be deployed to <code>/react</code> path while keeping the existing app at root:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>yarny.lindsaybrunner.com/          → Existing vanilla JS app (public/)
yarny.lindsaybrunner.com/react/*   → New React app (dist/)</code></pre>

          <h3>Required Changes</h3>
          
          <h4>Option 1: Separate Build Directory (Recommended)</h4>
          <p>Create a new <code>netlify-react.toml</code> for React app deployment:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code># netlify-react.toml (for React app at /react path)

[build]
  command = "npm run build"
  publish = "dist"

[build.environment]
  NODE_VERSION = "20"

# Serve React app at /react path
[[redirects]]
  from = "/react/*"
  to = "/react/index.html"
  status = 200

# Ensure React app assets are accessible
[[redirects]]
  from = "/react/assets/*"
  to = "/react/assets/:splat"
  status = 200</code></pre>

          <h4>Option 2: Combined Configuration</h4>
          <p>Update existing <code>netlify.toml</code> to handle both:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>[build]
  command = "npm run build"
  publish = "dist"  # React app builds to dist/

[build.environment]
  NODE_VERSION = "20"

# Serve existing app at root (from public/ directory)
# Note: This requires keeping public/ as static files
# or using a different build process

# Serve React app at /react path
[[redirects]]
  from = "/react/*"
  to = "/react/index.html"
  status = 200

# Existing app routes (unchanged)
[[redirects]]
  from = "/editor.html"
  to = "/editor.html"
  status = 200

[[redirects]]
  from = "/stories.html"
  to = "/stories.html"
  status = 200

# Catch-all for React Router (only for /react path)
[[redirects]]
  from = "/react/*"
  to = "/react/index.html"
  status = 200</code></pre>

          <h4>Vite Configuration for Base Path</h4>
          <p>Update <code>vite.config.ts</code> to set base path (TypeScript configuration):</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  base: '/react/',  // Important: Set base path for /react deployment
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
  },
  resolve: {
    alias: {
      '@': '/src',  // TypeScript path alias for cleaner imports
    },
  },
})</code></pre>

          <h4>TypeScript Configuration</h4>
          <p>Create <code>tsconfig.json</code>:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}</code></pre>

          <h4>React Router Configuration with Loaders</h4>
          <p>Update React Router to work with <code>/react</code> base path and use loaders for pre-fetching Drive API data (TypeScript):</p>
          <p><strong>Why React Router Loaders?</strong></p>
          <ul>
            <li><strong>Performance</strong>: Start fetching Drive API data BEFORE route components render, reducing perceived load time</li>
            <li><strong>Better UX</strong>: Route-level loading states while data is being fetched</li>
            <li><strong>Integration</strong>: Works seamlessly with React Query - loaders call <code>prefetchQuery()</code>, components use <code>useQuery()</code></li>
            <li><strong>Error Handling</strong>: Route-level error boundaries for Drive API failures</li>
          </ul>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/routes.tsx
import { createBrowserRouter } from 'react-router-dom';
import { queryClient } from './lib/react-query';
import { 
  driveKeys, 
  getOrCreateYarnyStories, 
  listDriveFiles,
  readDriveFile 
} from './hooks/useDriveQueries';
import { LoginPage } from './components/auth/LoginPage';
import { StoriesPage } from './components/stories/StoriesPage';
import { EditorPage } from './components/editor/EditorPage';

export const router = createBrowserRouter([
  {
    path: '/',
    element: &lt;LoginPage /&gt;,
  },
  {
    path: '/stories',
    loader: async () => {
      // Prefetch Yarny Stories folder before StoriesPage renders
      const folder = await queryClient.prefetchQuery({
        queryKey: driveKeys.yarnyStories(),
        queryFn: () => getOrCreateYarnyStories(),
      });
      
      // Prefetch stories list if folder exists
      if (folder?.id) {
        await queryClient.prefetchQuery({
          queryKey: driveKeys.list(folder.id),
          queryFn: () => listDriveFiles(folder.id),
        });
      }
      
      return null;
    },
    element: &lt;StoriesPage /&gt;,
  },
  {
    path: '/editor/:storyId?',
    loader: async ({ params }) => {
      const { storyId } = params;
      
      // Prefetch Yarny Stories folder
      const folder = await queryClient.prefetchQuery({
        queryKey: driveKeys.yarnyStories(),
        queryFn: () => getOrCreateYarnyStories(),
      });
      
      // Prefetch project.json if storyId is provided
      if (storyId && folder?.id) {
        const projectFileId = `${storyId}/project.json`;
        await queryClient.prefetchQuery({
          queryKey: driveKeys.file(projectFileId),
          queryFn: () => readDriveFile({ fileId: projectFileId }),
        });
      }
      
      return null;
    },
    element: &lt;EditorPage /&gt;,
  },
], {
  basename: '/react',
});

// src/App.tsx
import { RouterProvider } from 'react-router-dom';
import { QueryClientProvider } from '@tanstack/react-query';
import { queryClient } from './lib/react-query';
import { router } from './routes';

export function App(): JSX.Element {
  return (
    &lt;QueryClientProvider client={queryClient}&gt;
      &lt;RouterProvider router={router} /&gt;
    &lt;/QueryClientProvider&gt;
  );
}</code></pre>

          <h3>Build Scripts</h3>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>{
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "netlify:dev": "netlify dev"
  }
}</code></pre>
        </section>

        <section class="docs-section" id="next-steps">
          <h2 id="next-steps-heading">Next Steps</h2>
          <ol>
            <li><strong>Review & Approve Plan</strong> - Get stakeholder buy-in</li>
            <li><strong>Set Up Development Environment</strong> - Install dependencies, configure build</li>
            <li><strong>Configure Netlify for Parallel Deployment</strong> - Set up <code>/react</code> path routing</li>
            <li><strong>Create Proof of Concept</strong> - Migrate one small component to validate approach</li>
            <li><strong>Deploy to <code>/react</code> Path</strong> - Test deployment and routing</li>
            <li><strong>Begin Phase 1</strong> - Set up infrastructure</li>
            <li><strong>Iterate</strong> - Follow migration phases</li>
          </ol>

          <h3>Testing Strategy with Parallel Deployment</h3>
          <ul>
            <li><strong>Development:</strong> Test React app locally at <code>localhost:5173/react</code></li>
            <li><strong>Staging:</strong> Deploy React app to <code>yarny.lindsaybrunner.com/react</code></li>
            <li><strong>Comparison:</strong> Side-by-side testing with existing app</li>
            <li><strong>User Testing:</strong> Invite users to test React version at <code>/react</code> path</li>
            <li><strong>Migration:</strong> Once validated, can switch root to React app or keep both</li>
          </ul>
        </section>

        <section class="docs-section" id="file-structure">
          <h2 id="file-structure-proposed">File Structure (Proposed)</h2>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>yarny-app/
├── src/
│   ├── components/
│   │   ├── auth/
│   │   │   ├── LoginPage.tsx
│   │   │   └── AuthProvider.tsx
│   │   ├── editor/
│   │   │   ├── Editor.tsx
│   │   │   ├── StorySidebar.tsx
│   │   │   ├── NotesSidebar.tsx
│   │   │   ├── TipTapEditor.tsx        # Plain text only configuration
│   │   │   └── ...
│   │   ├── stories/
│   │   │   ├── StoriesList.tsx
│   │   │   ├── StoryCard.tsx
│   │   │   └── ...
│   │   ├── ui/
│   │   │   ├── Modal.tsx
│   │   │   ├── ColorPicker.tsx
│   │   │   ├── ContextMenu.tsx
│   │   │   └── ...
│   │   └── shared/
│   │       ├── Header.tsx
│   │       └── Footer.tsx
│   ├── hooks/
│   │   ├── useDriveQueries.ts              # React Query hooks for ALL Drive I/O
│   │   ├── useConflictDetection.ts         # Conflict detection between Yarny and Drive
│   │   ├── useWindowFocusReconciliation.ts # Reconciliation on window focus
│   │   ├── useAuth.ts
│   │   ├── useStory.ts
│   │   ├── useGoal.ts
│   │   └── ...
│   ├── lib/
│   │   └── react-query.ts        # React Query QueryClient configuration
│   ├── theme/
│   │   └── theme.ts               # MUI theme customization with brand color mappings
│   ├── utils/
│   │   ├── wordCount.ts
│   │   ├── export.ts
│   │   ├── goalCalculation.ts
│   │   ├── textExtraction.ts     # Plain text extraction matching Google Docs format
│   │   └── ...
│   ├── store/
│   │   ├── store.ts (Zustand)
│   │   ├── types.ts (Normalized state types)
│   │   └── selectors.ts (Selectors for derived views - see example below)
│   │       # Example: useGroupsList() derives array from normalized groups Record
│   │       # Convention: "derive, don't duplicate" - views computed via selectors, not stored in state
│   ├── api/
│   │   ├── contract.ts      # API contract definitions (types + Zod schemas)
│   │   ├── client.ts        # Typed API client functions
│   │   └── types.ts         # Shared API types (if needed)
│   ├── App.tsx
│   ├── main.tsx
│   └── routes.tsx
├── public/
│   └── (static assets)
├── netlify/
│   └── functions/
│       ├── types.ts              # Shared TypeScript types for all functions
│       ├── auth/
│       │   ├── config.ts
│       │   ├── login.ts
│       │   ├── register.ts
│       │   ├── storage.ts
│       │   ├── verify-login.ts
│       │   └── verify-register.ts
│       ├── config.ts
│       ├── drive-auth.ts
│       ├── drive-auth-callback.ts
│       ├── drive-check-comments.ts
│       ├── drive-client.ts
│       ├── drive-create-folder.ts
│       ├── drive-delete-file.ts
│       ├── drive-delete-story.ts
│       ├── drive-get-or-create-yarny-stories.ts
│       ├── drive-list.ts
│       ├── drive-read.ts
│       ├── drive-rename-file.ts
│       ├── drive-write.ts
│       ├── logout.ts
│       ├── uptime-status.ts
│       └── verify-google.ts
├── package.json
├── vite.config.ts
├── tsconfig.json
└── netlify.toml</code></pre>
        </section>

        <section class="docs-section" id="decision-points">
          <h2 id="decision-points-heading">Decision Points</h2>
          
          <h3>State Management: Context API vs Zustand vs Redux</h3>
          <p><strong>Recommendation: Zustand</strong></p>
          <ul>
            <li>✅ Simpler than Redux, more powerful than Context</li>
            <li>✅ Easy migration from global state object</li>
            <li>✅ Good TypeScript support</li>
            <li>✅ Small bundle size</li>
            <li><strong>Alternative</strong>: Context API (if team prefers built-in solution)</li>
            <li><strong>Trigger for change</strong>: If Zustand's API becomes too limiting for complex state updates or if React Context performance becomes acceptable for our use case</li>
          </ul>

          <h3>Text Editor: TipTap vs Slate vs Draft.js</h3>
          <p><strong>Recommendation: TipTap (Plain Text Only)</strong></p>
          <ul>
            <li>✅ Modern, React-first</li>
            <li>✅ Excellent documentation</li>
            <li>✅ Active development</li>
            <li>✅ Good performance</li>
            <li>✅ <strong>Configured for plain text only</strong> - matches Yarny's minimalist model and Google Docs round-tripping requirements</li>
            <li><strong>Alternative</strong>: Slate (if need more customization, but plain text constraint still applies)</li>
            <li><strong>Trigger for change</strong>: If TipTap's plain text extraction diverges from Google Docs API format and cannot be normalized, or if TipTap introduces breaking changes that conflict with our plain text constraint</li>
          </ul>

          <h3>Build Tool: Vite vs Create React App vs Webpack</h3>
          <p><strong>Recommendation: Vite</strong></p>
          <ul>
            <li>✅ Fastest development experience</li>
            <li>✅ Modern, simple configuration</li>
            <li>✅ Great TypeScript support</li>
            <li>✅ Smaller bundle sizes</li>
            <li><strong>Alternative</strong>: CRA (if team prefers familiarity)</li>
            <li><strong>Trigger for change</strong>: If Vite's build output has compatibility issues with Netlify deployment or if Vite's plugin ecosystem becomes insufficient for our needs</li>
          </ul>

          <h3>Routing: React Router with Loaders vs State-Based Navigation</h3>
          <p><strong>Recommendation: React Router with Loaders</strong> ✅</p>
          <ul>
            <li>✅ <strong>Performance</strong>: Start fetching Drive API data BEFORE route components render</li>
            <li>✅ <strong>Better UX</strong>: Route-level loading states while slow Drive API calls are in progress</li>
            <li>✅ <strong>Integration</strong>: Loaders use React Query <code>prefetchQuery()</code>, components use <code>useQuery()</code> hooks</li>
            <li>✅ <strong>Error Handling</strong>: Route-level error boundaries for Drive API failures</li>
            <li>✅ <strong>Browser History</strong>: Proper back/forward button support and URL management</li>
            <li>✅ <strong>Future-Proof</strong>: Easy to add more routes, route params, or protected routes later</li>
            <li><strong>Why not state-based</strong>: Would require data fetching after component mount, adding latency to slow Drive API calls</li>
            <li><strong>Why not hash routing</strong>: Less clean URLs, no route-level data loading capabilities</li>
            <li><strong>Trigger for change</strong>: If React Router's bundle size (~10KB) becomes a concern and performance gains don't justify it</li>
          </ul>

          <h3>TypeScript: Required</h3>
          <p><strong>Decision: TypeScript from the start</strong> ✅</p>
          <ul>
            <li>✅ Better developer experience with autocomplete and IntelliSense</li>
            <li>✅ Catch errors at compile-time, not runtime</li>
            <li>✅ Better IDE support (refactoring, navigation, find references)</li>
            <li>✅ Type safety prevents common bugs</li>
            <li>✅ Self-documenting code through types</li>
            <li>✅ Easier to maintain and refactor large codebases</li>
            <li>✅ All recommended libraries have excellent TypeScript support</li>
            <li>✅ TypeScript is now the industry standard for React projects</li>
            <li><strong>Trigger for change</strong>: None - TypeScript is a hard requirement for this migration</li>
          </ul>
        </section>

        <section class="docs-section" id="success-criteria">
          <h2 id="success-criteria-heading">Success Criteria</h2>
          
          <h3>Must Have (MVP)</h3>
          <ul>
            <li>All existing features work</li>
            <li>No regression in functionality</li>
            <li><strong>Performance budgets met</strong>:
              <ul>
                <li>Time-to-first-keystroke after editor mount ≤ 800 ms</li>
                <li>Snippet switch to interactive ≤ 300 ms (medium corpus, hot path)</li>
                <li>Background load never blocks typing (no jank &gt; 16 ms frames)</li>
                <li>Budgets met on medium corpus; virtualization kicks in automatically for large corpus</li>
              </ul>
            </li>
            <li>Authentication works</li>
            <li>Google Drive sync works</li>
            <li>Editor saves correctly</li>
            <li>Export functionality works</li>
            <li><strong>Classic UX anchors preserved</strong>: Goal meter, Today chip, footer word/character counts look and behave identically</li>
            <li><strong>Phase 1 Definition of Done</strong>: TanStack Query (React Query) fully configured and used for ALL Drive I/O operations</li>
            <li><strong>Phase 1 Definition of Done</strong>: API contract formalization with Zod schemas and runtime validation implemented</li>
            <li><strong>Visual parity</strong>: Side-by-side <code>/react</code> vs. root checks pass for: goal meter, Today chip, footer counts, story cards, and modal spacing. Document "diff" screenshots as artifacts.</li>
            <li><strong>Concurrency safety</strong>: Conflicts surfaced for Docs edits and second Yarny tabs; no silent last-writer-wins. (Verified in test checklist.)</li>
            <li><strong>Round-trip integrity</strong>: Paragraphs and soft line breaks round-trip without collapse/duplication; rich-text paste is stripped, special characters preserved.</li>
            <li><strong>Bundle discipline</strong>: Starter-kit removed; only the TipTap extensions actually used are shipped (Document, Paragraph, Text, HardBreak, History).</li>
          </ul>

          <h3>Should Have</h3>
          <ul>
            <li><strong>Accessibility polish beyond MUI defaults</strong>:
              <ul>
                <li>Minimum contrast ratios: 4.5:1 for text, 3:1 for UI chrome (tested against soft chips and dark surfaces)</li>
                <li>Visible focus rings on all actionable items (especially left rail and modal footers)</li>
                <li>Keyboard-only flows for reordering lists (dnd-kit keyboard navigation intentionally wired)</li>
                <li><strong>Keyboard-only completion of core tasks</strong>: Create/rename/reorder/export operations completable via keyboard only</li>
                <li><strong>Contrast checks on every chip color</strong>: All 12 accent colors (base, soft, dark variants) meet contrast requirements</li>
              </ul>
            </li>
            <li>Improved error handling</li>
            <li>Better loading states</li>
            <li>Complete TypeScript type coverage (all components, hooks, utilities)</li>
            <li>Type-safe API calls and state management</li>
            <li><strong>Editor truth and Google Docs round-tripping: plain text only, editor authoritative while open, reconciliation on focus</strong></li>
            <li><strong>Configurable virtualization thresholds</strong>: Virtualization thresholds (50+ chapters, 200+ snippets) exposed as settings for tuning without redeployment</li>
            <li><strong>Chunked export writes</strong>: Large chapter exports handle batchUpdate body limits with chunked writes</li>
            <li><strong>Order persistence</strong>: Order (groupIds/snippetIds) is persisted in Drive metadata as first-class field, survives concurrent edits and background loads</li>
          </ul>

          <h3>Nice to Have</h3>
          <ul>
            <li>Performance improvements</li>
            <li>Better mobile experience</li>
            <li>Additional features enabled by React</li>
            <li>Advanced TypeScript features (discriminated unions, branded types)</li>
            <li>TypeScript strict mode enabled</li>
            <li>Generated API types from OpenAPI/Swagger (if applicable)</li>
          </ul>
        </section>

        <section class="docs-section" id="notes-considerations">
          <h2 id="notes-considerations-heading">Notes & Considerations</h2>
          
          <h3>Keeping Old Code</h3>
          <ul>
            <li>Keep existing <code>public/</code> files until migration is complete</li>
            <li>Deploy React app to <code>/react</code> path for parallel testing</li>
            <li>Existing app remains at root (<code>yarny.lindsaybrunner.com</code>)</li>
            <li>Can run both versions side-by-side during migration</li>
            <li>Switch over when new version is feature-complete</li>
            <li>Option to keep both versions permanently or gradually migrate users</li>
          </ul>

          <h3>Testing Strategy</h3>
          <ol>
            <li><strong>Round-Trip Test</strong>: Edit in Yarny → Save → Edit in Google Docs → Check Yarny → Verify no format loss</li>
            <li><strong>Cross-Edit Test (Critical)</strong>: 
              <ul>
                <li>Open Yarny and load a snippet (make it idle, not actively editing)</li>
                <li>Open the same Google Doc in Google Docs in another tab/window</li>
                <li>Make edits in Google Docs</li>
                <li>Return to Yarny (switch snippets or refocus window)</li>
                <li>Verify conflict detection works correctly and conflict modal appears</li>
              </ul>
            </li>
            <li><strong>Conflict Test</strong>: Edit in Yarny → Edit in Google Docs → Switch snippets → Verify conflict detection</li>
            <li><strong>Reconciliation Test</strong>: Edit in Google Docs (other tab) → Focus Yarny window → Verify reconciliation notification</li>
            <li><strong>Format Test</strong>: Paste rich text → Verify it's stripped to plain text</li>
            <li><strong>Line Break Test</strong>: Test paragraph breaks (<code>\n\n</code>) and soft breaks (<code>\n</code>)</li>
            <li>Manual testing for each feature</li>
            <li>Test with real Google Drive data</li>
            <li>Test edge cases (large stories, many snippets, etc.)</li>
            <li>Cross-browser testing (Chrome, Firefox, Safari, Edge)</li>
          </ol>

          <h3 id="test-strategy-drive-docs">Test Strategy Specific to Drive/Docs (P2 Priority)</h3>
          <p><strong>Why</strong>: Google Drive and Google Docs integration is critical to Yarny's functionality. Round-tripping between Yarny's editor and Google Docs can introduce subtle bugs that only appear with real Drive data. A structured test corpus ensures regressions are obvious and all critical paths are validated.</p>
          <p><strong>What</strong>: Create a dedicated test corpus in a separate Google Drive folder with three project sizes (small, medium, large) and document smoke tests that validate all Drive/Docs operations.</p>

          <h4>1. Test Corpus Setup</h4>
          <p>Create a dedicated Google Drive folder: <strong><code>Yarny Test Corpus</code></strong> (separate from production <code>Yarny Stories</code> folder)</p>

          <p><strong>Small Project</strong> (<code>test-small</code>):</p>
          <ul>
            <li>1 story</li>
            <li>3 chapters</li>
            <li>5 snippets per chapter (15 total snippets)</li>
            <li>2 People, 2 Places, 2 Things notes</li>
            <li>~5,000 words total</li>
            <li><strong>Special test snippets</strong>:
              <ul>
                <li>One snippet with mixed line endings (<code>\n</code>, <code>\r\n</code>, <code>\r</code>)</li>
                <li>One snippet with NBSPs and trailing spaces</li>
                <li>One snippet with CJK text (Japanese, Chinese, Korean)</li>
                <li>One snippet with emoji and Unicode characters</li>
                <li>One snippet with long-press accents (é, è, ê, ë, ñ, ü, etc.)</li>
              </ul>
            </li>
            <li><strong>Purpose</strong>: Fast smoke tests, basic operations, format normalization, IME composition</li>
          </ul>

          <p><strong>Medium Project</strong> (<code>test-medium</code>):</p>
          <ul>
            <li>1 story</li>
            <li>10 chapters</li>
            <li>8 snippets per chapter (80 total snippets)</li>
            <li>10 People, 10 Places, 10 Things notes</li>
            <li>~25,000 words total</li>
            <li><strong>Purpose</strong>: Realistic project size, performance testing</li>
          </ul>

          <p><strong>Large Project</strong> (<code>test-large</code>):</p>
          <ul>
            <li>1 story</li>
            <li>25 chapters</li>
            <li>15 snippets per chapter (375 total snippets)</li>
            <li><strong>1 very large chapter</strong>: 1 chapter with 50+ snippets (tests export chunking and batchUpdate body limits)</li>
            <li>25 People, 25 Places, 25 Things notes</li>
            <li>~100,000 words total</li>
            <li><strong>Purpose</strong>: Stress testing, virtualization validation, lazy loading, export chunking validation</li>
          </ul>

          <p><strong>Test Corpus Structure</strong>:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>Yarny Test Corpus/
├── test-small/
│   ├── Chapters/
│   │   ├── Chapter 1/
│   │   │   ├── snippet-1.json (metadata)
│   │   │   └── snippet-1.gdoc (Google Doc)
│   │   ├── Chapter 2/
│   │   └── Chapter 3/
│   ├── People/
│   ├── Places/
│   ├── Things/
│   ├── story.json
│   └── goal.json
├── test-medium/
│   └── (same structure, more content)
└── test-large/
    └── (same structure, much more content)</code></pre>

          <h4>2. Smoke Tests</h4>
          <p>Document and execute these smoke tests for each project size to validate critical paths:</p>

          <p><strong>A. Create Operations</strong></p>
          <ul>
            <li>[ ] Create new story → Verify folder structure in Drive</li>
            <li>[ ] Create new chapter → Verify chapter folder created</li>
            <li>[ ] Create new snippet → Verify Google Doc created in correct chapter folder</li>
            <li>[ ] Create People/Places/Things note → Verify text file created in correct folder</li>
            <li>[ ] Create story with goal → Verify <code>goal.json</code> created and loaded correctly</li>
          </ul>

          <p><strong>B. Rename Operations</strong></p>
          <ul>
            <li>[ ] Rename story → Verify folder renamed in Drive, story list updates</li>
            <li>[ ] Rename chapter → Verify chapter folder renamed, metadata updated</li>
            <li>[ ] Rename snippet → Verify Google Doc renamed, metadata updated</li>
            <li>[ ] Rename People/Places/Things note → Verify file renamed, metadata updated</li>
          </ul>

          <p><strong>C. Reorder Operations</strong></p>
          <ul>
            <li>[ ] Reorder chapters (drag &amp; drop) → Verify order persisted in Drive, UI reflects order</li>
            <li>[ ] Reorder snippets within chapter → Verify order persisted in Drive, UI reflects order</li>
            <li>[ ] Reorder across chapters → Verify snippets moved to correct chapter folders</li>
          </ul>

          <p><strong>D. Edit Operations</strong></p>
          <ul>
            <li>[ ] Edit snippet content → Verify changes saved to Google Doc</li>
            <li>[ ] Edit snippet title/description → Verify metadata updated in Drive</li>
            <li>[ ] Edit chapter title/description → Verify metadata updated in Drive</li>
            <li>[ ] Edit story title/genre/description → Verify metadata updated in Drive</li>
            <li>[ ] Edit goal settings → Verify <code>goal.json</code> updated and loaded correctly</li>
            <li>[ ] Edit People/Places/Things note → Verify text file updated</li>
          </ul>

          <p><strong>E. Export Operations</strong></p>
          <ul>
            <li>[ ] Export all chapters → Verify combined Google Doc created with all snippets in order</li>
            <li>[ ] Export outline → Verify outline document created with titles and descriptions</li>
            <li>[ ] Export all People → Verify combined document created</li>
            <li>[ ] Export all Places → Verify combined document created</li>
            <li>[ ] Export all Things → Verify combined document created</li>
            <li>[ ] Verify export filenames match user input</li>
            <li>[ ] Verify exports appear in story folder in Drive</li>
            <li>[ ] <strong>Export very large chapter (50+ snippets)</strong>:
              <ul>
                <li>[ ] Verify export handles batchUpdate body limits correctly</li>
                <li>[ ] Verify chunked writes are used when chapter exceeds batchUpdate size limit</li>
                <li>[ ] Verify all snippets are included in export (no truncation)</li>
                <li>[ ] Verify export completes successfully without errors</li>
                <li>[ ] Verify export order is preserved across chunks</li>
                <li>[ ] Verify progress indication during chunked export</li>
              </ul>
            </li>
          </ul>

          <p><strong>F. Conflict Resolution</strong></p>
          <ul>
            <li>[ ] Edit snippet in Yarny → Edit same snippet in Google Docs (other tab) → Switch snippets → Verify conflict detected</li>
            <li>[ ] Edit snippet in Google Docs → Focus Yarny window → Verify reconciliation notification appears</li>
            <li>[ ] Resolve conflict: Keep Yarny version → Verify Yarny version overwrites Drive</li>
            <li>[ ] Resolve conflict: Use Drive version → Verify Drive version replaces Yarny content</li>
            <li>[ ] Edit snippet in Yarny → Add comments in Google Docs → Save in Yarny → Verify comments warning appears</li>
            <li>[ ] Edit snippet in Yarny → Add tracked changes in Google Docs → Save in Yarny → Verify tracked changes warning appears</li>
          </ul>

          <p><strong>G. Round-Trip Testing</strong></p>
          <ul>
            <li>[ ] Edit snippet in Yarny → Save → Edit in Google Docs → Switch snippets → Verify no format loss</li>
            <li>[ ] Edit snippet in Google Docs → Load in Yarny → Verify content matches (plain text only)</li>
            <li>[ ] <strong>Rich-text paste stripping</strong>: Paste rich text in Yarny → Verify stripped to plain text</li>
            <li>[ ] <strong>Paragraph breaks</strong>: Test paragraph breaks (<code>\n\n</code>) → Verify preserved in round-trip without collapse/duplication</li>
            <li>[ ] <strong>Soft line breaks</strong>: Test soft line breaks (<code>\n</code>) → Verify preserved in round-trip without collapse/duplication</li>
            <li>[ ] <strong>Special characters</strong>: Test special characters (quotes, em dashes, etc.) → Verify preserved in round-trip</li>
            <li>[ ] <strong>No collapse/duplication</strong>: Test content with multiple paragraph breaks → Verify no unintended collapse or duplication of breaks</li>
            <li>[ ] <strong>Format/Line Break Tests</strong>: Paste content with mixed <code>\n</code>/<code>\r\n</code> line endings → Round-trip through Docs → Verify normalized correctly</li>
            <li>[ ] <strong>NBSP and Trailing Spaces</strong>: Paste content with non-breaking spaces (NBSP) and trailing spaces → Round-trip through Docs → Verify normalized correctly (NBSP → space, trailing spaces may be collapsed)</li>
            <li>[ ] <strong>Mixed Line Endings</strong>: Test content with <code>\n</code>, <code>\r\n</code>, and <code>\r</code> → Round-trip → Verify all normalized to <code>\n</code></li>
          </ul>

          <p><strong>H. Performance &amp; Loading</strong></p>
          <ul>
            <li>[ ] Load large project (test-large) → Verify initial load time acceptable (&lt; 5 seconds)</li>
            <li>[ ] <strong>Time-to-first-edit (hot path)</strong>: Open snippet already in cache → Start typing → Verify latency ≤300 ms from click to first character appearing</li>
            <li>[ ] <strong>Time-to-first-edit (cold path)</strong>: Open snippet not yet loaded → Start typing → Verify latency ≤1.5 s from click to first character appearing (includes Drive fetch)</li>
            <li>[ ] <strong>Time-to-switch-snippet (hot path)</strong>: Switch to snippet already in cache → Verify latency ≤300 ms from click to editor ready</li>
            <li>[ ] <strong>Time-to-switch-snippet (cold path)</strong>: Switch to snippet not yet loaded → Verify latency ≤1.5 s from click to editor ready (includes Drive fetch)</li>
            <li>[ ] Scroll through chapter list in large project → Verify smooth scrolling (virtualized)</li>
            <li>[ ] Background loading → Verify non-active snippets load in background without blocking UI</li>
            <li>[ ] Lazy loading → Verify snippet content only loads when needed</li>
          </ul>

          <p><strong>I. Error Handling &amp; Rate Limiting</strong></p>
          <ul>
            <li>[ ] Network error during save → Verify error message displayed, retry works</li>
            <li>[ ] Invalid Drive permissions → Verify clear error message</li>
            <li>[ ] <strong>Drive API rate limit (429)</strong>:
              <ul>
                <li>[ ] Trigger rate limit (rapid requests) → Verify exponential backoff with jitter is applied</li>
                <li>[ ] Verify retry happens only when tab is visible (background tabs don't retry)</li>
                <li>[ ] Verify error message displayed to user with clear explanation</li>
                <li>[ ] Verify automatic retry after backoff delay completes</li>
                <li>[ ] Verify no infinite retry loops (max 3 retries)</li>
              </ul>
            </li>
            <li>[ ] Corrupted metadata file → Verify error handling, recovery option</li>
          </ul>

          <p><strong>L. Visibility-Based Request Gating</strong></p>
          <ul>
            <li>[ ] Open Yarny in multiple tabs → Verify only visible tab makes background prefetch requests</li>
            <li>[ ] Switch between tabs → Verify background prefetching pauses in hidden tab, resumes in visible tab</li>
            <li>[ ] Verify no request storms when tab is in background (prevents Drive quota exhaustion)</li>
            <li>[ ] Verify mutations (save, delete, rename) also respect visibility gating</li>
          </ul>

          <p><strong>J. IME Composition &amp; Internationalization</strong></p>
          <ul>
            <li>[ ] Type in Japanese (IME composition) → Verify word count updates only after <code>compositionend</code> event</li>
            <li>[ ] Type in Chinese (IME composition) → Verify save debouncing respects <code>compositionstart</code>/<code>compositionend</code></li>
            <li>[ ] Type in Korean (IME composition) → Verify no premature updates during composition</li>
            <li>[ ] <strong>Long-press accents</strong>: Type long-press accents (é, è, ê, ë, ñ, ü, etc.) → Verify word count and save behavior correct</li>
            <li>[ ] <strong>Emoji composition</strong>: Type emoji (Unicode composition) → Verify word count and save behavior correct</li>
            <li>[ ] <strong>Emoji picker</strong>: Use emoji picker to insert emoji → Verify word count and save behavior correct</li>
            <li>[ ] Test CJK text in test corpus → Verify round-trip preserves content correctly</li>
            <li>[ ] Test emoji in test corpus → Verify round-trip preserves content correctly</li>
            <li>[ ] <strong>Round-trip long-press accents</strong>: Test long-press accents in test corpus → Verify round-trip preserves content correctly</li>
          </ul>

          <p><strong>K. Cross-Tab Conflicts (Yarny vs. Yarny)</strong></p>
          <ul>
            <li>[ ] <strong>Immediate warning/lock</strong>: Open snippet in Tab 1 → Open same snippet in Tab 2 → Verify Tab 2 immediately shows warning/lock when opening snippet already edited in Tab 1</li>
            <li>[ ] <strong>Read-only mode</strong>: Edit snippet in Tab 1 → Try to edit in Tab 2 → Verify Tab 2 is read-only with visual indicator</li>
            <li>[ ] <strong>Tab timeout</strong>: Open snippet in Tab 1 → Make Tab 1 inactive (switch to other tab) → Wait for timeout → Verify lock released if Tab 1 becomes inactive</li>
            <li>[ ] <strong>Multiple tabs</strong>: Open snippet in Tab 1 → Open same snippet in Tab 2 and Tab 3 → Verify all tabs show appropriate warnings/locks</li>
            <li>[ ] <strong>Save propagation</strong>: Save in Tab 1 → Switch to Tab 2 → Verify Tab 2 updates with latest content</li>
            <li>[ ] <strong>Lock release</strong>: Close Tab 1 → Verify Tab 2 regains edit capability</li>
            <li>[ ] <strong>BroadcastChannel fallback</strong>: Test BroadcastChannel fallback → Verify localStorage heartbeat works if BroadcastChannel unavailable</li>
          </ul>

          <h4>3. Linking to Success Criteria</h4>
          <p>Map smoke tests to success criteria to ensure regressions are obvious:</p>
          <table style="width: 100%; border-collapse: collapse; margin: var(--space-lg) 0;">
            <thead>
              <tr style="background: rgba(0, 0, 0, 0.2);">
                <th style="padding: var(--space-md); text-align: left; border-bottom: 2px solid rgba(255, 255, 255, 0.2);">Success Criterion</th>
                <th style="padding: var(--space-md); text-align: left; border-bottom: 2px solid rgba(255, 255, 255, 0.2);">Smoke Tests</th>
                <th style="padding: var(--space-md); text-align: left; border-bottom: 2px solid rgba(255, 255, 255, 0.2);">Test Corpus</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);"><strong>Google Drive sync works</strong></td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Create, Edit, Rename, Reorder (all)</td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Small, Medium, Large</td>
              </tr>
              <tr>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);"><strong>Editor saves correctly</strong></td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Edit Operations (all)</td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Small, Medium, Large</td>
              </tr>
              <tr>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);"><strong>Export functionality works</strong></td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Export Operations (all)</td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Small, Medium</td>
              </tr>
              <tr>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);"><strong>Conflict resolution works</strong></td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Conflict Resolution (all)</td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Small, Medium</td>
              </tr>
              <tr>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);"><strong>Round-tripping works</strong></td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Round-Trip Testing (all)</td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Small, Medium</td>
              </tr>
              <tr>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);"><strong>Performance is equal or better</strong></td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Performance &amp; Loading (all)</td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Large (especially)</td>
              </tr>
              <tr>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);"><strong>No regression in functionality</strong></td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">All smoke tests</td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">All sizes</td>
              </tr>
            </tbody>
          </table>

          <h4>4. Test Execution Plan</h4>
          <p><strong>Phase 1 (Setup &amp; Infrastructure)</strong>:</p>
          <ul>
            <li>Create test corpus folder structure</li>
            <li>Populate small project with sample data</li>
            <li>Document smoke test checklist</li>
          </ul>

          <p><strong>Phase 4 (Editor - Tri-Pane Shell &amp; Plain Text Round-Trip)</strong>:</p>
          <ul>
            <li>Run smoke tests on small project after TipTap integration</li>
            <li>Validate round-tripping with small project</li>
            <li>Populate medium project</li>
          </ul>

          <p><strong>Phase 6 (Lazy Loading, Conflict Resolution &amp; Exports)</strong>:</p>
          <ul>
            <li>Run full smoke test suite on small and medium projects</li>
            <li>Validate all operations work correctly</li>
            <li>Populate large project</li>
          </ul>

          <p><strong>Phase 7 (Accessibility, Performance &amp; Polish)</strong>:</p>
          <ul>
            <li>Run full smoke test suite on all three project sizes</li>
            <li>Performance testing with large project</li>
            <li>Regression testing before production deployment</li>
          </ul>

          <h4>5. Test Corpus Maintenance</h4>
          <ul>
            <li><strong>Version Control</strong>: Document test corpus structure and expected state</li>
            <li><strong>Reset Script</strong>: Create script to reset test corpus to known good state</li>
            <li><strong>Validation</strong>: Periodically verify test corpus integrity (files exist, metadata correct)</li>
            <li><strong>Updates</strong>: Update test corpus when new features are added (e.g., new export types)</li>
          </ul>

          <h4>6. Benefits</h4>
          <ol>
            <li><strong>Obvious Regressions</strong>: Test corpus provides baseline for comparison - if something breaks, it's immediately obvious</li>
            <li><strong>Comprehensive Coverage</strong>: Smoke tests ensure all critical paths are validated</li>
            <li><strong>Performance Validation</strong>: Large project validates performance optimizations (virtualization, lazy loading)</li>
            <li><strong>Round-Trip Confidence</strong>: Structured tests ensure Google Docs integration works correctly</li>
            <li><strong>Documentation</strong>: Test corpus serves as living documentation of expected behavior</li>
          </ol>

          <h4>Implementation Timeline</h4>
          <p>This should be implemented in <strong>Phase 1</strong> (Setup &amp; Infrastructure):</p>
          <ul>
            <li>Create test corpus folder structure</li>
            <li>Populate small project</li>
            <li>Document smoke test checklist</li>
            <li>Integrate smoke tests into Phase 4, 6, and 7 testing workflow</li>
          </ul>

          <p><strong>LOE</strong>: 4-6 hours (includes creating test corpus structure, populating small/medium projects, documenting smoke tests, and setting up test execution workflow)</p>

          <h3>Performance Considerations</h3>
          <ul>
            <li>Use React.memo for expensive components</li>
            <li>Lazy load routes with React.lazy</li>
            <li>Optimize re-renders with useMemo/useCallback</li>
            <li>Consider virtual scrolling for long lists</li>
          </ul>

          <h3 id="performance-guardrails">Performance Guardrails for Big Projects (P2 Priority)</h3>
          <p><strong>Why</strong>: Large stories with many chapters and snippets can cause performance issues. The vanilla app already handles this with lazy loading; we need to carry forward these optimizations and add React-specific performance patterns.</p>
          <p><strong>What</strong>: Implement three key performance optimizations to ensure the React app performs well with large projects:</p>

          <h4>1. Virtualize Long Lists in the Left Rail</h4>
          <p><strong>Problem</strong>: When stories grow to 50+ chapters or 200+ snippets, rendering all list items at once causes:</p>
          <ul>
            <li>Slow initial render</li>
            <li>Laggy scrolling</li>
            <li>High memory usage</li>
            <li>Poor performance on lower-end devices</li>
          </ul>
          <p><strong>Solution</strong>: Use <code>@tanstack/react-virtual</code> (or similar) to virtualize the left rail lists with <strong>configurable thresholds</strong>.</p>
          <p><strong>Implementation</strong>:</p>
          <ul>
            <li>Virtualize the chapter/group list in the left sidebar</li>
            <li>Virtualize the snippet list within each chapter</li>
            <li>Only render visible items + small buffer (e.g., 5 items above/below viewport)</li>
            <li>Works seamlessly with normalized state structure (already planned)</li>
            <li><strong>Expose virtualization thresholds as configurable settings</strong> (stored in localStorage) so they can be tuned without redeploying</li>
          </ul>
          <p><strong>Configuration</strong>:</p>
          <p>Create <code>src/config/virtualization.ts</code> with configurable thresholds that can be adjusted via localStorage (default: 50+ chapters, 200+ snippets). This allows tuning performance thresholds without code changes or redeployment.</p>
          <p><strong>Code Example</strong>:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/components/editor/StorySidebar.tsx
import { useVirtualizer } from '@tanstack/react-virtual';
import { useGroupsList } from '../../store/selectors';

export function StorySidebar() {
  const groups = useGroupsList();
  const parentRef = useRef&lt;HTMLDivElement&gt;(null);
  
  const virtualizer = useVirtualizer({
    count: groups.length,
    getScrollElement: () =&gt; parentRef.current,
    estimateSize: () =&gt; 60, // Estimated row height
    overscan: 5, // Render 5 extra items above/below viewport
  });
  
  return (
    &lt;div ref={parentRef} style={{ height: '100%', overflow: 'auto' }}&gt;
      &lt;div style={{ height: `${virtualizer.getTotalSize()}px`, position: 'relative' }}&gt;
        {virtualizer.getVirtualItems().map((virtualRow) =&gt; {
          const group = groups[virtualRow.index];
          return (
            &lt;div
              key={group.id}
              style={{
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                height: `${virtualRow.size}px`,
                transform: `translateY(${virtualRow.start}px)`,
              }}
            &gt;
              &lt;GroupRow group={group} /&gt;
            &lt;/div&gt;
          );
        })}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>
          <p><strong>When to Implement</strong>:</p>
          <ul>
            <li>Phase 4 (Editor - Tri-Pane Shell) or Phase 5 (Library Features &amp; Goals UI)</li>
            <li>Add when testing with large stories (50+ chapters, 200+ snippets)</li>
            <li>Can be deferred if initial performance is acceptable, but should be in place before production</li>
          </ul>
          <p><strong>LOE</strong>: 4-6 hours (includes virtualizing both chapter and snippet lists, testing with large datasets)</p>

          <h4>2. Memoize Expensive List Rows and Editor Shell</h4>
          <p><strong>Problem</strong>: Passing anonymous callbacks and inline objects causes unnecessary re-renders:</p>
          <ul>
            <li>List rows re-render when parent re-renders (even if their data hasn't changed)</li>
            <li>Editor shell re-renders on every state update</li>
            <li>Anonymous callbacks create new function references on every render</li>
            <li>Deep prop drilling causes cascading re-renders</li>
          </ul>
          <p><strong>Solution</strong>: Use <code>React.memo</code>, <code>useMemo</code>, and <code>useCallback</code> strategically to prevent unnecessary re-renders.</p>
          <p><strong>Implementation Strategy</strong>:</p>
          <p><strong>A. Memoize List Row Components</strong>:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/components/editor/GroupRow.tsx
import React, { memo } from 'react';
import { Group } from '../../store/types';

interface GroupRowProps {
  group: Group;
  onSelect: (groupId: string) =&gt; void;
  onRename: (groupId: string, newTitle: string) =&gt; void;
  isActive: boolean;
  isCollapsed: boolean;
}

// Memoize the row component - only re-renders if props change
export const GroupRow = memo(function GroupRow({
  group,
  onSelect,
  onRename,
  isActive,
  isCollapsed,
}: GroupRowProps) {
  // Component implementation
}, (prevProps, nextProps) =&gt; {
  // Custom comparison function for better control
  return (
    prevProps.group.id === nextProps.group.id &amp;&amp;
    prevProps.group.title === nextProps.group.title &amp;&amp;
    prevProps.group.snippetIds.length === nextProps.group.snippetIds.length &amp;&amp;
    prevProps.isActive === nextProps.isActive &amp;&amp;
    prevProps.isCollapsed === nextProps.isCollapsed
  );
});</code></pre>
          <p><strong>B. Memoize Editor Shell</strong>:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/components/editor/Editor.tsx
import React, { memo, useCallback, useMemo } from 'react';
import { useStore } from '../../store/store';

export const Editor = memo(function Editor({ storyId }: { storyId: string }) {
  const activeSnippetId = useStore((state) =&gt; state.project.activeSnippetId);
  const snippet = useStore((state) =&gt; 
    activeSnippetId ? state.snippets[activeSnippetId] : null
  );
  
  // Memoize callbacks to prevent child re-renders
  const handleSave = useCallback((content: string) =&gt; {
    // Save logic
  }, []);
  
  const handleSnippetChange = useCallback((snippetId: string) =&gt; {
    // Change snippet logic
  }, []);
  
  // Memoize expensive computations
  const wordCount = useMemo(() =&gt; {
    return snippet ? countWords(snippet.body) : 0;
  }, [snippet?.body]);
  
  return (
    &lt;div className="editor-shell"&gt;
      {/* Editor content */}
    &lt;/div&gt;
  );
});</code></pre>
          <p><strong>C. Avoid Anonymous Callbacks in Deep Trees</strong>:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// ❌ DON'T DO THIS - creates new function on every render
&lt;GroupRow 
  group={group}
  onSelect={(id) =&gt; handleSelect(id)}  // Anonymous callback
  onClick={() =&gt; handleClick(group.id)} // Anonymous callback
/&gt;

// ✅ DO THIS - memoized callback
const handleSelect = useCallback((id: string) =&gt; {
  // Selection logic
}, []);

const handleGroupClick = useCallback((groupId: string) =&gt; {
  handleClick(groupId);
}, [handleClick]);

&lt;GroupRow 
  group={group}
  onSelect={handleSelect}  // Stable reference
  onClick={() =&gt; handleGroupClick(group.id)} // Still anonymous, but acceptable if group.id is stable
/&gt;

// ✅ EVEN BETTER - pass groupId directly
const handleGroupClick = useCallback((groupId: string) =&gt; {
  handleClick(groupId);
}, [handleClick]);

&lt;GroupRow 
  group={group}
  onSelect={handleSelect}
  onClick={handleGroupClick}  // Stable reference, groupId passed via closure
  groupId={group.id}  // Or pass as prop if needed
/&gt;</code></pre>
          <p><strong>When to Implement</strong>:</p>
          <ul>
            <li>Phase 4 (Editor - Tri-Pane Shell) - implement memoization from the start</li>
            <li>Review and optimize during Phase 7 (Accessibility, Performance &amp; Polish)</li>
          </ul>
          <p><strong>LOE</strong>: 3-4 hours (includes memoizing list rows, editor shell, and reviewing callback patterns)</p>

          <h4>3. Defer Non-Active Snippet Loads</h4>
          <p><strong>Problem</strong>: Loading all snippet content at once causes:</p>
          <ul>
            <li>Slow initial load</li>
            <li>High memory usage</li>
            <li>Unnecessary network requests</li>
            <li>Poor UX for large stories</li>
          </ul>
          <p><strong>Current Vanilla App Behavior</strong>:</p>
          <ul>
            <li>Loads active snippet immediately</li>
            <li>Background loads remaining snippets with throttling</li>
            <li>Uses <code>_contentLoaded</code> flag to track loaded state</li>
          </ul>
          <p><strong>Solution</strong>: Carry forward this pattern using React Query's prefetching and lazy loading capabilities.</p>
          <p><strong>Implementation</strong>:</p>
          <ul>
            <li>Use React Query's <code>useQuery</code> with <code>enabled: false</code> for non-active snippets</li>
            <li>Prefetch snippets in background using <code>prefetchQuery</code> (already planned in React Query section)</li>
            <li>Only load snippet content when:
              <ul>
                <li>Snippet becomes active (user clicks on it)</li>
                <li>Snippet is scrolled into view (for virtualized lists)</li>
                <li>Background prefetching (throttled, batched)</li>
              </ul>
            </li>
          </ul>
          <p><strong>Code Example</strong>:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/hooks/useSnippetContent.ts
import { useQuery, useQueryClient } from '@tanstack/react-query';
import { useStore } from '../store/store';
import { useDriveFile } from './useDriveQueries';

export function useSnippetContent(snippetId: string | null, loadImmediately = false) {
  const snippet = useStore((state) =&gt; 
    snippetId ? state.snippets[snippetId] : null
  );
  const activeSnippetId = useStore((state) =&gt; state.project.activeSnippetId);
  
  // Only load if:
  // 1. Load immediately (active snippet)
  // 2. Content already loaded (cached)
  // 3. Explicitly requested
  const shouldLoad = loadImmediately || 
                     snippet?._contentLoaded || 
                     snippetId === activeSnippetId;
  
  const { data, isLoading } = useDriveFile(
    shouldLoad &amp;&amp; snippet?.driveFileId ? snippet.driveFileId : null
  );
  
  return {
    content: data?.content || snippet?.body || '',
    isLoading: !snippet?._contentLoaded &amp;&amp; isLoading,
    isLoaded: !!snippet?._contentLoaded,
  };
}

// Background prefetching (throttled)
export function usePrefetchSnippets(snippetIds: string[], batchSize = 5, delay = 500) {
  const queryClient = useQueryClient();
  const snippets = useStore((state) =&gt; state.snippets);
  
  useEffect(() =&gt; {
    // Only prefetch snippets that haven't been loaded
    const unloadedSnippets = snippetIds.filter(
      (id) =&gt; !snippets[id]?._contentLoaded
    );
    
    // Prefetch in batches with delay
    unloadedSnippets.forEach((snippetId, index) =&gt; {
      const snippet = snippets[snippetId];
      if (!snippet?.driveFileId) return;
      
      setTimeout(() =&gt; {
        queryClient.prefetchQuery({
          queryKey: driveKeys.file(snippet.driveFileId),
          queryFn: () =&gt; readDriveFile({ fileId: snippet.driveFileId! }),
          staleTime: 5 * 60 * 1000,
        });
      }, Math.floor(index / batchSize) * delay);
    });
  }, [snippetIds, snippets, queryClient]);
}</code></pre>
          <p><strong>When to Implement</strong>:</p>
          <ul>
            <li>Phase 1 (Setup &amp; Infrastructure) - React Query setup already includes this</li>
            <li>Phase 6 (Lazy Loading, Conflict Resolution &amp; Exports) - integrate with editor component</li>
          </ul>
          <p><strong>LOE</strong>: Already included in React Query setup (Phase 1) and lazy loading (Phase 6)</p>

          <h4>Summary</h4>
          <table style="width: 100%; border-collapse: collapse; margin: var(--space-lg) 0;">
            <thead>
              <tr style="background: rgba(0, 0, 0, 0.2);">
                <th style="padding: var(--space-md); text-align: left; border: 1px solid rgba(255, 255, 255, 0.1);">Optimization</th>
                <th style="padding: var(--space-md); text-align: left; border: 1px solid rgba(255, 255, 255, 0.1);">Priority</th>
                <th style="padding: var(--space-md); text-align: left; border: 1px solid rgba(255, 255, 255, 0.1);">Phase</th>
                <th style="padding: var(--space-md); text-align: left; border: 1px solid rgba(255, 255, 255, 0.1);">LOE</th>
                <th style="padding: var(--space-md); text-align: left; border: 1px solid rgba(255, 255, 255, 0.1);">Status</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">Virtualize long lists</td>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">P2</td>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">Phase 4 or 5</td>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">4-6 hrs</td>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">Deferred until needed</td>
              </tr>
              <tr style="background: rgba(0, 0, 0, 0.1);">
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">Memoize list rows &amp; editor</td>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">P2</td>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">Phase 4</td>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">3-4 hrs</td>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">Implement from start</td>
              </tr>
              <tr>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">Defer non-active loads</td>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">P2</td>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">Phase 1 &amp; 6</td>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">Included</td>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">Already planned</td>
              </tr>
            </tbody>
          </table>
          <p><strong>Total Additional LOE</strong>: 7-10 hours (virtualization + memoization)</p>
          <p><strong>Benefits</strong>:</p>
          <ol>
            <li><strong>Scalability</strong>: App performs well with 100+ chapters and 500+ snippets</li>
            <li><strong>Better UX</strong>: Faster initial load, smoother scrolling</li>
            <li><strong>Lower Memory</strong>: Only render visible items, load content on demand</li>
            <li><strong>Future-Proof</strong>: Normalized state + virtualization enables even larger projects</li>
          </ol>

          <h3>Accessibility</h3>
          <ul>
            <li>All Material UI components are accessible by default</li>
            <li>Test with screen readers</li>
            <li>Ensure keyboard navigation works</li>
            <li>Check color contrast</li>
          </ul>
        </section>

        <section class="docs-section" id="questions">
          <h2 id="questions-to-resolve">Questions to Resolve</h2>
          <ul>
            <li>✅ TypeScript from start or add later? ✅ <strong>TypeScript from the start</strong></li>
            <li>State management choice (Zustand vs Context)? <strong>Recommendation: Zustand</strong></li>
            <li>✅ Should we keep old code as reference? ✅ <strong>Yes - parallel deployment at /react</strong></li>
            <li>Timeline constraints?</li>
            <li>Team size and availability?</li>
            <li>Testing requirements?</li>
            <li>When to migrate users from root to /react? (or keep both?)</li>
            <li>✅ How to handle shared Netlify Functions? ✅ <strong>Convert to TypeScript in Phase 2, works for both frontend versions</strong></li>
            <li>TypeScript strict mode level? (recommend: strict)</li>
            <li>ESLint + TypeScript ESLint configuration preferences?</li>
          </ul>
        </section>

        <section class="docs-section" id="resources">
          <h2 id="resources-heading">Resources</h2>
          
          <h3>Documentation</h3>
          <ul>
            <li><a href="https://tiptap.dev/" target="_blank" rel="noopener">TipTap Documentation</a></li>
            <li><a href="https://mui.com/" target="_blank" rel="noopener">Material UI Documentation</a></li>
            <li><a href="https://docs.dndkit.com/" target="_blank" rel="noopener">@dnd-kit Documentation</a></li>
            <li><a href="https://reactrouter.com/" target="_blank" rel="noopener">React Router Documentation</a></li>
            <li><a href="https://github.com/pmndrs/zustand" target="_blank" rel="noopener">Zustand Documentation</a></li>
          </ul>

          <h3>Migration Guides</h3>
          <ul>
            <li><a href="https://react.dev/learn/start-a-new-react-project" target="_blank" rel="noopener">React Migration Guide</a></li>
            <li><a href="https://vitejs.dev/guide/" target="_blank" rel="noopener">Vite Migration Guide</a></li>
          </ul>
        </section>

        <section class="docs-section" id="technical-details">
          <h2 id="additional-technical-details">Additional Technical Details</h2>
          
          <h3>State Structure</h3>
          <p>The current global <code>state</code> object will be converted to <strong>normalized</strong> TypeScript interfaces. All entities are keyed by id, and selectors derive views:</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/store/types.ts
export interface Group {
  id: string;
  title: string;
  description?: string;
  color: string;
  snippetIds: string[]; // References to snippet ids
  position?: number;
}

export interface Snippet {
  id: string;
  title: string;
  body: string;
  description?: string;
  groupId?: string; // Reference to group id
  kind?: 'person' | 'place' | 'thing';
  color?: string;
  words: number;
  chars: number;
  driveFileId?: string;
  updatedAt?: string;
  lastKnownDriveModifiedTime?: string;
  _contentLoaded?: boolean;
}

export interface Note {
  id: string;
  title: string;
  body: string;
  description?: string;
  kind: 'person' | 'place' | 'thing';
  color?: string;
  words: number;
  chars: number;
  driveFileId?: string;
  updatedAt?: string;
}

export interface Story {
  id: string;
  title: string;
  description?: string;
  genre?: string;
  driveFolderId: string;
  goalId?: string; // Reference to goal id
  createdAt: string;
  updatedAt: string;
}

export interface Goal {
  id: string;
  target: number | null;
  deadline: string | null;
  mode: 'elastic' | 'strict';
  writingDays: number[];
  daysOff: string[];
}

export interface Project {
  storyId: string | null;
  groupIds: string[]; // Ordered list of group ids
  snippetIds: string[]; // Ordered list of snippet ids
  activeSnippetId: string | null;
  activeRightTab: 'people' | 'places' | 'things';
  filters: {
    search: string;
  };
}

// Normalized state structure - all entities keyed by id
export interface AppState {
  // Normalized entities - keyed by id
  stories: Record&lt;string, Story&gt;;
  groups: Record&lt;string, Group&gt;;
  snippets: Record&lt;string, Snippet&gt;;
  notes: Record&lt;string, Note&gt;; // People, Places, Things
  goals: Record&lt;string, Goal&gt;;
  
  // Denormalized views - derived via selectors (see src/store/selectors.ts)
  project: Project;
  
  // Drive state
  drive: {
    storyFolderId: string | null;
  };
  
  // UI state
  collapsedGroups: Set&lt;string&gt;;
  editing: {
    savingState: 'idle' | 'saving' | 'saved';
    lastSavedAt: string | null;
  };
}</code></pre>
          <p><strong>Note</strong>: Views (e.g., left-rail lists) are derived using selectors in <code>src/store/selectors.ts</code>, not stored directly in state. This keeps renders cheap and enables virtualized lists later.</p>

          <p><strong>Example Selector Pattern</strong> (from <code>src/store/selectors.ts</code>):</p>
          <pre style="background: #111827; padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/store/selectors.ts
// Convention: "derive, don't duplicate" - views computed via selectors, not stored in state

import { useStore } from './store';
import { useMemo } from 'react';

// Get groups as array (for left-rail list) - MEMOIZED
export function useGroupsList() {
  const groupIds = useStore((state) => state.project.groupIds);
  const groups = useStore((state) => state.groups);
  
  return useMemo(() => {
    return groupIds
      .map((id) => groups[id])
      .filter(Boolean); // Filter out any missing groups
  }, [groupIds, groups]);
}</code></pre>

          <p>This pattern ensures:</p>
          <ul>
            <li><strong>Single source of truth</strong>: Groups exist once in <code>state.groups</code> Record</li>
            <li><strong>Cheap renders</strong>: Only re-renders when <code>groupIds</code> or <code>groups</code> change, not on unrelated updates</li>
            <li><strong>Memoization</strong>: Prevents unnecessary recalculations</li>
          </ul>

          <h3>Key Algorithms</h3>
          <ol>
            <li><strong>Word Counting</strong>: Custom function handling various text formats</li>
            <li><strong>Goal Calculation</strong>: Complex date/word math for daily targets</li>
            <li><strong>Conflict Detection</strong>: Compares local vs Drive modified times</li>
            <li><strong>Lazy Loading</strong>: Loads active snippet first, then batches remaining</li>
            <li><strong>Midnight Rollover</strong>: Detects day changes and recalculates goals</li>
          </ol>

          <h3>Performance Optimizations</h3>
          <ul>
            <li>Throttled updates during background loading</li>
            <li>Lazy content loading (only load when snippet is active)</li>
            <li>Batch background loading with delays</li>
            <li>Preserved order from saved data (no unnecessary sorting)</li>
            <li>Word count caching in snippet objects</li>
          </ul>

          <h3>Browser Compatibility</h3>
          <ul>
            <li><strong>Current</strong>: Works in modern browsers (Chrome, Firefox, Safari, Edge)</li>
            <li><strong>React</strong>: Same browser support expected</li>
            <li><strong>Mobile</strong>: Currently shows warning, not fully supported</li>
          </ul>
        </section>

        <section class="docs-section" id="changelog">
          <h2 id="changelog-heading">Changelog</h2>
          
          <ul>
            <li><strong>2025-01-XX</strong>: Added Netlify Functions TypeScript conversion
              <ul>
                <li><strong>Netlify Functions TypeScript Conversion</strong>: Added comprehensive section for converting all Netlify Functions to TypeScript</li>
                <li>Updated Executive Summary to include TypeScript for backend</li>
                <li>Updated "What Stays the Same" section to "What Gets Built as TypeScript Netlify Functions"</li>
                <li>Added TypeScript configuration for Netlify Functions (<code>netlify/functions/tsconfig.json</code>)</li>
                <li>Created shared types module (<code>netlify/functions/types.ts</code>) with all request/response types</li>
                <li>Added example conversion from JavaScript to TypeScript</li>
                <li>Updated Phase 2 to include Netlify Functions TypeScript conversion (8-12 hours LOE)</li>
                <li>Updated file structure to show all TypeScript function files</li>
                <li>Updated Phase 2 LOE from 12-18 hours to 20-28 hours (includes functions conversion)</li>
                <li>Updated risk mitigation for Google Drive API Integration to mention TypeScript conversion</li>
                <li>Resolved question about shared Netlify Functions (convert to TypeScript in Phase 2)</li>
                <li><strong>Total Additional LOE</strong>: 8-12 hours for Netlify Functions TypeScript conversion</li>
              </ul>
            </li>
          </ul>
          
          <hr style="margin: var(--space-xl) 0; border: none; border-top: 1px solid rgba(255, 255, 255, 0.1);">
          
          
          <ul>
            <li><strong>2025-01-XX</strong>: Added Phase 8: Test Automation (Week 5-6)
              <ul>
                <li>Comprehensive test automation strategy using Playwright (E2E), React Testing Library (component), and MSW (API mocking)</li>
                <li>Categorized testing workbook tests: 60-70% fully automatable, 20-25% partially automatable, 10-15% requires human testing</li>
                <li>Detailed implementation plan covering infrastructure setup, component tests, integration tests, E2E tests, visual regression tests, performance tests, test data management, and CI/CD integration</li>
                <li>Test coverage goals: 80%+ component tests, 90%+ integration tests, 70%+ E2E tests, 100% visual regression for classic UX anchors</li>
                <li>Mock strategy for Google Drive API and Google Sign-In using MSW</li>
                <li>Total LOE: 64-97 hours (8-12 days)</li>
                <li>Enables continuous regression testing and reduces manual testing burden by 60-70%</li>
                <li>Updated Risk Register Cadence to include Phase 8 checkpoint</li>
              </ul>
            </li>
            <li><strong>2025-01-XX</strong>: Added explicit success criteria for visual parity, concurrency safety, round-trip integrity, performance, accessibility, and bundle discipline
              <ul>
                <li><strong>Visual parity</strong>: Added side-by-side <code>/react</code> vs. root checks for goal meter, Today chip, footer counts, story cards, and modal spacing with "diff" screenshots as artifacts</li>
                <li><strong>Concurrency safety</strong>: Added requirement that conflicts are surfaced for Docs edits and second Yarny tabs (no silent last-writer-wins), verified in test checklist</li>
                <li><strong>Round-trip integrity</strong>: Added requirement that paragraphs and soft line breaks round-trip without collapse/duplication, rich-text paste is stripped, special characters preserved</li>
                <li><strong>Performance</strong>: Added requirement that budgets are met on medium corpus and virtualization kicks in automatically for large corpus</li>
                <li><strong>Accessibility</strong>: Added keyboard-only completion of core tasks (create/rename/reorder/export) and contrast checks on every chip color</li>
                <li><strong>Bundle discipline</strong>: Added requirement that starter-kit is removed and only TipTap extensions actually used are shipped</li>
                <li>Updated Phase 7 to include visual parity validation with diff screenshots, bundle size validation, and expanded accessibility checks</li>
                <li>Updated smoke tests to include concurrency safety verification (no silent last-writer-wins)</li>
                <li>Updated round-trip tests to explicitly verify no collapse/duplication of paragraph and soft line breaks</li>
                <li>Updated LOE estimate for Phase 7 (25-38 hours, up from 22-35 hours)</li>
              </ul>
            </li>
            <li><strong>2025-01-XX</strong>: Addressed feedback on TipTap dependencies, cross-tab conflicts, IME composition, and offline semantics
              <ul>
                <li><strong>TipTap Dependency Consistency</strong>: Added explicit note excluding <code>@tiptap/starter-kit</code> from dependencies to avoid accidental imports and extra bundle weight (individual extensions only)</li>
                <li><strong>Cross-Tab Yarny Conflicts</strong>: Enhanced cross-tab coordination hook with immediate warning/lock UI when snippet is opened in another tab; added comprehensive smoke tests for cross-tab scenarios (warning/lock, tab timeout, multiple tabs)</li>
                <li><strong>IME/Composition Edge Cases</strong>: Added explicit test coverage for long-press accents (é, è, ê, ë, ñ, etc.), emoji composition, and emoji picker to test corpus and smoke tests; expanded IME composition tests beyond CJK</li>
                <li><strong>Offline/Spotty-Network Semantics</strong>: Added new section defining UX for network states (queued saves, read-only mode, offline banners, "Saved at..." indicator behavior) tied to React Query's retry/backoff and cache staleness; added <code>useNetworkStatus</code> hook, <code>OfflineBanner</code> component, and comprehensive smoke tests for offline scenarios</li>
                <li>Updated Phase 6 to include offline/spotty-network semantics implementation</li>
                <li>Updated LOE estimates to reflect offline semantics work (Phase 6: 16-23 hours)</li>
              </ul>
            </li>
            <li><strong>2025-01-XX</strong>: Addressed feedback on performance budgets, decision point triggers, and selector examples
              <ul>
                <li><strong>Performance Budgets</strong>: Added time-to-first-edit and time-to-switch-snippet budgets (≤300 ms hot path, ≤1.5 s cold path) to large project smoke tests to catch performance regressions early</li>
                <li><strong>Decision Point Triggers</strong>: Added one-liners to each decision point stating what would trigger a change (e.g., if TipTap plain text extraction diverges from Docs, consider Slate)</li>
                <li><strong>Selector Examples</strong>: Added concrete selector example near store definition in file structure and State Structure sections to model "derive, don't duplicate" convention for discoverability</li>
              </ul>
            </li>
            <li><strong>2025-01-XX</strong>: Addressed feedback on Drive quota, virtualization, focus rings, and export chunking
              <ul>
                <li><strong>Drive Quota & Request Storms</strong>: Added visibility-based gating to React Query (only refetch/prefetch when tab is visible), exponential backoff with jitter for rate limit (429) responses, explicit "Drive rate limit" test with behavior validation</li>
                <li><strong>Virtualization Threshold</strong>: Made virtualization thresholds (50+ chapters, 200+ snippets) configurable via localStorage settings, allowing tuning without redeployment</li>
                <li><strong>MUI Focus Rings</strong>: Added accessible focus ring customization to theme (visible against dark cards and pale chips), added "accessible focus rings" to success criteria</li>
                <li><strong>Export Request Size</strong>: Added "very large chapter" (50+ snippets) to large test corpus, added chunked write logic for exports exceeding batchUpdate body limits, added chunked export tests to smoke test checklist</li>
                <li>Updated React Query setup to include visibility gating and rate limit handling</li>
                <li>Updated export functionality section to include chunking logic and progress indication</li>
                <li>Updated test corpus section to include very large chapter for export validation</li>
                <li>Updated Phase 6 to include chunked export implementation and testing</li>
              </ul>
            </li>
            <li><strong>2025-01-XX</strong>: Added new gotchas and edge cases
              <ul>
                <li><strong>Google Docs Newline Semantics</strong>: Added normalization for mixed <code>\n</code>/<code>\r\n</code> line endings, NBSPs, and trailing spaces in text extraction utilities</li>
                <li><strong>IME Composition Handling</strong>: Added <code>compositionstart</code>/<code>compositionend</code> event handling in TipTap editor to prevent premature word count updates and save debouncing during CJK/emoji input</li>
                <li><strong>Cross-Tab Conflict Detection</strong>: Added <code>useCrossTabCoordination</code> hook using BroadcastChannel API (with localStorage fallback) to detect and prevent simultaneous editing of same snippet in multiple Yarny tabs</li>
                <li><strong>Enhanced Test Corpus</strong>: Added special test snippets for format normalization (mixed line endings, NBSPs, trailing spaces) and IME composition (CJK text, emoji)</li>
                <li><strong>Expanded Smoke Tests</strong>: Added format/line break tests, IME composition tests, and cross-tab conflict tests to smoke test checklist</li>
                <li>Updated text extraction utilities to match Google Docs normalization behavior</li>
                <li>Updated TipTap editor to handle IME composition events</li>
                <li>Updated LOE estimates to include new edge case handling (12-18 hours for editor truth section)</li>
              </ul>
            </li>
            <li><strong>2025-01-XX</strong>: Initial plan created
              <ul>
                <li>Added implementation details section</li>
                <li>Added modal list (8 total)</li>
                <li>Added color system details</li>
                <li>Added export types breakdown</li>
                <li>Added goal system features</li>
                <li>Added code statistics</li>
                <li>Added technical details section</li>
                <li><strong>Added parallel deployment strategy</strong>: React app at <code>/react</code> path, existing app at root</li>
                <li>Added Netlify configuration for <code>/react</code> path deployment</li>
                <li>Added Vite and React Router base path configuration</li>
                <li>Added testing strategy for parallel deployment</li>
                <li><strong>Updated to require TypeScript</strong>: Changed from optional to required</li>
                <li>Added TypeScript configuration examples</li>
                <li>Updated file structure to show all <code>.tsx</code> and <code>.ts</code> files</li>
                <li>Added TypeScript type definitions for state structure</li>
                <li>Updated LOE estimates to include TypeScript setup time</li>
                <li>Updated decision points to make TypeScript mandatory</li>
                <li><strong>Added API Contract Formalization section (P1 Priority)</strong>:
                  <ul>
                    <li>Defined centralized API contract module with Zod schemas</li>
                    <li>Created typed API client wrapper with runtime validation</li>
                    <li>Documented all endpoints to be covered (auth, Drive, status)</li>
                    <li>Added example implementation code</li>
                    <li>Updated Phase 1 to include API contract setup</li>
                    <li>Added <code>zod</code> to dependencies</li>
                    <li>Updated file structure to show API contract files</li>
                    <li>Added API contract formalization to success criteria</li>
                  </ul>
                </li>
                <li><strong>Added Fetch/Caching Layer with TanStack Query section (P1 Priority)</strong>:
                  <ul>
                    <li>Adopted TanStack Query (React Query) as the fetch/caching layer for ALL Drive I/O</li>
                    <li>Replaced ad-hoc useEffect hooks with React Query hooks</li>
                    <li>Documented all Drive operations that must use React Query (read, write, list, delete, rename, check comments, create folder, etc.)</li>
                    <li>Added React Query setup and configuration</li>
                    <li>Created <code>useDriveQueries.ts</code> hook structure with examples</li>
                    <li>Updated lazy loading to use React Query prefetching and <code>useQueries</code></li>
                    <li>Added <code>@tanstack/react-query</code> to dependencies</li>
                    <li>Updated Phase 1 to include React Query setup</li>
                    <li>Updated Phase 6 to use React Query for lazy loading</li>
                    <li>Added React Query to success criteria</li>
                    <li><strong>Key change</strong>: ALL Drive I/O operations now use React Query, not just background loads</li>
                  </ul>
                </li>
                <li><strong>Added Editor Truth and Google Docs Round-Tripping section (P1 Priority)</strong>:
                  <ul>
                    <li>Constrained TipTap to plain text only (no rich formatting) to match Yarny's minimalist model</li>
                    <li>Established editor as authoritative while Yarny is open</li>
                    <li>Added reconciliation on window focus to detect external changes</li>
                    <li>Brought conflict detection forward to Phase 1/2 (early in migration)</li>
                    <li>Created text extraction utilities matching Google Docs API format</li>
                    <li>Updated TipTap configuration to use only Document, Paragraph, Text, HardBreak, History extensions</li>
                    <li>Added conflict detection and reconciliation hooks</li>
                    <li>Updated Phase 1 to include TipTap plain text configuration and early conflict detection</li>
                    <li>Updated Phase 2 to include reconciliation on window focus</li>
                    <li>Updated Phase 4 to integrate TipTap with conflict detection and test round-tripping</li>
                    <li>Added TipTap extension dependencies (individual extensions only - starter-kit explicitly excluded to prevent accidental import drift)</li>
                    <li>Added editor truth and round-tripping to success criteria</li>
                  </ul>
                </li>
                <li><strong>Added State Normalization section (P1 Priority)</strong>:
                  <ul>
                    <li>Normalize all entities (stories, groups, snippets, notes, tags, goals) keyed by id in Zustand store</li>
                    <li>Use selectors to derive views (e.g., left-rail lists) instead of storing nested objects</li>
                    <li>Keeps renders cheap and enables virtualized lists later</li>
                    <li>Updated state structure to show normalized form with entity references</li>
                    <li>Created selectors examples for derived views</li>
                    <li>Updated Phase 1 to include state normalization setup</li>
                    <li>Updated file structure to include <code>selectors.ts</code></li>
                    <li>Updated State Management Architecture section to explicitly call out normalization</li>
                  </ul>
                </li>
                <li><strong>Added Performance Guardrails for Big Projects section (P2 Priority)</strong>:
                  <ul>
                    <li>Virtualize long lists in the left rail using <code>@tanstack/react-virtual</code> when stories grow large (50+ chapters, 200+ snippets)</li>
                    <li>Memoize expensive list rows and editor shell using <code>React.memo</code>, <code>useMemo</code>, and <code>useCallback</code></li>
                    <li>Avoid passing anonymous callbacks into deep trees to prevent unnecessary re-renders</li>
                    <li>Defer non-active snippet loads using React Query's prefetching (carries forward vanilla app's lazy loading pattern)</li>
                    <li>Added code examples for virtualization, memoization, and lazy loading</li>
                    <li>Added <code>@tanstack/react-virtual</code> to dependencies</li>
                    <li>Updated Performance Considerations section with detailed implementation strategies</li>
                    <li>Total additional LOE: 7-10 hours (virtualization + memoization)</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>Document all major decisions and changes here</li>
          </ul>
        </section>

        <section class="docs-section" id="contact">
          <h2 id="contact-support">Contact & Support</h2>
          <p>For questions or updates to this plan, please document changes here and update the changelog.</p>
        </section>
      </div>
    </main>

    <footer class="shared-footer">
      <p>&copy; 2025 Yarny. Your personal writing tool.</p>
      <nav class="shared-footer-nav">
        <a href="/stories.html" id="footerStoriesLink" style="display: none;">My Stories</a>
        <a href="/docs.html">Docs</a>
        <a href="/migration-plan">Migration Plan</a>
        <a href="/migration-plan/testing-workbook">Testing Workbook</a>
        <a href="/" id="footerLoginLink">Back to Login</a>
      </nav>
    </footer>
  </div>
  <script>
    // Check if user is logged in
    function isTokenExpired(token) {
      if (!token) return true;
      
      try {
        const decoded = atob(token);
        const parts = decoded.split(':');
        
        if (parts.length !== 2) return true;
        
        const timestamp = parseInt(parts[1], 10);
        if (isNaN(timestamp)) return true;
        
        // Check if token is within 48 hours
        const SESSION_DURATION_MS = 48 * 60 * 60 * 1000;
        const now = Date.now();
        const age = now - timestamp;
        
        return age > SESSION_DURATION_MS;
      } catch (error) {
        console.error('Error checking token expiration:', error);
        return true;
      }
    }

    function checkAuthStatus() {
      const authToken = localStorage.getItem('yarny_auth');
      const isLoggedIn = authToken && !isTokenExpired(authToken);
      
      const storiesLink = document.getElementById('storiesNavLink');
      const loginLink = document.getElementById('loginNavLink');
      const footerStoriesLink = document.getElementById('footerStoriesLink');
      const footerLoginLink = document.getElementById('footerLoginLink');
      
      if (isLoggedIn) {
        if (storiesLink) storiesLink.style.display = 'inline-block';
        if (loginLink) loginLink.style.display = 'none';
        if (footerStoriesLink) footerStoriesLink.style.display = 'inline-block';
        if (footerLoginLink) footerLoginLink.style.display = 'none';
      } else {
        if (storiesLink) storiesLink.style.display = 'none';
        if (loginLink) loginLink.style.display = 'inline-block';
        if (footerStoriesLink) footerStoriesLink.style.display = 'none';
        if (footerLoginLink) footerLoginLink.style.display = 'inline-block';
      }
    }

    // Highlight active navigation item based on scroll position
    document.addEventListener('DOMContentLoaded', function() {
      // Check auth status on page load
      checkAuthStatus();
      
      const navLinks = document.querySelectorAll('.sidebar-nav .nav-link');
      const sections = document.querySelectorAll('.docs-section[id]');
      const sidebar = document.querySelector('.docs-sidebar');

      function updateActiveNav() {
        let current = '';
        const scrollPos = window.scrollY + 100; // Offset for nav buttons

        sections.forEach(section => {
          const sectionTop = section.offsetTop;
          const sectionHeight = section.offsetHeight;
          if (scrollPos >= sectionTop && scrollPos < sectionTop + sectionHeight) {
            current = section.getAttribute('id');
          }
        });

        navLinks.forEach(link => {
          link.classList.remove('active');
          if (link.getAttribute('href') === '#' + current) {
            link.classList.add('active');
          }
        });
      }

      // Mobile menu toggle
      const menuButton = document.querySelector('.mobile-menu-toggle') || document.createElement('button');
      const backdrop = document.querySelector('.sidebar-backdrop');
      
      if (!menuButton.parentNode) {
        menuButton.className = 'mobile-menu-toggle';
        menuButton.innerHTML = '☰';
        menuButton.setAttribute('aria-label', 'Toggle menu');
        document.body.appendChild(menuButton);
      }

      function toggleSidebar() {
        sidebar.classList.toggle('open');
        if (backdrop) {
          backdrop.classList.toggle('active');
        }
      }

      menuButton.addEventListener('click', function(e) {
        e.stopPropagation();
        toggleSidebar();
      });

      // Close sidebar when clicking backdrop
      if (backdrop) {
        backdrop.addEventListener('click', function() {
          sidebar.classList.remove('open');
          backdrop.classList.remove('active');
        });
      }

      // Close sidebar when clicking outside on mobile
      document.addEventListener('click', function(e) {
        if (window.innerWidth <= 900 && sidebar && sidebar.classList.contains('open')) {
          if (!sidebar.contains(e.target) && !e.target.classList.contains('mobile-menu-toggle')) {
            sidebar.classList.remove('open');
            if (backdrop) {
              backdrop.classList.remove('active');
            }
          }
        }
      });

      // Close sidebar when clicking a nav link on mobile
      navLinks.forEach(link => {
        link.addEventListener('click', function() {
          if (window.innerWidth <= 900) {
            sidebar.classList.remove('open');
            if (backdrop) {
              backdrop.classList.remove('active');
            }
          }
        });
      });

      window.addEventListener('scroll', updateActiveNav);
      window.addEventListener('resize', function() {
        // Only auto-close sidebar if we're above mobile breakpoint
        if (window.innerWidth > 900) {
          sidebar.classList.remove('open');
          if (backdrop) {
            backdrop.classList.remove('active');
          }
        }
      });

      updateActiveNav(); // Initial call

      // Collapsible navigation groups
      const navGroupHeaders = document.querySelectorAll('.nav-group-header');
      
      navGroupHeaders.forEach(header => {
        // Load saved state from localStorage
        const groupId = header.getAttribute('data-group');
        const savedState = localStorage.getItem(`nav-group-${groupId}`);
        if (savedState === 'collapsed') {
          header.setAttribute('aria-expanded', 'false');
        }

        header.addEventListener('click', function(e) {
          e.preventDefault();
          e.stopPropagation();
          
          const isExpanded = header.getAttribute('aria-expanded') === 'true';
          const newState = isExpanded ? 'false' : 'true';
          
          header.setAttribute('aria-expanded', newState);
          
          // Save state to localStorage
          if (newState === 'false') {
            localStorage.setItem(`nav-group-${groupId}`, 'collapsed');
          } else {
            localStorage.removeItem(`nav-group-${groupId}`);
          }
        });
      });
    });
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Yarny - React + TypeScript Migration Plan</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="/global.css">
  <link rel="stylesheet" href="/docs.css">
  <link rel="stylesheet" href="/footer.css">
  <!-- Privacy-friendly analytics by Plausible -->
  <script async src="https://plausible.io/js/pa-hQCYhFM-nW3tbKDHDR8Xc.js"></script>
  <script>
    window.plausible=window.plausible||function(){(plausible.q=plausible.q||[]).push(arguments)},plausible.init=plausible.init||function(i){plausible.o=i||{}};
    plausible.init()
  </script>
</head>
<body>
  <div class="docs-container">
    <header class="docs-header">
      <div class="docs-header-content">
        <div>
          <h1>Yarny</h1>
          <p class="docs-subtitle">React + TypeScript Migration Plan</p>
        </div>
        <nav class="docs-nav">
          <a href="/stories.html" id="storiesNavLink" class="btn-secondary" style="display: none;">My Stories</a>
          <a href="/docs.html" class="btn-secondary">Docs</a>
          <a href="/" id="loginNavLink" class="btn-secondary">Back to Login</a>
        </nav>
      </div>
    </header>

    <main class="docs-main">
      <div class="sidebar-backdrop"></div>
      <aside class="docs-sidebar">
        <div class="sidebar-header">
          <div class="status-indicator">
            <span class="status-dot status-green"></span>
            <span class="status-text">Planning Phase</span>
          </div>
        </div>
        <nav class="sidebar-nav">
          <ul class="sidebar-nav-list">
            <li><a href="#executive-summary" class="nav-link">Executive Summary</a></li>
            <li><a href="#typescript-react" class="nav-link">Understanding TypeScript + React</a></li>
            <li><a href="#current-analysis" class="nav-link">Current Project Analysis</a></li>
            <li><a href="#preserve-ux-anchors" class="nav-link">Preserve Classic UX Anchors (P1/P2)</a></li>
            <li><a href="#migration-strategy" class="nav-link">Migration Strategy</a></li>
            <li><a href="#library-replacements" class="nav-link">Library Replacements</a></li>
            <li><a href="#mui-theming-strategy" class="nav-link">MUI Theming Strategy (P2)</a></li>
            <li><a href="#effort-estimation" class="nav-link">Effort Estimation</a></li>
            <li><a href="#implementation-details" class="nav-link">Implementation Details</a></li>
            <li><a href="#state-normalization" class="nav-link">State Normalization (P1)</a></li>
            <li><a href="#custom-implementation" class="nav-link">What Needs Custom Implementation</a></li>
            <li><a href="#fetch-caching" class="nav-link">Fetch/Caching Layer (React Query)</a></li>
            <li><a href="#api-contract" class="nav-link">API Contract Formalization</a></li>
            <li><a href="#editor-truth" class="nav-link">Editor Truth & Round-Tripping</a></li>
            <li><a href="#migration-phases" class="nav-link">Migration Phases</a></li>
            <li><a href="#risk-factors" class="nav-link">Risk Factors</a></li>
            <li><a href="#benefits" class="nav-link">Benefits of Migration</a></li>
            <li><a href="#netlify-config" class="nav-link">Netlify Configuration</a></li>
            <li><a href="#file-structure" class="nav-link">File Structure</a></li>
            <li><a href="#decision-points" class="nav-link">Decision Points</a></li>
            <li><a href="#success-criteria" class="nav-link">Success Criteria</a></li>
            <li><a href="#notes-considerations" class="nav-link">Notes & Considerations</a></li>
            <li><a href="#test-strategy-drive-docs" class="nav-link">Test Strategy: Drive/Docs (P2)</a></li>
            <li><a href="#questions" class="nav-link">Questions to Resolve</a></li>
            <li><a href="#resources" class="nav-link">Resources</a></li>
            <li><a href="#technical-details" class="nav-link">Technical Details</a></li>
            <li><a href="#changelog" class="nav-link">Changelog</a></li>
            <li><a href="#next-steps" class="nav-link">Next Steps</a></li>
          </ul>
        </nav>
      </aside>

      <div class="docs-content">
        <section class="docs-section" id="executive-summary" style="background: #ECFDF5; border-left: 4px solid #10B981; padding: var(--space-lg); margin-bottom: var(--space-2xl); border-radius: var(--radius-lg);">
          <h2 id="executive-summary-heading" style="margin-top: 0; color: #059669; display: flex; align-items: center; gap: 8px;">
            <i class="material-icons" style="font-size: 24px;">lightbulb</i>
            Executive Summary
          </h2>
          <p style="margin-bottom: 0; color: #047857;">This document outlines the plan and effort estimation for converting the Yarny writing application from vanilla JavaScript to <strong style="color: #047857 !important;">React with TypeScript</strong>, while maintaining the existing Netlify Functions backend.</p>
          <p style="margin-top: var(--space-md); margin-bottom: 0; color: #047857;"><strong style="color: #047857 !important;">Note:</strong> This migration will use <strong style="color: #047857 !important;">TypeScript throughout</strong>. All components, hooks, utilities, and state management will be written in TypeScript.</p>
        </section>

        <section class="docs-section" id="typescript-react">
          <h2 id="understanding-typescript-react">Understanding TypeScript + React</h2>
          
          <h3>They Work Together, Not Separately</h3>
          <p><strong>Important</strong>: TypeScript and React are not alternatives—they work together. Everything in this migration will be built using <strong>React components written in TypeScript</strong>.</p>
          <ul>
            <li><strong>TypeScript</strong> = The programming language (typed JavaScript)</li>
            <li><strong>React</strong> = The UI framework/library for building components</li>
            <li><strong>Result</strong> = React components written in TypeScript (<code>.tsx</code> files)</li>
          </ul>

          <h3>What Gets Built as React Components (TypeScript)</h3>
          <p>All UI components will be React components written in TypeScript:</p>
          <ul>
            <li><strong>Pages</strong>: <code>LoginPage.tsx</code>, <code>StoriesPage.tsx</code>, <code>EditorPage.tsx</code></li>
            <li><strong>Editor Components</strong>: <code>Editor.tsx</code>, <code>StorySidebar.tsx</code>, <code>NotesSidebar.tsx</code>, <code>TipTapEditor.tsx</code></li>
            <li><strong>UI Components</strong>: <code>Modal.tsx</code>, <code>ColorPicker.tsx</code>, <code>ContextMenu.tsx</code>, etc.</li>
            <li><strong>Shared Components</strong>: <code>Header.tsx</code>, <code>Footer.tsx</code></li>
          </ul>

          <h3>What Gets Built as React Hooks (TypeScript)</h3>
          <p>Business logic will be React hooks written in TypeScript:</p>
          <ul>
            <li><strong><code>useDrive.ts</code></strong> - Google Drive API wrapper with TypeScript types</li>
            <li><strong><code>useAuth.ts</code></strong> - Authentication logic with TypeScript types</li>
            <li><strong><code>useStory.ts</code></strong> - Story management with TypeScript types</li>
            <li><strong><code>useGoal.ts</code></strong> - Goal calculation algorithms with TypeScript types</li>
            <li><strong><code>useMobileDetection.ts</code></strong> - Mobile device detection</li>
          </ul>

          <h3>What Gets Built as TypeScript Utilities</h3>
          <p>Pure functions and utilities written in TypeScript (no React):</p>
          <ul>
            <li><strong><code>wordCount.ts</code></strong> - Word counting logic</li>
            <li><strong><code>export.ts</code></strong> - Export functionality</li>
            <li><strong><code>goalCalculation.ts</code></strong> - Goal calculation algorithms</li>
            <li><strong><code>api/drive.ts</code></strong> - Drive API client with TypeScript types</li>
          </ul>

          <h3>What Gets Built as TypeScript State Management</h3>
          <p>State management using Zustand with TypeScript:</p>
          <ul>
            <li><strong><code>store/store.ts</code></strong> - Zustand store with TypeScript interfaces</li>
            <li><strong><code>store/types.ts</code></strong> - TypeScript type definitions for all state structures</li>
          </ul>

          <h3>What Stays the Same (No Changes)</h3>
          <ul>
            <li><strong>Netlify Functions</strong> (backend) - Remain in JavaScript (no changes needed)</li>
            <li><strong>Backend API endpoints</strong> - No changes required</li>
            <li><strong>Google Drive API integration</strong> - Backend already works, just needs React wrapper</li>
          </ul>

          <h3>Example: React Component in TypeScript</h3>
          <pre style="background: rgba(0, 0, 0, 0.3); padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// File: src/components/editor/Editor.tsx
// This is a React component written in TypeScript

import React from 'react';
import { useStore } from '../../store/store';
import { Group } from '../../store/types';

interface EditorProps {
  storyId: string;
}

export function Editor({ storyId }: EditorProps): JSX.Element {
  const groups = useStore((state) => state.groups);
  const activeSnippetId = useStore((state) => state.project.activeSnippetId);
  
  // Component logic here...
  
  return (
    &lt;div className="editor"&gt;
      {/* JSX here */}
    &lt;/div&gt;
  );
}</code></pre>

          <h3>Example: React Hook in TypeScript</h3>
          <pre style="background: rgba(0, 0, 0, 0.3); padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// File: src/hooks/useDrive.ts
// This is a React hook written in TypeScript

import { useState, useEffect } from 'react';
import { DriveFile } from '../api/drive';

interface UseDriveResult {
  files: DriveFile[];
  loading: boolean;
  error: Error | null;
}

export function useDrive(folderId: string): UseDriveResult {
  const [files, setFiles] = useState&lt;DriveFile[]&gt;([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState&lt;Error | null&gt;(null);
  
  // Hook logic here...
  
  return { files, loading, error };
}</code></pre>

          <h3>Summary</h3>
          <ul>
            <li>✅ <strong>Everything</strong> = React components written in TypeScript</li>
            <li>✅ <strong>UI Components</strong> = React (<code>.tsx</code> files)</li>
            <li>✅ <strong>Business Logic</strong> = React hooks (<code>.ts</code> files)</li>
            <li>✅ <strong>Utilities</strong> = TypeScript functions (<code>.ts</code> files)</li>
            <li>✅ <strong>State</strong> = Zustand with TypeScript types</li>
            <li>❌ <strong>Backend</strong> = Stays in JavaScript (no changes)</li>
          </ul>
          <p><strong>The plan states</strong>: "This migration will use <strong>TypeScript</strong> throughout. All components, hooks, utilities, and state management will be written in TypeScript."</p>
        </section>

        <section class="docs-section" id="current-analysis">
          <h2 id="current-project-analysis">Current Project Analysis</h2>
          
          <h3>Codebase Statistics</h3>
          <ul>
            <li><strong>Total JavaScript:</strong> ~8,782 lines across 4 main files</li>
            <li><strong>Largest File:</strong> <code>editor.js</code> - 6,069 lines</li>
            <li><strong>Other Files:</strong>
              <ul>
                <li><code>stories.js</code> - ~1,837 lines</li>
                <li><code>app.js</code> - ~503 lines</li>
                <li><code>drive.js</code> - ~269 lines</li>
              </ul>
            </li>
            <li><strong>Architecture:</strong> Vanilla JavaScript with direct DOM manipulation</li>
            <li><strong>Backend:</strong> Already using Netlify Functions (no changes needed)</li>
          </ul>

          <h3>Current Features</h3>
          <ul>
            <li>✅ Plain text editor (contentEditable, minimalist formatting)</li>
            <li>✅ Story/Chapter/Snippet management</li>
            <li>✅ Google Drive integration</li>
            <li>✅ Google Sign-In authentication</li>
            <li>✅ Drag & drop reordering</li>
            <li>✅ Color coding for chapters/snippets (12 accent colors)</li>
            <li>✅ Word count tracking & goals (elastic/strict modes)</li>
            <li>✅ Search functionality</li>
            <li>✅ Export functionality (chapters, outline, people, places, things)</li>
            <li>✅ Notes system (People/Places/Things)</li>
            <li>✅ Multiple modals and UI components</li>
            <li>✅ Context menus</li>
            <li>✅ Real-time save status</li>
            <li>✅ Mobile device detection & warning</li>
            <li>✅ Error logging to localStorage</li>
            <li>✅ Lazy loading of snippet content</li>
            <li>✅ Background loading optimization</li>
            <li>✅ Conflict resolution (Yarny vs Google Docs)</li>
            <li>✅ Comments/tracked changes detection</li>
          </ul>
        </section>

        <section class="docs-section" id="preserve-ux-anchors" style="background: #FEF3C7; border-left: 4px solid #F59E0B; padding: var(--space-lg); margin-bottom: var(--space-2xl); border-radius: var(--radius-lg);">
          <h2 id="preserve-ux-anchors-heading" style="margin-top: 0; color: #92400E; display: flex; align-items: center; gap: 8px;">
            <i class="material-icons" style="font-size: 24px;">palette</i>
            Preserve Classic UX Anchors (P1/P2 Priority)
          </h2>
          
          <h3>Overview</h3>
          <p><strong>Why</strong>: These UI elements are recognizable bits from the 2011–2015 screenshots that define Yarny's identity. Preserving them intact avoids the "new app uncanny valley" and maintains user familiarity during migration.</p>
          <p><strong>What</strong>: These specific UI elements must be preserved exactly as they appear in the current app, with identical visual design, behavior, and placement.</p>

          <h3>Elements to Preserve</h3>

          <h4>1. Left-Rail Goal Meter</h4>
          <ul>
            <li><strong>Location</strong>: Left sidebar, below story title and settings button</li>
            <li><strong>Features</strong>:
              <ul>
                <li>Displays total word count vs. goal (e.g., "0 / 3,000")</li>
                <li>Progress bar showing completion percentage</li>
                <li>Clickable to open goal panel</li>
                <li>Updates in real-time as user writes</li>
              </ul>
            </li>
            <li><strong>Preservation Requirements</strong>:
              <ul>
                <li>✅ Exact same visual design (font size, colors, spacing, border radius)</li>
                <li>✅ Same placement in left rail header</li>
                <li>✅ Same click behavior (opens goal panel)</li>
                <li>✅ Same real-time update behavior</li>
                <li>✅ Same progress bar styling and animation</li>
              </ul>
            </li>
            <li><strong>React Implementation</strong>: Create <code>GoalMeter.tsx</code> component in <code>src/components/editor/</code></li>
          </ul>

          <h4>2. "Today • N" Chip</h4>
          <ul>
            <li><strong>Location</strong>: Left sidebar, below goal meter</li>
            <li><strong>Features</strong>:
              <ul>
                <li>Displays "Today" label with daily word count (e.g., "Today • 250")</li>
                <li>Progress bar showing daily progress toward daily target</li>
                <li>Color-coded progress bar (green when ahead, red when behind in strict mode)</li>
                <li>Clickable to open goal panel</li>
                <li>Shows "—" when no goal is set</li>
              </ul>
            </li>
            <li><strong>Preservation Requirements</strong>:
              <ul>
                <li>✅ Exact same visual design (chip style, padding, border, colors)</li>
                <li>✅ Same placement below goal meter</li>
                <li>✅ Same "Today • N" format with number formatting (e.g., "1,234" with commas)</li>
                <li>✅ Same progress bar styling (2px height, subtle background)</li>
                <li>✅ Same color logic (green/red in strict mode, primary color otherwise)</li>
                <li>✅ Same click behavior (opens goal panel)</li>
                <li>✅ Always visible (even when no goal set, shows "—")</li>
              </ul>
            </li>
            <li><strong>React Implementation</strong>: Create <code>TodayChip.tsx</code> component in <code>src/components/editor/</code></li>
          </ul>

          <h4>3. Footer Word/Character Counts</h4>
          <ul>
            <li><strong>Location</strong>: Footer bar, center section</li>
            <li><strong>Features</strong>:
              <ul>
                <li>Displays "Words: N" and "Characters: N" with separator ("—")</li>
                <li>Updates in real-time as user types</li>
                <li>Shows counts for active snippet only</li>
                <li>Centered in footer bar</li>
                <li>Small font size, secondary text color</li>
              </ul>
            </li>
            <li><strong>Preservation Requirements</strong>:
              <ul>
                <li>✅ Exact same visual design (font size, color, spacing, separator)</li>
                <li>✅ Same placement in footer center</li>
                <li>✅ Same format ("Words: N — Characters: N")</li>
                <li>✅ Same real-time update behavior</li>
                <li>✅ Same calculation logic (active snippet only)</li>
              </ul>
            </li>
            <li><strong>React Implementation</strong>: Create <code>Footer.tsx</code> component in <code>src/components/shared/</code></li>
          </ul>

          <h4>4. Version Slider Affordance</h4>
          <ul>
            <li><strong>Location</strong>: Footer bar (or editor area, depending on implementation)</li>
            <li><strong>Note</strong>: This may refer to a feature from the original 2011-2015 Yarny app that isn't in the current codebase</li>
            <li><strong>Investigation Needed</strong>:
              <ul>
                <li>Check reference documentation for original version slider implementation</li>
                <li>Verify if this feature exists in current codebase under different name</li>
                <li>Document findings and implementation plan</li>
              </ul>
            </li>
            <li><strong>Preservation Requirements</strong>:
              <ul>
                <li>✅ If present in current app: Preserve exact design and behavior</li>
                <li>✅ If not present but referenced in original app: Document for future implementation</li>
                <li>✅ Maintain same visual affordance and interaction pattern</li>
              </ul>
            </li>
          </ul>

          <h3>Implementation Strategy</h3>
          <ul>
            <li><strong>Phase 1</strong>: Document and audit current implementation</li>
            <li><strong>Phase 4</strong>: Implement Footer component (word/character counts) with exact styling</li>
            <li><strong>Phase 5</strong>: Implement Goals UI components (Goal Meter, Today Chip) with exact styling</li>
            <li><strong>Phase 7</strong>: Visual parity testing - side-by-side comparison with current app</li>
          </ul>

          <h3>Success Criteria</h3>
          <ul>
            <li>✅ Goal meter looks and behaves identically to current app</li>
            <li>✅ Today chip looks and behaves identically to current app</li>
            <li>✅ Footer word/character counts look and behave identically to current app</li>
            <li>✅ Version slider (if applicable) looks and behaves identically to current app</li>
            <li>✅ Side-by-side visual comparison shows pixel-perfect match</li>
            <li>✅ User testing confirms no "uncanny valley" effect</li>
          </ul>

          <p style="margin-top: var(--space-md); margin-bottom: 0; color: #92400E;"><strong style="color: #92400E !important;">LOE</strong>: 9-14 hours (documentation, implementation, and visual parity testing)</p>
        </section>

        <section class="docs-section" id="migration-strategy">
          <h2 id="migration-strategy-heading">Migration Strategy</h2>
          
          <h3>Approach: Incremental Migration</h3>
          <ol>
            <li>Set up React infrastructure alongside existing code</li>
            <li>Migrate page by page (index → stories → editor)</li>
            <li>Use third-party libraries to replace custom implementations</li>
            <li>Maintain feature parity throughout migration</li>
          </ol>

          <h3>Deployment Strategy: Parallel Development</h3>
          <ul>
            <li><strong>New React App:</strong> Deploy to <code>yarny.lindsaybrunner.com/react</code></li>
            <li><strong>Existing App:</strong> Remains live at <code>yarny.lindsaybrunner.com</code> (root)</li>
            <li><strong>Benefits:</strong>
              <ul>
                <li>Keep existing app fully functional during development</li>
                <li>Enable side-by-side testing and comparison</li>
                <li>Allow gradual user migration</li>
                <li>Easy rollback if needed</li>
                <li>Test with real users before full migration</li>
              </ul>
            </li>
          </ul>
        </section>

        <section class="docs-section" id="library-replacements">
          <h2 id="third-party-library-replacements">Third-Party Library Replacements</h2>
          
          <p>This section details exactly which parts of the current codebase can be replaced by proven React libraries, significantly reducing development time and maintenance burden.</p>

          <h3>Replaceable Components & Estimated Savings</h3>
          <table>
            <thead>
              <tr>
                <th>Component</th>
                <th>Current Lines</th>
                <th>Library</th>
                <th>Savings</th>
                <th>What It Replaces</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Text Editor (Plain Text)</td>
                <td>~1,500-2,000</td>
                <td>TipTap (Plain Text Only)</td>
                <td>~1,500-2,000 lines</td>
                <td>All contentEditable handling, text extraction, plain text formatting logic</td>
              </tr>
              <tr>
                <td>Modals (8 total)</td>
                <td>~500-800</td>
                <td>Material UI Dialog</td>
                <td>~500-800 lines</td>
                <td>Story Info, Export, Description Edit, Goal Panel, Rename, Delete, Conflict Resolution, Comments Warning</td>
              </tr>
              <tr>
                <td>Drag & Drop</td>
                <td>~300-400</td>
                <td>@dnd-kit</td>
                <td>~300-400 lines</td>
                <td>All drag event handlers, drop zones, reordering logic for chapters/snippets</td>
              </tr>
              <tr>
                <td>Color Picker</td>
                <td>~150</td>
                <td>react-colorful</td>
                <td>~150 lines</td>
                <td>Custom color picker UI, color selection logic, positioning</td>
              </tr>
              <tr>
                <td>Tabs</td>
                <td>~100</td>
                <td>Material UI Tabs</td>
                <td>~100 lines</td>
                <td>People/Places/Things tab switching, tab state management</td>
              </tr>
              <tr>
                <td>Context Menu</td>
                <td>~150</td>
                <td>Material UI Menu</td>
                <td>~150 lines</td>
                <td>Right-click menu for rename/delete, menu positioning</td>
              </tr>
              <tr>
                <td>Dropdown Menus</td>
                <td>~100</td>
                <td>Material UI Menu</td>
                <td>~100 lines</td>
                <td>Export dropdown menu, positioning, open/close logic</td>
              </tr>
              <tr>
                <td>Forms</td>
                <td>~200</td>
                <td>React Hook Form</td>
                <td>~200 lines</td>
                <td>Form validation, form state, error handling for all modals</td>
              </tr>
              <tr>
                <td>Date Picker</td>
                <td>~50</td>
                <td>Material UI DatePicker</td>
                <td>~50 lines</td>
                <td>Goal deadline date input, date validation</td>
              </tr>
              <tr>
                <td>Tooltips</td>
                <td>~50</td>
                <td>Material UI Tooltip</td>
                <td>~50 lines</td>
                <td>All title attributes and custom tooltip implementations</td>
              </tr>
              <tr>
                <td>Toast Notifications</td>
                <td>~100</td>
                <td>react-hot-toast</td>
                <td>~100 lines</td>
                <td>Save status updates, error notifications, success messages</td>
              </tr>
              <tr>
                <td>Collapsible/Accordion</td>
                <td>~100</td>
                <td>Material UI Accordion</td>
                <td>~100 lines</td>
                <td>Chapter collapse/expand functionality</td>
              </tr>
              <tr>
                <td><strong>TOTAL</strong></td>
                <td><strong>~3,300-4,200</strong></td>
                <td></td>
                <td><strong>~3,300-4,200 lines</strong></td>
                <td><strong>40-50% of codebase</strong></td>
              </tr>
            </tbody>
          </table>

          <h3>Detailed Component Mapping</h3>
          
          <h4>1. Rich Text Editor → TipTap (Constrained to Plain Text)</h4>
          <p><strong>Current Implementation:</strong></p>
          <ul>
            <li><code>editor.js</code>: <code>getEditorTextContent()</code>, <code>setEditorTextContent()</code>, contentEditable event handlers</li>
            <li>Complex text extraction logic handling <code>&lt;br&gt;</code>, <code>&lt;div&gt;</code>, <code>&lt;p&gt;</code> tags</li>
            <li>Line break normalization</li>
            <li>Cursor position management</li>
            <li>Content synchronization with state</li>
            <li><strong>Content Format</strong>: Plain text with line breaks (<code>\n</code>), stored as <code>snippet.body</code> string</li>
            <li><strong>Storage</strong>: Google Docs API (for snippets) or plain text (for notes)</li>
            <li><strong>Conflict Detection</strong>: Compares plain text content and timestamps</li>
          </ul>
          <p><strong>Replacement:</strong></p>
          <ul>
            <li>TipTap configured for <strong>minimalist plain text only</strong> (no rich formatting)</li>
            <li><strong>Format Constraint</strong>: Plain paragraphs and soft line breaks only (matches current model)</li>
            <li><strong>Editor as Truth</strong>: Editor is authoritative while Yarny is open</li>
            <li><strong>Reconciliation</strong>: Check for external changes on window focus, reconcile if needed</li>
            <li><strong>Conflict Detection</strong>: Infrastructure in Phase 1, hooks and UI in Phase 6</li>
            <li>Type-safe editor API</li>
            <li>Handles cursor management and content synchronization</li>
          </ul>
          <p><strong>Critical Constraints:</strong></p>
          <ul>
            <li><strong>NO rich formatting</strong> (bold, italic, colors, etc.) - Google Docs API doesn't handle arbitrary HTML well</li>
            <li><strong>Plain text only</strong> - matches Yarny's minimalist model</li>
            <li><strong>Paragraph breaks</strong> - use TipTap's paragraph support for <code>\n\n</code> (paragraph breaks)</li>
            <li><strong>Soft line breaks</strong> - use TipTap's line break support for <code>\n</code> (single line breaks)</li>
            <li><strong>Text extraction</strong> - must extract plain text that matches Google Docs API output format</li>
          </ul>
          <p><strong>Code Locations:</strong></p>
          <ul>
            <li><code>editor.js</code> lines ~590-670 (text content extraction)</li>
            <li><code>editor.js</code> lines ~669-738 (editor rendering and content management)</li>
            <li><code>editor.js</code> lines ~1160-1383 (conflict detection and resolution)</li>
            <li>All contentEditable event listeners throughout <code>editor.js</code></li>
          </ul>

          <h4>2. Modals → Material UI Dialog</h4>
          <p><strong>Current Implementation:</strong></p>
          <ul>
            <li>8 separate modal implementations with custom show/hide logic</li>
            <li>Modal overlay management</li>
            <li>Focus trapping</li>
            <li>Escape key handling</li>
            <li>Click-outside-to-close logic</li>
          </ul>
          <p><strong>Replacement:</strong></p>
          <ul>
            <li>Material UI Dialog component handles all modal behavior</li>
            <li>Accessible by default (ARIA, focus management)</li>
            <li>Keyboard navigation built-in</li>
            <li>Can style to match existing design with theme customization</li>
          </ul>
          <p><strong>Code Locations:</strong></p>
          <ul>
            <li><code>editor.html</code> lines 200-571 (all modal HTML structures)</li>
            <li><code>editor.js</code> modal open/close functions throughout</li>
          </ul>

          <h4>3. Drag & Drop → @dnd-kit</h4>
          <p><strong>Current Implementation:</strong></p>
          <ul>
            <li>Native HTML5 drag events (<code>dragstart</code>, <code>dragover</code>, <code>drop</code>, <code>dragend</code>)</li>
            <li>Custom drop zone detection</li>
            <li>Visual feedback during drag</li>
            <li>Reordering logic for groups and snippets</li>
          </ul>
          <p><strong>Replacement:</strong></p>
          <ul>
            <li>@dnd-kit provides sortable list functionality</li>
            <li>Touch device support</li>
            <li>Better performance than native drag events</li>
            <li>Built-in visual feedback</li>
          </ul>
          <p><strong>Code Locations:</strong></p>
          <ul>
            <li><code>editor.js</code> lines ~300, 368-376 (group drag handlers)</li>
            <li><code>editor.js</code> lines ~410, 526-534 (snippet drag handlers)</li>
            <li><code>editor.js</code> lines ~766, 905-910 (notes drag handlers)</li>
            <li>All <code>handleGroupDragStart</code>, <code>handleSnippetDragStart</code>, <code>handleDragOver</code>, etc. functions</li>
          </ul>

          <h4>4. Color Picker → react-colorful</h4>
          <p><strong>Current Implementation:</strong></p>
          <ul>
            <li>Custom color picker UI with 12 color grid</li>
            <li>Positioning logic relative to color chip</li>
            <li>Click-outside-to-close handling</li>
            <li>Color selection and application</li>
          </ul>
          <p><strong>Replacement:</strong></p>
          <ul>
            <li>react-colorful provides pre-built color picker</li>
            <li>Can be styled to match 12-color palette</li>
            <li>Simpler integration</li>
          </ul>
          <p><strong>Code Locations:</strong></p>
          <ul>
            <li><code>editor.js</code> lines 2682-2784 (color picker functions)</li>
            <li><code>editor.html</code> lines 437-442 (color picker HTML)</li>
          </ul>

          <h4>5. Tabs → Material UI Tabs</h4>
          <p><strong>Current Implementation:</strong></p>
          <ul>
            <li>Custom tab switching for People/Places/Things</li>
            <li>Tab state management</li>
            <li>Active tab styling</li>
          </ul>
          <p><strong>Replacement:</strong></p>
          <ul>
            <li>Material UI Tabs handles all tab functionality</li>
            <li>Accessible keyboard navigation</li>
            <li>Built-in active state management</li>
            <li>Can be styled to match existing design</li>
          </ul>
          <p><strong>Code Locations:</strong></p>
          <ul>
            <li><code>editor.html</code> lines 115-139 (tabs HTML)</li>
            <li><code>editor.js</code> tab switching logic</li>
          </ul>

          <h4>6. Context Menu → Material UI Menu</h4>
          <p><strong>Current Implementation:</strong></p>
          <ul>
            <li>Right-click event handling</li>
            <li>Menu positioning</li>
            <li>Rename/Delete menu items</li>
          </ul>
          <p><strong>Replacement:</strong></p>
          <ul>
            <li>Material UI Menu provides full context menu functionality</li>
            <li>Accessible, keyboard navigable</li>
            <li>Proper positioning with anchor positioning</li>
            <li>Can be styled to match existing design</li>
          </ul>
          <p><strong>Code Locations:</strong></p>
          <ul>
            <li><code>editor.html</code> lines 444-448 (context menu HTML)</li>
            <li><code>editor.js</code> context menu show/hide logic</li>
          </ul>

          <h4>7. Forms → React Hook Form</h4>
          <p><strong>Current Implementation:</strong></p>
          <ul>
            <li>Manual form validation</li>
            <li>Form state management</li>
            <li>Error message display</li>
            <li>Used in: Story Info, New Story, Goal Panel, Rename, Description Edit modals</li>
          </ul>
          <p><strong>Replacement:</strong></p>
          <ul>
            <li>React Hook Form handles validation, state, and errors</li>
            <li>TypeScript integration</li>
            <li>Better performance (uncontrolled components)</li>
          </ul>
          <p><strong>Code Locations:</strong></p>
          <ul>
            <li>All modal forms in <code>editor.html</code> and <code>stories.html</code></li>
            <li>Form validation logic in <code>editor.js</code> and <code>stories.js</code></li>
          </ul>

          <h4>8. Date Picker → Material UI DatePicker</h4>
          <p><strong>Current Implementation:</strong></p>
          <ul>
            <li>Native HTML5 date input</li>
            <li>Date validation</li>
            <li>Used in Goal Panel for deadline selection</li>
          </ul>
          <p><strong>Replacement:</strong></p>
          <ul>
            <li>Material UI DatePicker provides better UX</li>
            <li>Date range selection</li>
            <li>Integrated with Material UI theme</li>
            <li>Accessible and keyboard navigable</li>
          </ul>
          <p><strong>Code Locations:</strong></p>
          <ul>
            <li><code>editor.html</code> lines 365-372 (goal deadline input)</li>
            <li><code>stories.html</code> deadline input in new story modal</li>
          </ul>

          <h4>9. Toast Notifications → react-hot-toast</h4>
          <p><strong>Current Implementation:</strong></p>
          <ul>
            <li>Custom save status updates ("Saving...", "Saved at X:XX")</li>
            <li>Manual status element updates</li>
            <li>Status styling and transitions</li>
          </ul>
          <p><strong>Replacement:</strong></p>
          <ul>
            <li>react-hot-toast provides toast notifications</li>
            <li>Auto-dismiss, positioning, animations</li>
            <li>Success/error/info variants</li>
          </ul>
          <p><strong>Code Locations:</strong></p>
          <ul>
            <li><code>editor.js</code> lines 1057-1077 (<code>updateSaveStatus</code> function)</li>
            <li><code>editor.html</code> line 108 (save status element)</li>
          </ul>

          <h4>10. Collapsible/Accordion → Material UI Accordion</h4>
          <p><strong>Current Implementation:</strong></p>
          <ul>
            <li>Custom collapse/expand for chapters</li>
            <li>Collapse state management (localStorage)</li>
            <li>Icon toggling (arrow up/down)</li>
          </ul>
          <p><strong>Replacement:</strong></p>
          <ul>
            <li>Material UI Accordion handles collapse functionality</li>
            <li>Accessible, keyboard navigable</li>
            <li>Built-in state management</li>
            <li>Can be styled to match existing design</li>
          </ul>
          <p><strong>Code Locations:</strong></p>
          <ul>
            <li><code>editor.js</code> lines 217-262 (collapse state management)</li>
            <li><code>editor.js</code> lines 303-316 (collapse button rendering)</li>
            <li><code>editor.js</code> lines 254-262 (<code>toggleGroupCollapse</code> function)</li>
          </ul>

          <h3>Benefits of Using Third-Party Libraries</h3>
          <ol>
            <li><strong>Massive Code Reduction</strong>: ~3,300-4,200 lines of custom code replaced by battle-tested libraries</li>
            <li><strong>Accessibility Built-In</strong>: All Material UI components are fully accessible (ARIA, keyboard nav)</li>
            <li><strong>Consistent Design System</strong>: Material UI provides a cohesive design system that can be customized</li>
            <li><strong>Type Safety</strong>: All recommended libraries have excellent TypeScript support</li>
            <li><strong>Maintenance</strong>: Libraries are maintained by teams, reducing our maintenance burden</li>
            <li><strong>Performance</strong>: Optimized libraries often perform better than custom implementations</li>
            <li><strong>Documentation</strong>: Well-documented libraries with examples and community support</li>
            <li><strong>Bug Fixes</strong>: Libraries fix edge cases we haven't encountered yet</li>
            <li><strong>Future-Proof</strong>: Libraries evolve with React ecosystem</li>
          </ol>

          <h3>Recommended Library Stack</h3>
          <p><strong>Note:</strong> This migration will use <strong>TypeScript</strong> throughout. All components, hooks, utilities, and state management will be written in TypeScript.</p>
          <pre style="background: rgba(0, 0, 0, 0.3); padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>{
  "dependencies": {
    "react": "^18.x",
    "react-dom": "^18.x",
    "react-router-dom": "^6.x",
    "@tiptap/react": "^2.x",
    "@tiptap/starter-kit": "^2.x",
    "@tiptap/extension-document": "^2.x",
    "@tiptap/extension-paragraph": "^2.x",
    "@tiptap/extension-text": "^2.x",
    "@tiptap/extension-hard-break": "^2.x",
    "@tiptap/extension-history": "^2.x",
    "@tanstack/react-query": "^5.x",
    "@tanstack/react-virtual": "^3.x",
    "@mui/material": "^5.x",
    "@mui/icons-material": "^5.x",
    "@mui/x-date-pickers": "^6.x",
    "@emotion/react": "^11.x",
    "@emotion/styled": "^11.x",
    "@dnd-kit/core": "^6.x",
    "@dnd-kit/sortable": "^8.x",
    "@dnd-kit/utilities": "^3.x",
    "react-colorful": "^5.x",
    "react-hook-form": "^7.x",
    "react-hot-toast": "^2.x",
    "axios": "^1.x",
    "zustand": "^4.x",
    "zod": "^3.x"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.x",
    "vite": "^5.x",
    "typescript": "^5.x",
    "@types/react": "^18.x",
    "@types/react-dom": "^18.x",
    "@types/node": "^20.x"
  }
}</code></pre>

          <h3>Library Selection Rationale</h3>
          
          <h4>Text Editor: <strong>TipTap</strong> (Recommended - Plain Text Only)</h4>
          <ul>
            <li>✅ Modern, extensible, built for React</li>
            <li>✅ <strong>Excellent TypeScript support</strong> - Full type definitions included</li>
            <li>✅ Active community and maintenance</li>
            <li>✅ Handles contentEditable complexity</li>
            <li>✅ Type-safe editor extensions and commands</li>
            <li>✅ Replaces ~1,500-2,000 lines of custom contentEditable code</li>
            <li>✅ <strong>Configured for plain text only</strong> - matches Yarny's minimalist model</li>
            <li>✅ Handles text extraction matching Google Docs API format</li>
            <li>✅ Supports paragraph breaks and soft line breaks (no rich formatting)</li>
            <li><strong>Note</strong>: Will be configured with only Document, Paragraph, Text, HardBreak, History extensions (no Bold, Italic, etc.)</li>
            <li><strong>Alternative</strong>: Slate.js (more complex but powerful, also has TypeScript support)</li>
          </ul>

          <h4>UI Components: <strong>Material UI</strong> (Recommended)</h4>
          <ul>
            <li>✅ Comprehensive component library with consistent design system</li>
            <li>✅ Full keyboard navigation built-in</li>
            <li>✅ ARIA attributes automatically handled</li>
            <li>✅ Highly customizable with theme system - can match existing design</li>
            <li>✅ <strong>Full TypeScript support</strong> - All components are typed</li>
            <li>✅ Replaces ~1,000+ lines of modal, menu, tab, tooltip code</li>
            <li>✅ Provides: Dialog (modals), Menu (dropdowns/context menus), Tabs, Tooltip, Accordion, DatePicker, and many more</li>
            <li>✅ Includes Material Icons library for consistent iconography</li>
            <li>✅ Active development and large community</li>
            <li><strong>Alternative</strong>: Radix UI (unstyled, more minimal) or Headless UI (similar, different API)</li>
          </ul>

          <h4>Drag & Drop: <strong>@dnd-kit</strong> (Recommended)</h4>
          <ul>
            <li>✅ Modern, performant library</li>
            <li>✅ Better than react-beautiful-dnd (which is unmaintained)</li>
            <li>✅ Supports sortable lists out of the box</li>
            <li>✅ Touch device support for tablets</li>
            <li>✅ Replaces ~300-400 lines of native drag event handling</li>
            <li>✅ Handles all the drag/drop logic for chapters and snippets</li>
            <li>✅ Better visual feedback and drop zone detection than native events</li>
          </ul>
        </section>

        <section class="docs-section" id="mui-theming-strategy">
          <h2 id="mui-theming-strategy-heading">MUI Theming Strategy: Keep Brand Look, Use MUI for Plumbing (P2)</h2>
          
          <h3>Overview</h3>
          <p><strong>Principle</strong>: Keep the brand look; let MUI do the plumbing.</p>
          <p><strong>Why</strong>: MUI is ergonomic but visually opinionated. You've already defined a 12-color system and gradient aesthetic; keep that as the design source of truth while using MUI for accessibility and behaviors. The plan already codifies the palette and usage guidelines—excellent.</p>

          <h3>Design Philosophy</h3>
          <ol>
            <li><strong>Brand as Source of Truth</strong>: The existing 12-color categorical accent system and gradient aesthetic are the design foundation. MUI components will be customized to match this palette, not the other way around.</li>
            <li><strong>MUI for Behaviors</strong>: Use MUI components for:
              <ul>
                <li>Accessibility (ARIA attributes, keyboard navigation, focus management)</li>
                <li>Interaction behaviors (modal open/close, menu positioning, form validation)</li>
                <li>Component plumbing (Dialog, Menu, Tabs, Tooltip, Accordion, DatePicker)</li>
                <li>Built-in accessibility features that would be time-consuming to implement from scratch</li>
              </ul>
            </li>
            <li><strong>Customization Over Defaults</strong>: MUI's theme system will be extensively customized to:
              <ul>
                <li>Map the 12-color accent palette to MUI's color system</li>
                <li>Preserve the gradient aesthetic where applicable</li>
                <li>Maintain the existing visual hierarchy and spacing</li>
                <li>Keep the minimalist, clean design language</li>
              </ul>
            </li>
          </ol>

          <h3>Implementation Strategy</h3>
          
          <h4>1. MUI Theme Customization</h4>
          <p>Create <code>src/theme/theme.ts</code> that maps the brand palette to MUI's theme:</p>
          <pre><code>import { createTheme } from '@mui/material/styles';

// Import the 12-color palette from the Color System section
const brandColors = {
  primary: '#10B981', // Emerald (matches existing primary)
  primaryLight: '#D1FAE5',
  primaryDark: '#059669',
  // ... all 12 accent colors with their variants
};

export const theme = createTheme({
  palette: {
    primary: {
      main: brandColors.primary,
      light: brandColors.primaryLight,
      dark: brandColors.primaryDark,
    },
    // Map accent colors to MUI's secondary, error, warning, info, success
    // Or create custom palette extensions
  },
  // Customize component defaults to match brand
  components: {
    MuiDialog: {
      styleOverrides: {
        paper: {
          // Match existing modal styling
        },
      },
    },
    MuiButton: {
      styleOverrides: {
        root: {
          // Match existing button styling
        },
      },
    },
    // ... customize all MUI components used
  },
});</code></pre>

          <h4>2. Component-Level Styling</h4>
          <p>For components that need exact brand matching:</p>
          <ul>
            <li>Use MUI's <code>sx</code> prop for one-off customizations</li>
            <li>Use <code>styled()</code> API for reusable branded components</li>
            <li>Keep MUI's accessibility and behavior, override only visual styling</li>
          </ul>
          <pre><code>import { Dialog, styled } from '@mui/material';

// Keep MUI Dialog behavior, customize appearance
const BrandedDialog = styled(Dialog)(({ theme }) => ({
  '& .MuiDialog-paper': {
    // Match existing modal design exactly
    borderRadius: '8px',
    // Use brand colors
    border: `1px solid ${theme.palette.primary.main}`,
  },
}));</code></pre>

          <h4>3. Color System Integration</h4>
          <p>The existing 12-color categorical accent system (defined in the Color System section) will be:</p>
          <ul>
            <li><strong>Preserved</strong>: All color variants (base, soft, dark, on-solid) remain as defined</li>
            <li><strong>Mapped</strong>: Integrated into MUI's theme system for consistent usage</li>
            <li><strong>Extended</strong>: Used in MUI components via theme overrides and custom props</li>
          </ul>

          <h4>4. Usage Guidelines</h4>
          <ul>
            <li><strong>Use MUI components</strong> for: Modals (Dialog), Menus, Tabs, Tooltips, Accordions, DatePickers, Forms</li>
            <li><strong>Customize appearance</strong> to match: Existing color palette, spacing, typography, border radius, shadows</li>
            <li><strong>Keep MUI behaviors</strong>: Accessibility, keyboard navigation, focus management, ARIA attributes</li>
            <li><strong>Preserve brand identity</strong>: Visual design remains consistent with existing app</li>
          </ul>

          <h3>Benefits</h3>
          <ol>
            <li><strong>Accessibility Out of the Box</strong>: MUI components provide full keyboard navigation, ARIA attributes, and focus management without custom implementation</li>
            <li><strong>Reduced Code</strong>: ~1,000+ lines of modal, menu, tab code replaced by MUI</li>
            <li><strong>Brand Consistency</strong>: Theme customization ensures visual consistency with existing design</li>
            <li><strong>Maintainability</strong>: MUI's theming system makes it easy to update brand colors globally</li>
            <li><strong>Best of Both Worlds</strong>: Brand look + MUI's proven accessibility and behaviors</li>
          </ol>

          <h3>Implementation Timeline</h3>
          <p>This should be implemented in <strong>Phase 1</strong> (Setup & Infrastructure):</p>
          <ul>
            <li>Create <code>src/theme/theme.ts</code> with brand color mappings</li>
            <li>Customize MUI component defaults to match existing design</li>
            <li>Set up theme provider in app root</li>
            <li>Test theme customization with sample components</li>
          </ul>
          <p><strong>LOE</strong>: 4-6 hours (adds time but ensures brand consistency and proper MUI integration)</p>
        </section>

        <section class="docs-section" id="effort-estimation">
          <h2 id="effort-estimation-heading">Effort Estimation</h2>
          
          <h3>Original LOE (Without Libraries)</h3>
          <table>
            <thead>
              <tr>
                <th>Task</th>
                <th>Hours</th>
                <th>Complexity</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Editor Component (6,069 lines)</td>
                <td>40-60</td>
                <td>Very High</td>
              </tr>
              <tr>
                <td>State Management Migration</td>
                <td>20-30</td>
                <td>High</td>
              </tr>
              <tr>
                <td>ContentEditable Integration</td>
                <td>15-25</td>
                <td>High</td>
              </tr>
              <tr>
                <td>Stories Page</td>
                <td>12-18</td>
                <td>Medium</td>
              </tr>
              <tr>
                <td>Authentication Flow</td>
                <td>8-12</td>
                <td>Medium</td>
              </tr>
              <tr>
                <td>Google Drive Integration</td>
                <td>8-12</td>
                <td>Medium</td>
              </tr>
              <tr>
                <td>CSS/Styling Updates</td>
                <td>10-15</td>
                <td>Medium</td>
              </tr>
              <tr>
                <td>Docs Page</td>
                <td>4-6</td>
                <td>Low</td>
              </tr>
              <tr>
                <td>Export Functionality</td>
                <td>6-10</td>
                <td>Medium</td>
              </tr>
              <tr>
                <td>Goal Tracking & UI Components</td>
                <td>8-12</td>
                <td>Medium</td>
              </tr>
              <tr>
                <td>React Setup & Configuration</td>
                <td>8-12</td>
                <td>Medium</td>
              </tr>
              <tr>
                <td>Testing & Bug Fixes</td>
                <td>20-30</td>
                <td>High</td>
              </tr>
              <tr>
                <td><strong>TOTAL</strong></td>
                <td><strong>159-220</strong></td>
                <td></td>
              </tr>
            </tbody>
          </table>
          <p><strong>Timeline:</strong> 4-11 weeks (depending on hours/week)</p>

          <h3>Revised LOE (With Third-Party Libraries)</h3>
          <table>
            <thead>
              <tr>
                <th>Task</th>
                <th>Hours</th>
                <th>Savings</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Text Editor (TipTap - Plain Text Only)</td>
                <td>15-25</td>
                <td>25-35 hrs</td>
              </tr>
              <tr>
                <td>UI Components (Material UI)</td>
                <td>10-15</td>
                <td>20-25 hrs</td>
              </tr>
              <tr>
                <td>Drag & Drop (@dnd-kit)</td>
                <td>4-6</td>
                <td>11-14 hrs</td>
              </tr>
              <tr>
                <td>Forms & Inputs (React Hook Form)</td>
                <td>3-4</td>
                <td>5-8 hrs</td>
              </tr>
              <tr>
                <td>State Management</td>
                <td>20-30</td>
                <td>0 hrs</td>
              </tr>
              <tr>
                <td>Stories Page</td>
                <td>8-12</td>
                <td>4-6 hrs</td>
              </tr>
              <tr>
                <td>Authentication Flow</td>
                <td>6-8</td>
                <td>2-4 hrs</td>
              </tr>
              <tr>
                <td>Google Drive Integration</td>
                <td>6-8</td>
                <td>2-4 hrs</td>
              </tr>
              <tr>
                <td>CSS/Styling Updates</td>
                <td>8-10</td>
                <td>2-5 hrs</td>
              </tr>
              <tr>
                <td>Docs Page</td>
                <td>2-3</td>
                <td>2-3 hrs</td>
              </tr>
              <tr>
                <td>Export Functionality</td>
                <td>4-6</td>
                <td>2-4 hrs</td>
              </tr>
              <tr>
                <td>Goal Tracking</td>
                <td>6-8</td>
                <td>2-4 hrs</td>
              </tr>
              <tr>
                <td>React Setup & Configuration</td>
                <td>8-12</td>
                <td>0 hrs (includes TS setup)</td>
              </tr>
              <tr>
                <td>TypeScript Type Definitions</td>
                <td>8-12</td>
                <td>-8-12 hrs (adds time but saves debugging)</td>
              </tr>
              <tr>
                <td>Testing & Bug Fixes</td>
                <td>12-20</td>
                <td>8 hrs (TypeScript catches errors earlier)</td>
              </tr>
              <tr>
                <td><strong>TOTAL</strong></td>
                <td><strong>105-160</strong></td>
                <td><strong>66-87 hrs saved</strong></td>
              </tr>
            </tbody>
          </table>

          <h3>Timeline Estimates</h3>
          <table>
            <thead>
              <tr>
                <th>Scenario</th>
                <th>Hours</th>
                <th>Weeks (40hr)</th>
                <th>Weeks (20hr)</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Optimistic</strong></td>
                <td>67</td>
                <td>1.7</td>
                <td>3.3</td>
              </tr>
              <tr>
                <td><strong>Realistic</strong></td>
                <td>86</td>
                <td>2.1</td>
                <td>4.3</td>
              </tr>
              <tr>
                <td><strong>Pessimistic</strong></td>
                <td>105</td>
                <td>2.6</td>
                <td>5.3</td>
              </tr>
            </tbody>
          </table>
        </section>

        <section class="docs-section" id="implementation-details">
          <h2 id="implementation-details-heading">Implementation Details</h2>
          
          <h3>Modals (8 Total)</h3>
          <ol>
            <li><strong>Story Info Modal</strong> - Edit story title, genre, description, word goal</li>
            <li><strong>Export Filename Modal</strong> - User-provided filename for exports</li>
            <li><strong>Description Edit Modal</strong> - Edit chapter/snippet descriptions</li>
            <li><strong>Goal Panel Modal</strong> - Set writing goals (target, deadline, days, mode)</li>
            <li><strong>Rename Modal</strong> - Rename chapters/snippets</li>
            <li><strong>Delete Confirmation Modal</strong> - Confirm deletion</li>
            <li><strong>Snippet Conflict Resolution Modal</strong> - Resolve Yarny vs Google Docs conflicts</li>
            <li><strong>Comments Warning Modal</strong> - Warn about comments/tracked changes in Google Docs</li>
          </ol>

          <h3>Color System</h3>
          
          <h4>Primaries (Brand)</h4>
          <ul>
            <li><strong>Primary</strong>: <code>#10B981</code></li>
            <li><strong>Primary-light</strong>: <code>#D1FAE5</code></li>
            <li><strong>Primary-dark</strong>: <code>#059669</code></li>
          </ul>

          <h4>12 Categorical Accents (Chapter/Snippet Colors)</h4>
          <p>Each accent color has four variants: base (solid), soft (pale), dark, and on-solid (text color for contrast).</p>
          
          <ol>
            <li><strong>Red</strong>
              <ul>
                <li>Base: <code>#EF4444</code></li>
                <li>Soft: <code>#FEE2E2</code></li>
                <li>Dark: <code>#991B1B</code></li>
                <li>On-solid: <code>#FFFFFF</code></li>
              </ul>
            </li>
            <li><strong>Orange</strong>
              <ul>
                <li>Base: <code>#F97316</code></li>
                <li>Soft: <code>#FFEDD5</code></li>
                <li>Dark: <code>#9A3412</code></li>
                <li>On-solid: <code>#FFFFFF</code></li>
              </ul>
            </li>
            <li><strong>Amber</strong>
              <ul>
                <li>Base: <code>#F59E0B</code></li>
                <li>Soft: <code>#FEF3C7</code></li>
                <li>Dark: <code>#92400E</code></li>
                <li>On-solid: <code>#1F2937</code></li>
              </ul>
            </li>
            <li><strong>Yellow</strong>
              <ul>
                <li>Base: <code>#EAB308</code></li>
                <li>Soft: <code>#FEF9C3</code></li>
                <li>Dark: <code>#854D0E</code></li>
                <li>On-solid: <code>#1F2937</code></li>
              </ul>
            </li>
            <li><strong>Lime</strong>
              <ul>
                <li>Base: <code>#84CC16</code></li>
                <li>Soft: <code>#ECFCCB</code></li>
                <li>Dark: <code>#365314</code></li>
                <li>On-solid: <code>#0B1220</code></li>
              </ul>
            </li>
            <li><strong>Emerald</strong>
              <ul>
                <li>Base: <code>#10B981</code></li>
                <li>Soft: <code>#D1FAE5</code></li>
                <li>Dark: <code>#065F46</code></li>
                <li>On-solid: <code>#FFFFFF</code></li>
              </ul>
            </li>
            <li><strong>Teal</strong>
              <ul>
                <li>Base: <code>#14B8A6</code></li>
                <li>Soft: <code>#CCFBF1</code></li>
                <li>Dark: <code>#115E59</code></li>
                <li>On-solid: <code>#FFFFFF</code></li>
              </ul>
            </li>
            <li><strong>Cyan</strong>
              <ul>
                <li>Base: <code>#06B6D4</code></li>
                <li>Soft: <code>#CFFAFE</code></li>
                <li>Dark: <code>#155E75</code></li>
                <li>On-solid: <code>#FFFFFF</code></li>
              </ul>
            </li>
            <li><strong>Blue</strong>
              <ul>
                <li>Base: <code>#3B82F6</code></li>
                <li>Soft: <code>#DBEAFE</code></li>
                <li>Dark: <code>#1E40AF</code></li>
                <li>On-solid: <code>#FFFFFF</code></li>
              </ul>
            </li>
            <li><strong>Indigo</strong>
              <ul>
                <li>Base: <code>#6366F1</code></li>
                <li>Soft: <code>#E0E7FF</code></li>
                <li>Dark: <code>#3730A3</code></li>
                <li>On-solid: <code>#FFFFFF</code></li>
              </ul>
            </li>
            <li><strong>Violet</strong>
              <ul>
                <li>Base: <code>#8B5CF6</code></li>
                <li>Soft: <code>#EDE9FE</code></li>
                <li>Dark: <code>#5B21B6</code></li>
                <li>On-solid: <code>#FFFFFF</code></li>
              </ul>
            </li>
            <li><strong>Fuchsia</strong>
              <ul>
                <li>Base: <code>#D946EF</code></li>
                <li>Soft: <code>#FAE8FF</code></li>
                <li>Dark: <code>#86198F</code></li>
                <li>On-solid: <code>#FFFFFF</code></li>
              </ul>
            </li>
          </ol>

          <h4>Neutrals (Text on Soft Chips)</h4>
          <ul>
            <li><strong>Ink-900</strong>: <code>#0F172A</code></li>
            <li><strong>Ink-700</strong>: <code>#334155</code></li>
            <li><strong>Ink-500</strong>: <code>#64748B</code></li>
          </ul>

          <h4>Usage Notes</h4>
          <ul>
            <li><strong>Soft</strong>: Use for left-rail "pale chip" backgrounds and subtle tag pills. Pair with Ink-900 text and a 1px border in the base color.</li>
            <li><strong>Base (solid)</strong>: Use for stronger chips, selected rows, or small badges. Use the listed on-solid color to maintain contrast.</li>
            <li><strong>Dark</strong>: Use for hover states, borders, or focus rings for the same accent.</li>
          </ul>

          <h3>Export Types</h3>
          <ol>
            <li><strong>Export All Chapters</strong> - All chapters with optional snippet names</li>
            <li><strong>Export Outline</strong> - Chapter and snippet titles with descriptions</li>
            <li><strong>Export All People</strong> - All person snippets</li>
            <li><strong>Export All Places</strong> - All place snippets</li>
            <li><strong>Export All Things</strong> - All thing snippets</li>
          </ol>

          <h3>Goal System Features</h3>
          <ul>
            <li><strong>Target</strong>: Total word count goal</li>
            <li><strong>Deadline</strong>: Target completion date</li>
            <li><strong>Writing Days</strong>: Selectable days of week (Mon-Sun)</li>
            <li><strong>Mode</strong>:
              <ul>
                <li>Elastic: Rebalances daily targets based on progress</li>
                <li>Strict: Fixed daily targets regardless of progress</li>
              </ul>
            </li>
            <li><strong>Days Off</strong>: Comma-separated dates to exclude</li>
            <li><strong>Midnight Rollover</strong>: Handles day boundary crossings</li>
          </ul>

          <h3>Code Statistics</h3>
          <ul>
            <li><strong>Total Functions</strong>: ~987 functions across all JS files</li>
            <li><strong>Error Logging</strong>: Custom system with localStorage persistence</li>
            <li><strong>Background Loading</strong>: Optimized batch loading with throttled updates</li>
          </ul>
        </section>

        <section class="docs-section" id="state-normalization" style="background: #ECFDF5; border-left: 4px solid #10B981; padding: var(--space-lg); margin-bottom: var(--space-2xl); border-radius: var(--radius-lg);">
          <h2 id="state-normalization-heading" style="margin-top: 0; color: #059669; display: flex; align-items: center; gap: 8px;">
            <i class="material-icons" style="font-size: 24px;">storage</i>
            State Normalization (P1 Priority)
          </h2>

          <h3>Overview</h3>
          <p><strong>Why</strong>: Moving to React is the perfect moment to stop passing giant nested objects around. Normalized state keeps renders cheap, enables virtualized lists later, and makes the codebase more maintainable.</p>
          <p><strong>What</strong>: Model all entities (stories, groups, snippets, notes, tags, goals) keyed by id in the Zustand store. Use selectors to derive views (e.g., left-rail lists). This keeps renders cheap and enables virtualized lists later.</p>

          <h3>Implementation Strategy</h3>

          <h4>1. Normalized Store Structure</h4>
          <p>All entities will be stored in normalized form (keyed by id) in the Zustand store:</p>
          <pre><code>// src/store/types.ts
export interface AppState {
  // Normalized entities - keyed by id
  stories: Record&lt;string, Story&gt;;
  groups: Record&lt;string, Group&gt;;
  snippets: Record&lt;string, Snippet&gt;;
  notes: Record&lt;string, Note&gt;; // People, Places, Things
  tags: Record&lt;string, Tag&gt;;
  goals: Record&lt;string, Goal&gt;;
  
  // Denormalized views - derived via selectors
  project: {
    storyId: string | null;
    groupIds: string[]; // Ordered list of group ids
    snippetIds: string[]; // Ordered list of snippet ids
    activeSnippetId: string | null;
    activeRightTab: 'people' | 'places' | 'things';
    filters: {
      search: string;
    };
  };
  
  // UI state
  collapsedGroups: Set&lt;string&gt;;
  editing: {
    savingState: 'idle' | 'saving' | 'saved';
    lastSavedAt: string | null;
  };
}</code></pre>

          <h4>2. Selectors for Derived Views</h4>
          <p>Create selectors to derive views from normalized state:</p>
          <pre><code>// src/store/selectors.ts
import { useStore } from './store';

// Get groups as array (for left-rail list)
export function useGroupsList() {
  return useStore((state) => {
    const { project, groups } = state;
    return project.groupIds
      .map((id) => groups[id])
      .filter(Boolean); // Filter out any missing groups
  });
}

// Get snippets for a specific group
export function useGroupSnippets(groupId: string) {
  return useStore((state) => {
    const group = state.groups[groupId];
    if (!group) return [];
    return group.snippetIds
      .map((id) => state.snippets[id])
      .filter(Boolean);
  });
}

// Get filtered groups (for search)
export function useFilteredGroups() {
  return useStore((state) => {
    const { project, groups } = state;
    const search = project.filters.search.toLowerCase();
    if (!search) {
      return project.groupIds.map((id) => groups[id]).filter(Boolean);
    }
    return project.groupIds
      .map((id) => groups[id])
      .filter((group) => {
        if (!group) return false;
        // Search in group title
        if (group.title.toLowerCase().includes(search)) return true;
        // Search in group snippets
        return group.snippetIds.some((snippetId) => {
          const snippet = state.snippets[snippetId];
          if (!snippet) return false;
          return (
            snippet.title.toLowerCase().includes(search) ||
            snippet.body.toLowerCase().includes(search)
          );
        });
      });
  });
}

// Get notes by type (People, Places, Things)
export function useNotesByType(type: 'person' | 'place' | 'thing') {
  return useStore((state) => {
    return Object.values(state.notes).filter((note) => note.kind === type);
  });
}</code></pre>

          <h4>3. Benefits of Normalization</h4>
          <ol>
            <li><strong>Cheap Renders</strong>: Components only re-render when their specific entities change, not when unrelated entities update</li>
            <li><strong>Virtualized Lists</strong>: Normalized structure makes it easy to implement virtual scrolling for long lists later</li>
            <li><strong>Single Source of Truth</strong>: Each entity exists once in the store, eliminating duplication</li>
            <li><strong>Efficient Updates</strong>: Updating a single entity doesn't require re-rendering entire lists</li>
            <li><strong>Type Safety</strong>: TypeScript ensures we access entities correctly via selectors</li>
          </ol>

          <h4>4. Migration from Current Structure</h4>
          <p><strong>Before (nested objects)</strong>:</p>
          <pre><code>// ❌ DON'T DO THIS
const state = {
  groups: [
    {
      id: '1',
      title: 'Chapter 1',
      snippets: [
        { id: '1-1', title: 'Snippet 1', body: '...' },
        { id: '1-2', title: 'Snippet 2', body: '...' },
      ],
    },
  ],
};</code></pre>

          <p><strong>After (normalized)</strong>:</p>
          <pre><code>// ✅ DO THIS
const state = {
  groups: {
    '1': { id: '1', title: 'Chapter 1', snippetIds: ['1-1', '1-2'] },
  },
  snippets: {
    '1-1': { id: '1-1', title: 'Snippet 1', body: '...', groupId: '1' },
    '1-2': { id: '1-2', title: 'Snippet 2', body: '...', groupId: '1' },
  },
  project: {
    groupIds: ['1'],
  },
};

// Use selector to get groups as array
const groupsList = useGroupsList(); // Returns array of groups</code></pre>

          <h3>Implementation Timeline</h3>
          <p>This should be implemented in <strong>Phase 1</strong> (Setup & Infrastructure) as it's foundational:</p>
          <ul>
            <li>Define normalized state structure in <code>src/store/types.ts</code></li>
            <li>Create Zustand store with normalized entities</li>
            <li>Create selectors in <code>src/store/selectors.ts</code></li>
            <li>Update all components to use selectors instead of direct state access</li>
          </ul>
          <p><strong>LOE</strong>: 4-6 hours (adds time but saves significant debugging and enables future optimizations)</p>
        </section>

        <section class="docs-section" id="custom-implementation">
          <h2 id="what-needs-custom-implementation">What Needs Custom Implementation</h2>
          <p>These areas cannot be replaced with libraries and require custom React code:</p>

          <h3>1. State Management Architecture</h3>
          <ul>
            <li><strong>Current</strong>: Global <code>state</code> object with direct mutations and nested structures</li>
            <li><strong>React + TypeScript</strong>: Zustand with TypeScript interfaces and <strong>normalized state structure</strong></li>
            <li><strong>Complexity</strong>: High</li>
            <li><strong>Lines</strong>: ~500-800 lines of state logic + type definitions + selectors</li>
            <li><strong>TypeScript</strong>: Will create interfaces for all state structures (Group, Snippet, Project, Goal, etc.)</li>
            <li><strong>Normalization</strong>: All entities (stories, groups, snippets, notes, tags, goals) keyed by id in the store; selectors derive views (e.g., left-rail lists)</li>
            <li><strong>Benefits</strong>: Keeps renders cheap, enables virtualized lists later, single source of truth</li>
          </ul>

          <h3>2. Google Drive Integration</h3>
          <ul>
            <li><strong>Current</strong>: API calls in <code>drive.js</code></li>
            <li><strong>React + TypeScript</strong>: Convert to React Query hooks using TanStack Query for ALL Drive I/O operations</li>
            <li><strong>Complexity</strong>: Medium</li>
            <li><strong>Status</strong>: Backend already works, just needs React Query wrapper</li>
            <li><strong>TypeScript</strong>: Will create interfaces for API responses and request parameters</li>
            <li><strong>Critical</strong>: ALL Drive operations (read, write, list, delete, rename, check comments, etc.) MUST use React Query, not ad-hoc useEffect hooks</li>
            <li><strong>Benefits</strong>: Automatic deduplication, retries, stale-while-revalidate, cache invalidation, loading/error states</li>
          </ul>

          <h3>3. Word Counting Logic</h3>
          <ul>
            <li><strong>Current</strong>: <code>countWords()</code> function</li>
            <li><strong>React</strong>: Can be reused as-is or converted to hook</li>
            <li><strong>Complexity</strong>: Low</li>
            <li><strong>Lines</strong>: ~50-100 lines</li>
          </ul>

          <h3>4. Goal Calculation Algorithms</h3>
          <ul>
            <li><strong>Current</strong>: Complex date/word calculation logic</li>
            <li><strong>React</strong>: Convert to hooks (<code>useGoal</code>, <code>useDailyTarget</code>)</li>
            <li><strong>Complexity</strong>: Medium-High</li>
            <li><strong>Lines</strong>: ~200-300 lines</li>
          </ul>

          <h3>5. Export Functionality</h3>
          <ul>
            <li><strong>Current</strong>: Custom export logic for chapters/outline/notes</li>
            <li><strong>React</strong>: Convert to utility functions or hooks</li>
            <li><strong>Complexity</strong>: Medium</li>
            <li><strong>Lines</strong>: ~200-300 lines</li>
            <li><strong>Details</strong>:
              <ul>
                <li>Exports to Google Docs format</li>
                <li>Supports 5 export types (chapters, outline, people, places, things)</li>
                <li>Optional snippet name inclusion</li>
                <li>User-provided filenames</li>
              </ul>
            </li>
          </ul>

          <h3>6. Search/Filtering Logic</h3>
          <ul>
            <li><strong>Current</strong>: Inline filtering in render functions</li>
            <li><strong>React</strong>: Convert to <code>useMemo</code> hooks</li>
            <li><strong>Complexity</strong>: Low-Medium</li>
            <li><strong>Lines</strong>: ~100-150 lines</li>
            <li><strong>Details</strong>:
              <ul>
                <li>Searches group titles, snippet titles, and snippet body content</li>
                <li>Case-insensitive matching</li>
              </ul>
            </li>
          </ul>

          <h3>7. Authentication Flow</h3>
          <ul>
            <li><strong>Current</strong>: Google Sign-In SDK integration</li>
            <li><strong>React</strong>: Convert to context + hooks</li>
            <li><strong>Complexity</strong>: Medium</li>
            <li><strong>Lines</strong>: ~200-300 lines</li>
            <li><strong>Details</strong>:
              <ul>
                <li>48-hour session expiration</li>
                <li>Token validation</li>
                <li>Auto-redirect logic</li>
                <li>Dev mode bypass for localhost</li>
              </ul>
            </li>
          </ul>

          <h3>8. Lazy Loading Logic</h3>
          <ul>
            <li><strong>Current</strong>: Background loading of snippet content</li>
            <li><strong>React</strong>: Convert to React Query with prefetching and background refetching</li>
            <li><strong>Complexity</strong>: Medium</li>
            <li><strong>Lines</strong>: ~300-400 lines</li>
            <li><strong>Details</strong>:
              <ul>
                <li>Loads active snippet first, then background loads remaining</li>
                <li>Uses React Query's <code>prefetchQuery</code> and <code>useQueries</code> for batch loading</li>
                <li>React Query handles throttling and prevents duplicate requests automatically</li>
                <li>Prevents UI blocking with React Query's built-in background refetching</li>
                <li><strong>Note</strong>: This is part of the broader React Query strategy for ALL Drive I/O</li>
              </ul>
            </li>
          </ul>

          <h3>9. Mobile Detection</h3>
          <ul>
            <li><strong>Current</strong>: User agent and touch detection</li>
            <li><strong>React</strong>: Convert to custom hook (<code>useMobileDetection</code>)</li>
            <li><strong>Complexity</strong>: Low</li>
            <li><strong>Lines</strong>: ~50 lines</li>
            <li><strong>Details</strong>: Shows warning message for mobile devices</li>
          </ul>

          <h3>10. Error Logging System</h3>
          <ul>
            <li><strong>Current</strong>: Custom localStorage-based error logging</li>
            <li><strong>React</strong>: Can reuse or convert to error boundary + logging service</li>
            <li><strong>Complexity</strong>: Low-Medium</li>
            <li><strong>Lines</strong>: ~100 lines</li>
            <li><strong>Details</strong>:
              <ul>
                <li>Logs errors to localStorage (max 50)</li>
                <li>Captures console errors, unhandled rejections</li>
                <li>Exposes <code>viewYarnyErrors()</code> function</li>
              </ul>
            </li>
          </ul>

          <h3>11. Midnight Rollover Handling</h3>
          <ul>
            <li><strong>Current</strong>: Handles goal calculation across day boundaries</li>
            <li><strong>React</strong>: Convert to hook with date change detection</li>
            <li><strong>Complexity</strong>: Medium</li>
            <li><strong>Lines</strong>: ~100-150 lines</li>
            <li><strong>Details</strong>: Recalculates daily targets when crossing midnight</li>
          </ul>

          <h3>12. Goal Calculation Modes</h3>
          <ul>
            <li><strong>Current</strong>: Elastic (rebalances) vs Strict (fixed) modes</li>
            <li><strong>React</strong>: Convert to hook with mode-specific logic</li>
            <li><strong>Complexity</strong>: Medium</li>
            <li><strong>Lines</strong>: ~200-300 lines</li>
            <li><strong>Details</strong>:
              <ul>
                <li>Elastic: Adjusts daily targets based on progress</li>
                <li>Strict: Fixed daily targets</li>
                <li>Writing days selection (Mon-Sun)</li>
                <li>Days off support</li>
              </ul>
            </li>
          </ul>
        </section>

        <section class="docs-section" id="fetch-caching">
          <h2 id="fetch-caching-heading">Fetch/Caching Layer with TanStack Query (P1 Priority)</h2>
          
          <h3>Overview</h3>
          <p><strong>Why</strong>: Multiple components will read/write the same Drive resources. Manual <code>useEffect</code> trees are brittle and lead to duplicate API calls, no automatic retry logic, manual cache management, inconsistent loading/error states, and race conditions.</p>
          <p><strong>What</strong>: Adopt <strong>TanStack Query (React Query)</strong> as the fetch/caching layer for ALL Drive I/O operations. This provides automatic deduplication, retries, stale-while-revalidate, cache invalidation, loading/error states, and background refetching.</p>

          <h3>Drive Operations Covered</h3>
          <p>ALL of these operations MUST use React Query (not ad-hoc useEffect):</p>
          <ol>
            <li>✅ <strong>List files/folders</strong> - <code>useDriveFiles()</code></li>
            <li>✅ <strong>Read file content</strong> - <code>useDriveFile()</code>, <code>useDriveFilesBatch()</code></li>
            <li>✅ <strong>Write/update file</strong> - <code>useWriteDriveFile()</code> mutation</li>
            <li>✅ <strong>Delete file</strong> - <code>useDeleteDriveFile()</code> mutation</li>
            <li>✅ <strong>Rename file</strong> - <code>useRenameDriveFile()</code> mutation</li>
            <li>✅ <strong>Check comments/changes</strong> - <code>useDriveComments()</code></li>
            <li>✅ <strong>Create folder</strong> - <code>useCreateFolder()</code> mutation</li>
            <li>✅ <strong>Get/create Yarny Stories folder</strong> - <code>useYarnyStoriesFolder()</code></li>
            <li>✅ <strong>Background/lazy loading</strong> - <code>prefetchQuery()</code> and <code>useQueries()</code></li>
          </ol>

          <h3>Benefits</h3>
          <ol>
            <li><strong>No Duplicate Requests</strong>: Multiple components reading the same file share one request</li>
            <li><strong>Automatic Retries</strong>: Failed requests retry automatically with exponential backoff</li>
            <li><strong>Stale-While-Revalidate</strong>: Show cached data immediately, update in background</li>
            <li><strong>Cache Invalidation</strong>: Mutations automatically invalidate related queries</li>
            <li><strong>Loading States</strong>: Built-in <code>isLoading</code>, <code>isFetching</code>, <code>isError</code> states</li>
            <li><strong>Background Refetching</strong>: Keep data fresh without blocking UI</li>
            <li><strong>Type Safety</strong>: Full TypeScript support with typed queries and mutations</li>
          </ol>

          <h3>Implementation Timeline</h3>
          <p>This should be implemented in <strong>Phase 1</strong> (Setup & Infrastructure) alongside API contract formalization:</p>
          <ul>
            <li>Install <code>@tanstack/react-query</code></li>
            <li>Set up <code>QueryClient</code> and <code>QueryClientProvider</code></li>
            <li>Create <code>useDriveQueries.ts</code> with all Drive operation hooks</li>
            <li>Update all components to use React Query hooks instead of direct API calls</li>
            <li>Replace lazy loading logic with React Query prefetching</li>
          </ul>
          <p><strong>LOE:</strong> 6-8 hours (adds time but saves significant debugging and provides better UX)</p>
        </section>

        <section class="docs-section" id="api-contract">
          <h2 id="api-contract-heading">API Contract Formalization (P1 Priority)</h2>
          
          <h3>Overview</h3>
          <p><strong>Why</strong>: TypeScript on the client is only half the story. We need a typed boundary with runtime validation so Drive/Docs responses don't surprise us during the migration. This reduces "works in dev, breaks in prod" bugs during the cut-over.</p>
          <p><strong>What</strong>: Define a minimal "API contract" (types + runtime validation) for every endpoint we hit (auth, Drive metadata, snapshot list). Keep it central and use it consistently.</p>

          <h3>Implementation Strategy</h3>
          
          <h4>1. Centralized API Contract Module</h4>
          <p>Create <code>src/api/contract.ts</code> that defines:</p>
          <ul>
            <li><strong>TypeScript types</strong> for all request/response shapes</li>
            <li><strong>Zod schemas</strong> for runtime validation</li>
            <li><strong>Single source of truth</strong> for all API contracts</li>
          </ul>
          <p><strong>Why Zod?</strong></p>
          <ul>
            <li>TypeScript-first schema validation</li>
            <li>Automatic type inference from schemas</li>
            <li>Small bundle size (~8KB)</li>
            <li>Excellent error messages</li>
            <li>Can generate TypeScript types from schemas</li>
          </ul>

          <h4>2. API Client Wrapper</h4>
          <p>Create <code>src/api/client.ts</code> that:</p>
          <ul>
            <li>Provides typed functions for each endpoint</li>
            <li>Automatically validates requests and responses using Zod</li>
            <li>Handles errors consistently</li>
            <li>Provides type-safe API calls throughout the app</li>
          </ul>

          <h4>3. File Structure</h4>
          <pre style="background: rgba(0, 0, 0, 0.3); padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>src/api/
├── contract.ts      # Type definitions + Zod schemas for all endpoints
├── client.ts       # Typed API client functions
└── types.ts        # Shared TypeScript types (if needed)</code></pre>

          <h3>Endpoints to Cover</h3>
          
          <h4>Authentication Endpoints</h4>
          <ul>
            <li><code>POST /.netlify/functions/verify-google</code> - Verify Google ID token</li>
            <li><code>POST /.netlify/functions/logout</code> - Clear session</li>
            <li><code>GET /.netlify/functions/config</code> - Get Google Client ID</li>
          </ul>

          <h4>Drive Integration Endpoints</h4>
          <ul>
            <li><code>GET /.netlify/functions/drive-list</code> - List files/folders</li>
            <li><code>POST /.netlify/functions/drive-read</code> - Read file content</li>
            <li><code>POST /.netlify/functions/drive-write</code> - Write/update file</li>
            <li><code>POST /.netlify/functions/drive-check-comments</code> - Check for comments/tracked changes</li>
            <li><code>POST /.netlify/functions/drive-create-folder</code> - Create folder</li>
            <li><code>POST /.netlify/functions/drive-delete-story</code> - Delete story folder</li>
            <li><code>GET /.netlify/functions/drive-get-or-create-yarny-stories</code> - Get or create Yarny Stories folder</li>
            <li><code>POST /.netlify/functions/drive-delete-file</code> - Delete file</li>
            <li><code>POST /.netlify/functions/drive-rename-file</code> - Rename file</li>
            <li><code>GET /.netlify/functions/drive-auth</code> - Initiate Drive OAuth (redirect)</li>
            <li><code>GET /.netlify/functions/drive-auth-callback</code> - OAuth callback (redirect)</li>
          </ul>

          <h4>Status Endpoints</h4>
          <ul>
            <li><code>GET /.netlify/functions/uptime-status</code> - Get uptime status</li>
          </ul>

          <h3>Example Implementation</h3>
          <pre style="background: rgba(0, 0, 0, 0.3); padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/api/contract.ts
import { z } from 'zod';

// Request/Response schemas using Zod
export const VerifyGoogleRequestSchema = z.object({
  token: z.string().min(1),
});

export const VerifyGoogleResponseSchema = z.object({
  verified: z.boolean(),
  user: z.string().email(),
  name: z.string().optional(),
  picture: z.string().url().optional(),
  token: z.string(),
});

// Infer TypeScript types from schemas
export type VerifyGoogleRequest = z.infer&lt;typeof VerifyGoogleRequestSchema&gt;;
export type VerifyGoogleResponse = z.infer&lt;typeof VerifyGoogleResponseSchema&gt;;

// Drive file metadata schema
export const DriveFileSchema = z.object({
  id: z.string(),
  name: z.string(),
  mimeType: z.string(),
  modifiedTime: z.string().optional(),
  size: z.string().optional(),
  trashed: z.boolean().optional(),
});

export const DriveListResponseSchema = z.object({
  files: z.array(DriveFileSchema),
  nextPageToken: z.string().optional(),
});

export type DriveFile = z.infer&lt;typeof DriveFileSchema&gt;;
export type DriveListResponse = z.infer&lt;typeof DriveListResponseSchema&gt;;

// Drive read request/response
export const DriveReadRequestSchema = z.object({
  fileId: z.string().min(1),
});

export const DriveReadResponseSchema = z.object({
  id: z.string(),
  name: z.string(),
  mimeType: z.string(),
  modifiedTime: z.string().optional(),
  content: z.string(),
});

export type DriveReadRequest = z.infer&lt;typeof DriveReadRequestSchema&gt;;
export type DriveReadResponse = z.infer&lt;typeof DriveReadResponseSchema&gt;;

// Drive write request/response
export const DriveWriteRequestSchema = z.object({
  fileId: z.string().optional(),
  fileName: z.string().min(1),
  content: z.string(),
  parentFolderId: z.string().optional(),
  mimeType: z.string().default('text/plain'),
});

export const DriveWriteResponseSchema = z.object({
  id: z.string(),
  name: z.string(),
  modifiedTime: z.string().optional(),
});

export type DriveWriteRequest = z.infer&lt;typeof DriveWriteRequestSchema&gt;;
export type DriveWriteResponse = z.infer&lt;typeof DriveWriteResponseSchema&gt;;

// Error response schema (common across all endpoints)
export const ApiErrorResponseSchema = z.object({
  error: z.string(),
  message: z.string().optional(),
  requiresReauth: z.boolean().optional(),
});

export type ApiErrorResponse = z.infer&lt;typeof ApiErrorResponseSchema&gt;;</code></pre>

          <pre style="background: rgba(0, 0, 0, 0.3); padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/api/client.ts
import axios from 'axios';
import { z } from 'zod';
import {
  VerifyGoogleRequestSchema,
  VerifyGoogleResponseSchema,
  DriveListResponseSchema,
  DriveReadRequestSchema,
  DriveReadResponseSchema,
  DriveWriteRequestSchema,
  DriveWriteResponseSchema,
  ApiErrorResponseSchema,
  type VerifyGoogleRequest,
  type VerifyGoogleResponse,
  type DriveListResponse,
  type DriveReadRequest,
  type DriveReadResponse,
  type DriveWriteRequest,
  type DriveWriteResponse,
} from './contract';

const API_BASE = '/.netlify/functions';

// Configure axios defaults
axios.defaults.withCredentials = true;

// Generic API call helper with validation
async function apiCall&lt;TRequest, TResponse&gt;(
  endpoint: string,
  request: TRequest,
  requestSchema: z.ZodSchema&lt;TRequest&gt;,
  responseSchema: z.ZodSchema&lt;TResponse&gt;,
  method: 'GET' | 'POST' = 'POST'
): Promise&lt;TResponse&gt; {
  // Validate request
  const validatedRequest = requestSchema.parse(request);

  try {
    const response = await (method === 'GET'
      ? axios.get(`${API_BASE}${endpoint}`, { params: validatedRequest })
      : axios.post(`${API_BASE}${endpoint}`, validatedRequest));

    // Validate response
    const validatedResponse = responseSchema.parse(response.data);
    return validatedResponse;
  } catch (error) {
    if (axios.isAxiosError(error) && error.response) {
      // Try to parse error response
      const errorData = ApiErrorResponseSchema.safeParse(error.response.data);
      if (errorData.success) {
        throw new Error(errorData.data.error);
      }
      throw new Error(error.response.data?.error || 'API request failed');
    }
    if (error instanceof z.ZodError) {
      // Validation error - this is a contract violation
      console.error('API contract violation:', error.errors);
      throw new Error(`Invalid API response: ${error.errors.map(e => e.message).join(', ')}`);
    }
    throw error;
  }
}

// Typed API functions
export async function verifyGoogle(
  request: VerifyGoogleRequest
): Promise&lt;VerifyGoogleResponse&gt; {
  return apiCall(
    '/verify-google',
    request,
    VerifyGoogleRequestSchema,
    VerifyGoogleResponseSchema
  );
}

export async function listDriveFiles(
  folderId?: string,
  pageToken?: string
): Promise&lt;DriveListResponse&gt; {
  const params = { folderId, pageToken };
  // For GET requests, we'll handle validation differently
  const response = await axios.get(`${API_BASE}/drive-list`, { params });
  return DriveListResponseSchema.parse(response.data);
}

export async function readDriveFile(
  request: DriveReadRequest
): Promise&lt;DriveReadResponse&gt; {
  return apiCall(
    '/drive-read',
    request,
    DriveReadRequestSchema,
    DriveReadResponseSchema
  );
}

export async function writeDriveFile(
  request: DriveWriteRequest
): Promise&lt;DriveWriteResponse&gt; {
  return apiCall(
    '/drive-write',
    request,
    DriveWriteRequestSchema,
    DriveWriteResponseSchema
  );
}

// ... additional endpoint functions</code></pre>

          <h3>Benefits</h3>
          <ol>
            <li><strong>Type Safety</strong>: Compile-time checking ensures we use correct request/response shapes</li>
            <li><strong>Runtime Validation</strong>: Zod catches shape mismatches at runtime, preventing "works in dev, breaks in prod" issues</li>
            <li><strong>Centralized Contracts</strong>: Single source of truth makes it easy to update when endpoints change</li>
            <li><strong>Better Error Messages</strong>: Zod provides clear validation error messages</li>
            <li><strong>Self-Documenting</strong>: Types serve as inline documentation</li>
            <li><strong>Migration Safety</strong>: During cut-over, validation ensures backend changes don't break the frontend silently</li>
          </ol>

          <h3>Implementation Timeline</h3>
          <p>This should be implemented in <strong>Phase 1</strong> (Setup & Infrastructure) as it's foundational:</p>
          <ul>
            <li>Create <code>src/api/contract.ts</code> with all endpoint schemas</li>
            <li>Create <code>src/api/client.ts</code> with typed API functions</li>
            <li>Update hooks (<code>useDrive</code>, <code>useAuth</code>) to use the typed client</li>
            <li>Add <code>zod</code> to dependencies</li>
          </ul>
          <p><strong>LOE:</strong> 4-6 hours (adds time but saves debugging during migration)</p>

          <h3>Dependencies</h3>
          <p>Add to <code>package.json</code>:</p>
          <pre style="background: rgba(0, 0, 0, 0.3); padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>{
  "dependencies": {
    "zod": "^3.x"
  }
}</code></pre>
        </section>

        <section class="docs-section" id="editor-truth">
          <h2 id="editor-truth-heading">Editor Truth and Google Docs Round-Tripping (P1 Priority)</h2>
          
          <h3>Overview</h3>
          <p><strong>Why</strong>: TipTap is a great editor, but Google Docs is the storage of record. The Google Docs API doesn't speak arbitrary HTML; even if you keep content plain-text, small mismatches can creep in during round-tripping between the editor and Google Docs.</p>
          <p><strong>What</strong>: For v1 React migration, constrain TipTap formatting to Yarny's minimalist model (plain paragraphs, soft line-breaks) and establish clear rules for editor authority and reconciliation.</p>

          <h3>Design Decisions</h3>
          
          <h4>1. Format Constraint: Plain Text Only</h4>
          <p><strong>Decision</strong>: TipTap will be configured to support <strong>only plain text</strong> - no rich formatting (bold, italic, colors, etc.).</p>
          <p><strong>Why</strong>:</p>
          <ul>
            <li>Google Docs API doesn't handle arbitrary HTML well</li>
            <li>Current Yarny model is minimalist (plain text with line breaks)</li>
            <li>Reduces round-tripping issues and format mismatches</li>
            <li>Simpler implementation for v1</li>
          </ul>
          <p><strong>Implementation</strong>:</p>
          <ul>
            <li>Use TipTap's <code>Document</code> extension (required)</li>
            <li>Use <code>Paragraph</code> extension for paragraph breaks (<code>\n\n</code>)</li>
            <li>Use <code>HardBreak</code> extension for soft line breaks (<code>\n</code>)</li>
            <li><strong>Disable</strong> all formatting extensions (Bold, Italic, Heading, etc.)</li>
            <li>Configure TipTap to extract plain text that matches Google Docs API output</li>
          </ul>

          <h4>2. Editor as Truth While Open</h4>
          <p><strong>Decision</strong>: While Yarny is open and a snippet is being edited, <strong>the editor is authoritative</strong>. Changes made in Google Docs while Yarny is open are ignored until the user switches snippets or closes Yarny.</p>
          <p><strong>Why</strong>:</p>
          <ul>
            <li>Prevents conflicts while actively editing</li>
            <li>Better UX - user's current edits take precedence</li>
            <li>Matches current behavior (editor content is saved to Drive, overwriting Drive version)</li>
          </ul>

          <h4>3. Reconciliation on Window Focus</h4>
          <p><strong>Decision</strong>: When the window regains focus, check if any open snippets were modified externally in Google Docs. If so, reconcile the changes.</p>
          <p><strong>Why</strong>:</p>
          <ul>
            <li>User might have edited in Google Docs in another tab/window</li>
            <li>Need to detect and handle external changes</li>
            <li>Better than only checking on snippet switch (catches changes sooner)</li>
          </ul>

          <h4>4. Conflict Detection</h4>
          <p><strong>Decision</strong>: Set up conflict detection infrastructure early (Phase 1), implement hooks and UI in Phase 6.</p>
          <p><strong>Why</strong>:</p>
          <ul>
            <li>Conflict detection infrastructure (text extraction utilities) is foundational</li>
            <li>Need to test round-tripping early (Phase 4)</li>
            <li>Conflict resolution UI can be implemented after core editor is working (Phase 6)</li>
          </ul>

          <h3>Round-Tripping Flow</h3>
          <ol>
            <li><strong>Load from Drive</strong>: Google Docs content → Plain text → TipTap editor</li>
            <li><strong>Edit in TipTap</strong>: User edits → TipTap onChange → Plain text → State update</li>
            <li><strong>Save to Drive</strong>: Plain text → Google Docs API → Google Docs updated</li>
            <li><strong>Reconciliation</strong>: On focus/switch, check if Drive changed → Compare plain text → Resolve if different</li>
          </ol>

          <h3>Implementation Timeline</h3>
          <p>This spans multiple phases:</p>
          <ul>
            <li><strong>Phase 1</strong>: Set up TipTap with plain text configuration, create text extraction utilities</li>
            <li><strong>Phase 2</strong>: Implement reconciliation on window focus</li>
            <li><strong>Phase 4</strong>: Integrate TipTap editor with round-trip testing</li>
            <li><strong>Phase 6</strong>: Create conflict detection hooks, conflict resolution UI and logic</li>
          </ul>
          <p><strong>LOE:</strong> 8-12 hours (includes TipTap configuration, conflict detection, reconciliation, and testing)</p>

          <h3>Dependencies</h3>
          <p>Already included in recommended stack:</p>
          <ul>
            <li><code>@tiptap/react</code> - Editor framework</li>
            <li>Individual TipTap extensions: <code>@tiptap/extension-document</code>, <code>@tiptap/extension-paragraph</code>, <code>@tiptap/extension-text</code>, <code>@tiptap/extension-hard-break</code>, <code>@tiptap/extension-history</code></li>
          </ul>
          <p><strong>Note</strong>: Do NOT use full starter-kit - configure extensions individually to exclude formatting.</p>
        </section>

        <section class="docs-section" id="migration-phases">
          <h2 id="migration-phases-heading">Migration Phases</h2>
          
          <h3>Phase 1: Setup & Infrastructure (Week 1)</h3>
          <ul>
            <li>Set up React + TypeScript + Vite build system</li>
            <li>Configure TypeScript (tsconfig.json)</li>
            <li>Set up type definitions for all libraries</li>
            <li>Set up Netlify build configuration</li>
            <li>Install and configure all libraries</li>
            <li><strong>Set up TanStack Query (React Query) with QueryClient and QueryClientProvider</strong></li>
            <li><strong>Create React Query hooks for ALL Drive I/O operations (<code>src/hooks/useDriveQueries.ts</code>)</strong></li>
            <li><strong>Configure TipTap for plain text only (no rich formatting)</strong></li>
            <li><strong>Create text extraction utilities matching Google Docs format</strong></li>
            <li>Create base component structure with TypeScript</li>
            <li><strong>Set up normalized state management (Zustand) with TypeScript types</strong></li>
            <li><strong>Create normalized state structure in <code>src/store/types.ts</code> (all entities keyed by id)</strong></li>
            <li><strong>Create selectors in <code>src/store/selectors.ts</code> to derive views (e.g., left-rail lists)</strong></li>
            <li><strong>Set up MUI theme customization (<code>src/theme/theme.ts</code>) with brand color mappings</strong></li>
            <li><strong>Customize MUI component defaults to match existing design</strong></li>
            <li><strong>Set up ThemeProvider in app root</strong></li>
            <li><strong>Create test corpus folder structure (<code>Yarny Test Corpus</code> in Drive)</strong></li>
            <li><strong>Populate small project with sample data</strong></li>
            <li><strong>Document smoke test checklist</strong></li>
          </ul>
          <p><strong>LOE:</strong> 30-42 hours (includes TypeScript setup, type definitions, React Query setup, TipTap plain text configuration, state normalization, MUI theming, and test corpus setup)</p>

          <h3>Phase 2: Authentication, Router & API Contract (Week 1-2)</h3>
          <ul>
            <li>Configure React Router with TypeScript</li>
            <li>Set up routing structure</li>
            <li><strong>Create API contract module (<code>src/api/contract.ts</code>) with Zod schemas</strong></li>
            <li><strong>Create typed API client (<code>src/api/client.ts</code>)</strong></li>
            <li>Convert login page to React</li>
            <li>Integrate Google Sign-In SDK</li>
            <li>Create Auth context/provider</li>
            <li>Handle auth state and redirects</li>
            <li><strong>Implement reconciliation on window focus (<code>src/hooks/useWindowFocusReconciliation.ts</code>)</strong></li>
            <li>Test authentication flow</li>
          </ul>
          <p><strong>LOE:</strong> 12-18 hours (includes router setup, API contract formalization, and reconciliation hook implementation)</p>

          <h3>Phase 3: Stories Page with Virtualization Stub (Week 2)</h3>
          <ul>
            <li>Convert stories list to React components</li>
            <li>Implement search/filtering</li>
            <li>Add modals (new story, delete confirmation)</li>
            <li>Integrate with Drive API hooks</li>
            <li><strong>Stub virtualized list capability (set up <code>@tanstack/react-virtual</code> infrastructure, even if not used yet)</strong></li>
            <li>Test story management</li>
          </ul>
          <p><strong>LOE:</strong> 10-14 hours (includes virtualization infrastructure setup)</p>

          <h3>Phase 4: Editor - Tri-Pane Shell & Plain Text Round-Trip (Week 2-3)</h3>
          <ul>
            <li>Set up three-column layout (Story/Editor/Notes)</li>
            <li>Convert story list sidebar</li>
            <li>Convert notes sidebar with tabs</li>
            <li><strong>Implement footer word/character counts first</strong></li>
            <li><strong>Implement save status display</strong></li>
            <li><strong>Set up TipTap editor with plain text configuration</strong></li>
            <li><strong>Integrate TipTap with conflict detection</strong></li>
            <li><strong>Implement editor as truth (authoritative while open)</strong></li>
            <li>Basic editor functionality</li>
            <li><strong>Test round-tripping with Google Docs</strong></li>
            <li><strong>Run smoke tests on small project (test-small) after TipTap integration</strong></li>
            <li><strong>Validate round-tripping with small project</strong></li>
            <li><strong>Populate medium project (test-medium)</strong></li>
          </ul>
          <p><strong>LOE:</strong> 24-33 hours (includes TipTap integration, conflict detection integration, round-trip testing, smoke test execution, and footer/save status implementation)</p>

          <h3>Phase 5: Library Features & Goals UI (Week 3-4)</h3>
          <ul>
            <li>Implement drag & drop with @dnd-kit</li>
            <li>Color picker integration</li>
            <li>Context menus</li>
            <li>All modals (story info, rename, delete, etc.) using Material UI Dialog</li>
            <li>Tabs implementation using Material UI Tabs</li>
            <li><strong>Implement Goals UI: Goal Meter (left-rail) and Goal Panel modal at parity with alpha plan</strong></li>
            <li><strong>Implement "Today • N" chip with progress bar</strong></li>
            <li>Word count updates</li>
          </ul>
          <p><strong>LOE:</strong> 20-30 hours (includes Goals UI implementation with chip and panel)</p>

          <h3>Phase 6: Lazy Loading, Conflict Resolution & Exports (Week 4)</h3>
          <ul>
            <li>Lazy loading logic using React Query prefetching and <code>useQueries</code></li>
            <li>Auto-save functionality using React Query mutations</li>
            <li><strong>Create conflict detection hooks (<code>src/hooks/useConflictDetection.ts</code>)</strong></li>
            <li>Conflict resolution UI and logic</li>
            <li>Export functionality</li>
            <li><strong>Run full smoke test suite on small and medium projects</strong></li>
            <li><strong>Validate all operations work correctly</strong></li>
            <li><strong>Populate large project (test-large)</strong></li>
          </ul>
          <p><strong>LOE:</strong> 17-22 hours (Note: Lazy loading is simplified with React Query's built-in prefetching; includes smoke test execution)</p>

          <h3>Phase 7: Accessibility, Performance & Polish (Week 4-5)</h3>
          <ul>
            <li>Accessibility audit and fixes</li>
            <li>Cross-browser testing</li>
            <li><strong>Run full smoke test suite on all three project sizes (test-small, test-medium, test-large)</strong></li>
            <li><strong>Performance testing with large project (test-large)</strong></li>
            <li>Performance optimization (virtualization activation if needed, memoization review)</li>
            <li><strong>Regression testing before production deployment</strong></li>
            <li>Bug fixes</li>
            <li>Mobile responsiveness check</li>
            <li>Documentation updates</li>
          </ul>
          <p><strong>LOE:</strong> 19-31 hours (includes smoke test execution on all test corpus projects, accessibility pass, and performance touches)</p>
        </section>

        <section class="docs-section" id="risk-factors">
          <h2 id="risk-factors-heading">Risk Factors</h2>
          
          <h3>High Risk</h3>
          <ul>
            <li><strong>ContentEditable Complexity & Round-Tripping</strong> - Plain text editor integration and Google Docs round-tripping may have edge cases. Mitigation: Use TipTap (proven library) configured for plain text only, test round-tripping early. Contingency: Allow extra 5-10 hours for editor edge cases and round-trip testing.</li>
            <li><strong>State Management Migration</strong> - Complex state object with many interdependencies. Mitigation: Use Zustand for simpler migration path.</li>
            <li><strong>Performance with Large Stories</strong> - React re-renders may be slower. Mitigation: Use React.memo, useMemo, useCallback strategically.</li>
          </ul>

          <h3>Medium Risk</h3>
          <ul>
            <li><strong>Google Drive API Integration</strong> - React hooks may need different error handling. Status: Low risk, mostly wrapping existing code.</li>
            <li><strong>Feature Parity</strong> - Missing features during migration. Mitigation: Create feature checklist, test each feature.</li>
            <li><strong>CSS/Styling Migration</strong> - Styling may break during migration. Mitigation: Use CSS modules or styled-components for isolation.</li>
          </ul>

          <h3>Low Risk</h3>
          <ul>
            <li><strong>Build Configuration</strong> - Netlify build may need adjustments. Mitigation: Netlify has good React support, standard config. Status: Well-documented, low risk.</li>
            <li><strong>Third-Party Library Issues</strong> - Libraries may have bugs or incompatibilities. Mitigation: Use well-maintained, popular libraries. Status: All recommended libraries are stable.</li>
          </ul>
        </section>

        <section class="docs-section" id="benefits">
          <h2 id="benefits-of-migration">Benefits of Migration</h2>
          
          <h3>Development Benefits</h3>
          <ol>
            <li><strong>Reduced Code</strong>: ~3,300-4,200 lines replaced by libraries</li>
            <li><strong>Better Maintainability</strong>: React's component model is easier to maintain</li>
            <li><strong>Type Safety</strong>: TypeScript provides compile-time error checking and better IDE support</li>
            <li><strong>Developer Experience</strong>: Hot reload, better tooling, autocomplete, refactoring support</li>
            <li><strong>Easier Testing</strong>: React Testing Library makes testing easier, TypeScript catches errors before runtime</li>
            <li><strong>Better Documentation</strong>: TypeScript types serve as inline documentation</li>
            <li><strong>Safer Refactoring</strong>: TypeScript ensures changes don't break existing code</li>
          </ol>

          <h3>User Benefits</h3>
          <ol>
            <li><strong>Better Accessibility</strong>: Material UI components are fully accessible</li>
            <li><strong>Improved Performance</strong>: React optimizations (memoization, etc.)</li>
            <li><strong>Better UX</strong>: Polished interactions from proven libraries</li>
            <li><strong>Future Features</strong>: Easier to add new features in React</li>
          </ol>

          <h3>Business Benefits</h3>
          <ol>
            <li><strong>Faster Development</strong>: Future features will be faster to build</li>
            <li><strong>Easier Hiring</strong>: More developers know React than vanilla JS</li>
            <li><strong>Ecosystem</strong>: Access to React ecosystem of tools and libraries</li>
            <li><strong>Long-term Maintainability</strong>: React is a stable, long-term choice</li>
          </ol>
        </section>

        <section class="docs-section" id="netlify-config">
          <h2 id="netlify-configuration">Netlify Configuration</h2>
          
          <h3>Current Setup</h3>
          <ul>
            <li>✅ Netlify Functions already configured</li>
            <li>✅ Build settings in <code>netlify.toml</code></li>
            <li>✅ Redirects configured</li>
            <li>✅ Existing app served from <code>public/</code> directory</li>
          </ul>

          <h3>Deployment Strategy: Parallel Paths</h3>
          <p>The React app will be deployed to <code>/react</code> path while keeping the existing app at root:</p>
          <pre style="background: rgba(0, 0, 0, 0.3); padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>yarny.lindsaybrunner.com/          → Existing vanilla JS app (public/)
yarny.lindsaybrunner.com/react/*   → New React app (dist/)</code></pre>

          <h3>Required Changes</h3>
          
          <h4>Option 1: Separate Build Directory (Recommended)</h4>
          <p>Create a new <code>netlify-react.toml</code> for React app deployment:</p>
          <pre style="background: rgba(0, 0, 0, 0.3); padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code># netlify-react.toml (for React app at /react path)

[build]
  command = "npm run build"
  publish = "dist"

[build.environment]
  NODE_VERSION = "20"

# Serve React app at /react path
[[redirects]]
  from = "/react/*"
  to = "/react/index.html"
  status = 200

# Ensure React app assets are accessible
[[redirects]]
  from = "/react/assets/*"
  to = "/react/assets/:splat"
  status = 200</code></pre>

          <h4>Option 2: Combined Configuration</h4>
          <p>Update existing <code>netlify.toml</code> to handle both:</p>
          <pre style="background: rgba(0, 0, 0, 0.3); padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>[build]
  command = "npm run build"
  publish = "dist"  # React app builds to dist/

[build.environment]
  NODE_VERSION = "20"

# Serve existing app at root (from public/ directory)
# Note: This requires keeping public/ as static files
# or using a different build process

# Serve React app at /react path
[[redirects]]
  from = "/react/*"
  to = "/react/index.html"
  status = 200

# Existing app routes (unchanged)
[[redirects]]
  from = "/editor.html"
  to = "/editor.html"
  status = 200

[[redirects]]
  from = "/stories.html"
  to = "/stories.html"
  status = 200

# Catch-all for React Router (only for /react path)
[[redirects]]
  from = "/react/*"
  to = "/react/index.html"
  status = 200</code></pre>

          <h4>Vite Configuration for Base Path</h4>
          <p>Update <code>vite.config.ts</code> to set base path (TypeScript configuration):</p>
          <pre style="background: rgba(0, 0, 0, 0.3); padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  base: '/react/',  // Important: Set base path for /react deployment
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
  },
  resolve: {
    alias: {
      '@': '/src',  // TypeScript path alias for cleaner imports
    },
  },
})</code></pre>

          <h4>TypeScript Configuration</h4>
          <p>Create <code>tsconfig.json</code>:</p>
          <pre style="background: rgba(0, 0, 0, 0.3); padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}</code></pre>

          <h4>React Router Configuration</h4>
          <p>Update React Router to work with <code>/react</code> base path (TypeScript):</p>
          <pre style="background: rgba(0, 0, 0, 0.3); padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// In your router setup (App.tsx)
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import { LoginPage } from './components/auth/LoginPage';
import { StoriesPage } from './components/stories/StoriesPage';
import { EditorPage } from './components/editor/EditorPage';

export function App(): JSX.Element {
  return (
    &lt;BrowserRouter basename="/react"&gt;
      &lt;Routes&gt;
        &lt;Route path="/" element={&lt;LoginPage /&gt;} /&gt;
        &lt;Route path="/stories" element={&lt;StoriesPage /&gt;} /&gt;
        &lt;Route path="/editor" element={&lt;EditorPage /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/BrowserRouter&gt;
  );
}</code></pre>

          <h3>Build Scripts</h3>
          <pre style="background: rgba(0, 0, 0, 0.3); padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>{
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "netlify:dev": "netlify dev"
  }
}</code></pre>
        </section>

        <section class="docs-section" id="next-steps">
          <h2 id="next-steps-heading">Next Steps</h2>
          <ol>
            <li><strong>Review & Approve Plan</strong> - Get stakeholder buy-in</li>
            <li><strong>Set Up Development Environment</strong> - Install dependencies, configure build</li>
            <li><strong>Configure Netlify for Parallel Deployment</strong> - Set up <code>/react</code> path routing</li>
            <li><strong>Create Proof of Concept</strong> - Migrate one small component to validate approach</li>
            <li><strong>Deploy to <code>/react</code> Path</strong> - Test deployment and routing</li>
            <li><strong>Begin Phase 1</strong> - Set up infrastructure</li>
            <li><strong>Iterate</strong> - Follow migration phases</li>
          </ol>

          <h3>Testing Strategy with Parallel Deployment</h3>
          <ul>
            <li><strong>Development:</strong> Test React app locally at <code>localhost:5173/react</code></li>
            <li><strong>Staging:</strong> Deploy React app to <code>yarny.lindsaybrunner.com/react</code></li>
            <li><strong>Comparison:</strong> Side-by-side testing with existing app</li>
            <li><strong>User Testing:</strong> Invite users to test React version at <code>/react</code> path</li>
            <li><strong>Migration:</strong> Once validated, can switch root to React app or keep both</li>
          </ul>
        </section>

        <section class="docs-section" id="file-structure">
          <h2 id="file-structure-proposed">File Structure (Proposed)</h2>
          <pre style="background: rgba(0, 0, 0, 0.3); padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>yarny-app/
├── src/
│   ├── components/
│   │   ├── auth/
│   │   │   ├── LoginPage.tsx
│   │   │   └── AuthProvider.tsx
│   │   ├── editor/
│   │   │   ├── Editor.tsx
│   │   │   ├── StorySidebar.tsx
│   │   │   ├── NotesSidebar.tsx
│   │   │   ├── TipTapEditor.tsx        # Plain text only configuration
│   │   │   └── ...
│   │   ├── stories/
│   │   │   ├── StoriesList.tsx
│   │   │   ├── StoryCard.tsx
│   │   │   └── ...
│   │   ├── ui/
│   │   │   ├── Modal.tsx
│   │   │   ├── ColorPicker.tsx
│   │   │   ├── ContextMenu.tsx
│   │   │   └── ...
│   │   └── shared/
│   │       ├── Header.tsx
│   │       └── Footer.tsx
│   ├── hooks/
│   │   ├── useDriveQueries.ts              # React Query hooks for ALL Drive I/O
│   │   ├── useConflictDetection.ts         # Conflict detection between Yarny and Drive
│   │   ├── useWindowFocusReconciliation.ts # Reconciliation on window focus
│   │   ├── useAuth.ts
│   │   ├── useStory.ts
│   │   ├── useGoal.ts
│   │   └── ...
│   ├── lib/
│   │   └── react-query.ts        # React Query QueryClient configuration
│   ├── theme/
│   │   └── theme.ts               # MUI theme customization with brand color mappings
│   ├── utils/
│   │   ├── wordCount.ts
│   │   ├── export.ts
│   │   ├── goalCalculation.ts
│   │   ├── textExtraction.ts     # Plain text extraction matching Google Docs format
│   │   └── ...
│   ├── store/
│   │   ├── store.ts (Zustand)
│   │   ├── types.ts (Normalized state types)
│   │   └── selectors.ts (Selectors for derived views)
│   ├── api/
│   │   ├── contract.ts      # API contract definitions (types + Zod schemas)
│   │   ├── client.ts        # Typed API client functions
│   │   └── types.ts         # Shared API types (if needed)
│   ├── App.tsx
│   ├── main.tsx
│   └── routes.tsx
├── public/
│   └── (static assets)
├── netlify/
│   └── functions/ (unchanged)
├── package.json
├── vite.config.ts
├── tsconfig.json
└── netlify.toml</code></pre>
        </section>

        <section class="docs-section" id="decision-points">
          <h2 id="decision-points-heading">Decision Points</h2>
          
          <h3>State Management: Context API vs Zustand vs Redux</h3>
          <p><strong>Recommendation: Zustand</strong></p>
          <ul>
            <li>✅ Simpler than Redux, more powerful than Context</li>
            <li>✅ Easy migration from global state object</li>
            <li>✅ Good TypeScript support</li>
            <li>✅ Small bundle size</li>
            <li><strong>Alternative</strong>: Context API (if team prefers built-in solution)</li>
          </ul>

          <h3>Text Editor: TipTap vs Slate vs Draft.js</h3>
          <p><strong>Recommendation: TipTap (Plain Text Only)</strong></p>
          <ul>
            <li>✅ Modern, React-first</li>
            <li>✅ Excellent documentation</li>
            <li>✅ Active development</li>
            <li>✅ Good performance</li>
            <li>✅ <strong>Configured for plain text only</strong> - matches Yarny's minimalist model and Google Docs round-tripping requirements</li>
            <li><strong>Alternative</strong>: Slate (if need more customization, but plain text constraint still applies)</li>
          </ul>

          <h3>Build Tool: Vite vs Create React App vs Webpack</h3>
          <p><strong>Recommendation: Vite</strong></p>
          <ul>
            <li>✅ Fastest development experience</li>
            <li>✅ Modern, simple configuration</li>
            <li>✅ Great TypeScript support</li>
            <li>✅ Smaller bundle sizes</li>
            <li><strong>Alternative</strong>: CRA (if team prefers familiarity)</li>
          </ul>

          <h3>TypeScript: Required</h3>
          <p><strong>Decision: TypeScript from the start</strong> ✅</p>
          <ul>
            <li>✅ Better developer experience with autocomplete and IntelliSense</li>
            <li>✅ Catch errors at compile-time, not runtime</li>
            <li>✅ Better IDE support (refactoring, navigation, find references)</li>
            <li>✅ Type safety prevents common bugs</li>
            <li>✅ Self-documenting code through types</li>
            <li>✅ Easier to maintain and refactor large codebases</li>
            <li>✅ All recommended libraries have excellent TypeScript support</li>
            <li>✅ TypeScript is now the industry standard for React projects</li>
          </ul>
        </section>

        <section class="docs-section" id="success-criteria">
          <h2 id="success-criteria-heading">Success Criteria</h2>
          
          <h3>Must Have (MVP)</h3>
          <ul>
            <li>All existing features work</li>
            <li>No regression in functionality</li>
            <li>Performance is equal or better</li>
            <li>Authentication works</li>
            <li>Google Drive sync works</li>
            <li>Editor saves correctly</li>
            <li>Export functionality works</li>
            <li><strong>Classic UX anchors preserved</strong>: Goal meter, Today chip, footer word/character counts look and behave identically</li>
          </ul>

          <h3>Should Have</h3>
          <ul>
            <li>Better accessibility (ARIA attributes)</li>
            <li>Improved error handling</li>
            <li>Better loading states</li>
            <li>Complete TypeScript type coverage (all components, hooks, utilities)</li>
            <li>Type-safe API calls and state management</li>
            <li><strong>API contract formalization with runtime validation (Zod schemas)</strong></li>
            <li><strong>TanStack Query (React Query) for ALL Drive I/O operations with deduplication, retries, and stale-while-revalidate</strong></li>
            <li><strong>Editor truth and Google Docs round-tripping: plain text only, editor authoritative while open, reconciliation on focus</strong></li>
          </ul>

          <h3>Nice to Have</h3>
          <ul>
            <li>Performance improvements</li>
            <li>Better mobile experience</li>
            <li>Additional features enabled by React</li>
            <li>Advanced TypeScript features (discriminated unions, branded types)</li>
            <li>TypeScript strict mode enabled</li>
            <li>Generated API types from OpenAPI/Swagger (if applicable)</li>
          </ul>
        </section>

        <section class="docs-section" id="notes-considerations">
          <h2 id="notes-considerations-heading">Notes & Considerations</h2>
          
          <h3>Keeping Old Code</h3>
          <ul>
            <li>Keep existing <code>public/</code> files until migration is complete</li>
            <li>Deploy React app to <code>/react</code> path for parallel testing</li>
            <li>Existing app remains at root (<code>yarny.lindsaybrunner.com</code>)</li>
            <li>Can run both versions side-by-side during migration</li>
            <li>Switch over when new version is feature-complete</li>
            <li>Option to keep both versions permanently or gradually migrate users</li>
          </ul>

          <h3>Testing Strategy</h3>
          <ul>
            <li>Manual testing for each feature</li>
            <li>Test with real Google Drive data</li>
            <li>Test edge cases (large stories, many snippets, etc.)</li>
            <li>Cross-browser testing (Chrome, Firefox, Safari, Edge)</li>
          </ul>

          <h3 id="test-strategy-drive-docs">Test Strategy Specific to Drive/Docs (P2 Priority)</h3>
          <p><strong>Why</strong>: Google Drive and Google Docs integration is critical to Yarny's functionality. Round-tripping between Yarny's editor and Google Docs can introduce subtle bugs that only appear with real Drive data. A structured test corpus ensures regressions are obvious and all critical paths are validated.</p>
          <p><strong>What</strong>: Create a dedicated test corpus in a separate Google Drive folder with three project sizes (small, medium, large) and document smoke tests that validate all Drive/Docs operations.</p>

          <h4>1. Test Corpus Setup</h4>
          <p>Create a dedicated Google Drive folder: <strong><code>Yarny Test Corpus</code></strong> (separate from production <code>Yarny Stories</code> folder)</p>

          <p><strong>Small Project</strong> (<code>test-small</code>):</p>
          <ul>
            <li>1 story</li>
            <li>3 chapters</li>
            <li>5 snippets per chapter (15 total snippets)</li>
            <li>2 People, 2 Places, 2 Things notes</li>
            <li>~5,000 words total</li>
            <li><strong>Purpose</strong>: Fast smoke tests, basic operations</li>
          </ul>

          <p><strong>Medium Project</strong> (<code>test-medium</code>):</p>
          <ul>
            <li>1 story</li>
            <li>10 chapters</li>
            <li>8 snippets per chapter (80 total snippets)</li>
            <li>10 People, 10 Places, 10 Things notes</li>
            <li>~25,000 words total</li>
            <li><strong>Purpose</strong>: Realistic project size, performance testing</li>
          </ul>

          <p><strong>Large Project</strong> (<code>test-large</code>):</p>
          <ul>
            <li>1 story</li>
            <li>25 chapters</li>
            <li>15 snippets per chapter (375 total snippets)</li>
            <li>25 People, 25 Places, 25 Things notes</li>
            <li>~100,000 words total</li>
            <li><strong>Purpose</strong>: Stress testing, virtualization validation, lazy loading</li>
          </ul>

          <p><strong>Test Corpus Structure</strong>:</p>
          <pre style="background: rgba(0, 0, 0, 0.3); padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>Yarny Test Corpus/
├── test-small/
│   ├── Chapters/
│   │   ├── Chapter 1/
│   │   │   ├── snippet-1.json (metadata)
│   │   │   └── snippet-1.gdoc (Google Doc)
│   │   ├── Chapter 2/
│   │   └── Chapter 3/
│   ├── People/
│   ├── Places/
│   ├── Things/
│   ├── story.json
│   └── goal.json
├── test-medium/
│   └── (same structure, more content)
└── test-large/
    └── (same structure, much more content)</code></pre>

          <h4>2. Smoke Tests</h4>
          <p>Document and execute these smoke tests for each project size to validate critical paths:</p>

          <p><strong>A. Create Operations</strong></p>
          <ul>
            <li>[ ] Create new story → Verify folder structure in Drive</li>
            <li>[ ] Create new chapter → Verify chapter folder created</li>
            <li>[ ] Create new snippet → Verify Google Doc created in correct chapter folder</li>
            <li>[ ] Create People/Places/Things note → Verify text file created in correct folder</li>
            <li>[ ] Create story with goal → Verify <code>goal.json</code> created and loaded correctly</li>
          </ul>

          <p><strong>B. Rename Operations</strong></p>
          <ul>
            <li>[ ] Rename story → Verify folder renamed in Drive, story list updates</li>
            <li>[ ] Rename chapter → Verify chapter folder renamed, metadata updated</li>
            <li>[ ] Rename snippet → Verify Google Doc renamed, metadata updated</li>
            <li>[ ] Rename People/Places/Things note → Verify file renamed, metadata updated</li>
          </ul>

          <p><strong>C. Reorder Operations</strong></p>
          <ul>
            <li>[ ] Reorder chapters (drag &amp; drop) → Verify order persisted in Drive, UI reflects order</li>
            <li>[ ] Reorder snippets within chapter → Verify order persisted in Drive, UI reflects order</li>
            <li>[ ] Reorder across chapters → Verify snippets moved to correct chapter folders</li>
          </ul>

          <p><strong>D. Edit Operations</strong></p>
          <ul>
            <li>[ ] Edit snippet content → Verify changes saved to Google Doc</li>
            <li>[ ] Edit snippet title/description → Verify metadata updated in Drive</li>
            <li>[ ] Edit chapter title/description → Verify metadata updated in Drive</li>
            <li>[ ] Edit story title/genre/description → Verify metadata updated in Drive</li>
            <li>[ ] Edit goal settings → Verify <code>goal.json</code> updated and loaded correctly</li>
            <li>[ ] Edit People/Places/Things note → Verify text file updated</li>
          </ul>

          <p><strong>E. Export Operations</strong></p>
          <ul>
            <li>[ ] Export all chapters → Verify combined Google Doc created with all snippets in order</li>
            <li>[ ] Export outline → Verify outline document created with titles and descriptions</li>
            <li>[ ] Export all People → Verify combined document created</li>
            <li>[ ] Export all Places → Verify combined document created</li>
            <li>[ ] Export all Things → Verify combined document created</li>
            <li>[ ] Verify export filenames match user input</li>
            <li>[ ] Verify exports appear in story folder in Drive</li>
          </ul>

          <p><strong>F. Conflict Resolution</strong></p>
          <ul>
            <li>[ ] Edit snippet in Yarny → Edit same snippet in Google Docs (other tab) → Switch snippets → Verify conflict detected</li>
            <li>[ ] Edit snippet in Google Docs → Focus Yarny window → Verify reconciliation notification appears</li>
            <li>[ ] Resolve conflict: Keep Yarny version → Verify Yarny version overwrites Drive</li>
            <li>[ ] Resolve conflict: Use Drive version → Verify Drive version replaces Yarny content</li>
            <li>[ ] Edit snippet in Yarny → Add comments in Google Docs → Save in Yarny → Verify comments warning appears</li>
            <li>[ ] Edit snippet in Yarny → Add tracked changes in Google Docs → Save in Yarny → Verify tracked changes warning appears</li>
          </ul>

          <p><strong>G. Round-Trip Testing</strong></p>
          <ul>
            <li>[ ] Edit snippet in Yarny → Save → Edit in Google Docs → Switch snippets → Verify no format loss</li>
            <li>[ ] Edit snippet in Google Docs → Load in Yarny → Verify content matches (plain text only)</li>
            <li>[ ] Paste rich text in Yarny → Verify stripped to plain text</li>
            <li>[ ] Test paragraph breaks (<code>\n\n</code>) → Verify preserved in round-trip</li>
            <li>[ ] Test soft line breaks (<code>\n</code>) → Verify preserved in round-trip</li>
            <li>[ ] Test special characters (quotes, em dashes, etc.) → Verify preserved in round-trip</li>
          </ul>

          <p><strong>H. Performance &amp; Loading</strong></p>
          <ul>
            <li>[ ] Load large project (test-large) → Verify initial load time acceptable (&lt; 5 seconds)</li>
            <li>[ ] Switch between snippets in large project → Verify no lag</li>
            <li>[ ] Scroll through chapter list in large project → Verify smooth scrolling (virtualized)</li>
            <li>[ ] Background loading → Verify non-active snippets load in background without blocking UI</li>
            <li>[ ] Lazy loading → Verify snippet content only loads when needed</li>
          </ul>

          <p><strong>I. Error Handling</strong></p>
          <ul>
            <li>[ ] Network error during save → Verify error message displayed, retry works</li>
            <li>[ ] Invalid Drive permissions → Verify clear error message</li>
            <li>[ ] Drive API rate limit → Verify graceful handling, retry logic</li>
            <li>[ ] Corrupted metadata file → Verify error handling, recovery option</li>
          </ul>

          <h4>3. Linking to Success Criteria</h4>
          <p>Map smoke tests to success criteria to ensure regressions are obvious:</p>
          <table style="width: 100%; border-collapse: collapse; margin: var(--space-lg) 0;">
            <thead>
              <tr style="background: rgba(0, 0, 0, 0.2);">
                <th style="padding: var(--space-md); text-align: left; border-bottom: 2px solid rgba(255, 255, 255, 0.2);">Success Criterion</th>
                <th style="padding: var(--space-md); text-align: left; border-bottom: 2px solid rgba(255, 255, 255, 0.2);">Smoke Tests</th>
                <th style="padding: var(--space-md); text-align: left; border-bottom: 2px solid rgba(255, 255, 255, 0.2);">Test Corpus</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);"><strong>Google Drive sync works</strong></td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Create, Edit, Rename, Reorder (all)</td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Small, Medium, Large</td>
              </tr>
              <tr>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);"><strong>Editor saves correctly</strong></td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Edit Operations (all)</td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Small, Medium, Large</td>
              </tr>
              <tr>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);"><strong>Export functionality works</strong></td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Export Operations (all)</td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Small, Medium</td>
              </tr>
              <tr>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);"><strong>Conflict resolution works</strong></td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Conflict Resolution (all)</td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Small, Medium</td>
              </tr>
              <tr>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);"><strong>Round-tripping works</strong></td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Round-Trip Testing (all)</td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Small, Medium</td>
              </tr>
              <tr>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);"><strong>Performance is equal or better</strong></td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Performance &amp; Loading (all)</td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Large (especially)</td>
              </tr>
              <tr>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);"><strong>No regression in functionality</strong></td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">All smoke tests</td>
                <td style="padding: var(--space-md); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">All sizes</td>
              </tr>
            </tbody>
          </table>

          <h4>4. Test Execution Plan</h4>
          <p><strong>Phase 1 (Setup &amp; Infrastructure)</strong>:</p>
          <ul>
            <li>Create test corpus folder structure</li>
            <li>Populate small project with sample data</li>
            <li>Document smoke test checklist</li>
          </ul>

          <p><strong>Phase 4 (Editor - Tri-Pane Shell &amp; Plain Text Round-Trip)</strong>:</p>
          <ul>
            <li>Run smoke tests on small project after TipTap integration</li>
            <li>Validate round-tripping with small project</li>
            <li>Populate medium project</li>
          </ul>

          <p><strong>Phase 6 (Lazy Loading, Conflict Resolution &amp; Exports)</strong>:</p>
          <ul>
            <li>Run full smoke test suite on small and medium projects</li>
            <li>Validate all operations work correctly</li>
            <li>Populate large project</li>
          </ul>

          <p><strong>Phase 7 (Accessibility, Performance &amp; Polish)</strong>:</p>
          <ul>
            <li>Run full smoke test suite on all three project sizes</li>
            <li>Performance testing with large project</li>
            <li>Regression testing before production deployment</li>
          </ul>

          <h4>5. Test Corpus Maintenance</h4>
          <ul>
            <li><strong>Version Control</strong>: Document test corpus structure and expected state</li>
            <li><strong>Reset Script</strong>: Create script to reset test corpus to known good state</li>
            <li><strong>Validation</strong>: Periodically verify test corpus integrity (files exist, metadata correct)</li>
            <li><strong>Updates</strong>: Update test corpus when new features are added (e.g., new export types)</li>
          </ul>

          <h4>6. Benefits</h4>
          <ol>
            <li><strong>Obvious Regressions</strong>: Test corpus provides baseline for comparison - if something breaks, it's immediately obvious</li>
            <li><strong>Comprehensive Coverage</strong>: Smoke tests ensure all critical paths are validated</li>
            <li><strong>Performance Validation</strong>: Large project validates performance optimizations (virtualization, lazy loading)</li>
            <li><strong>Round-Trip Confidence</strong>: Structured tests ensure Google Docs integration works correctly</li>
            <li><strong>Documentation</strong>: Test corpus serves as living documentation of expected behavior</li>
          </ol>

          <h4>Implementation Timeline</h4>
          <p>This should be implemented in <strong>Phase 1</strong> (Setup &amp; Infrastructure):</p>
          <ul>
            <li>Create test corpus folder structure</li>
            <li>Populate small project</li>
            <li>Document smoke test checklist</li>
            <li>Integrate smoke tests into Phase 4, 6, and 7 testing workflow</li>
          </ul>

          <p><strong>LOE</strong>: 4-6 hours (includes creating test corpus structure, populating small/medium projects, documenting smoke tests, and setting up test execution workflow)</p>

          <h3>Performance Considerations</h3>
          <ul>
            <li>Use React.memo for expensive components</li>
            <li>Lazy load routes with React.lazy</li>
            <li>Optimize re-renders with useMemo/useCallback</li>
            <li>Consider virtual scrolling for long lists</li>
          </ul>

          <h3 id="performance-guardrails">Performance Guardrails for Big Projects (P2 Priority)</h3>
          <p><strong>Why</strong>: Large stories with many chapters and snippets can cause performance issues. The vanilla app already handles this with lazy loading; we need to carry forward these optimizations and add React-specific performance patterns.</p>
          <p><strong>What</strong>: Implement three key performance optimizations to ensure the React app performs well with large projects:</p>

          <h4>1. Virtualize Long Lists in the Left Rail</h4>
          <p><strong>Problem</strong>: When stories grow to 50+ chapters or 200+ snippets, rendering all list items at once causes:</p>
          <ul>
            <li>Slow initial render</li>
            <li>Laggy scrolling</li>
            <li>High memory usage</li>
            <li>Poor performance on lower-end devices</li>
          </ul>
          <p><strong>Solution</strong>: Use <code>@tanstack/react-virtual</code> (or similar) to virtualize the left rail lists.</p>
          <p><strong>Implementation</strong>:</p>
          <ul>
            <li>Virtualize the chapter/group list in the left sidebar</li>
            <li>Virtualize the snippet list within each chapter</li>
            <li>Only render visible items + small buffer (e.g., 5 items above/below viewport)</li>
            <li>Works seamlessly with normalized state structure (already planned)</li>
          </ul>
          <p><strong>Code Example</strong>:</p>
          <pre style="background: rgba(0, 0, 0, 0.3); padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/components/editor/StorySidebar.tsx
import { useVirtualizer } from '@tanstack/react-virtual';
import { useGroupsList } from '../../store/selectors';

export function StorySidebar() {
  const groups = useGroupsList();
  const parentRef = useRef&lt;HTMLDivElement&gt;(null);
  
  const virtualizer = useVirtualizer({
    count: groups.length,
    getScrollElement: () =&gt; parentRef.current,
    estimateSize: () =&gt; 60, // Estimated row height
    overscan: 5, // Render 5 extra items above/below viewport
  });
  
  return (
    &lt;div ref={parentRef} style={{ height: '100%', overflow: 'auto' }}&gt;
      &lt;div style={{ height: `${virtualizer.getTotalSize()}px`, position: 'relative' }}&gt;
        {virtualizer.getVirtualItems().map((virtualRow) =&gt; {
          const group = groups[virtualRow.index];
          return (
            &lt;div
              key={group.id}
              style={{
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                height: `${virtualRow.size}px`,
                transform: `translateY(${virtualRow.start}px)`,
              }}
            &gt;
              &lt;GroupRow group={group} /&gt;
            &lt;/div&gt;
          );
        })}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>
          <p><strong>When to Implement</strong>:</p>
          <ul>
            <li>Phase 4 (Editor - Tri-Pane Shell) or Phase 5 (Library Features &amp; Goals UI)</li>
            <li>Add when testing with large stories (50+ chapters, 200+ snippets)</li>
            <li>Can be deferred if initial performance is acceptable, but should be in place before production</li>
          </ul>
          <p><strong>LOE</strong>: 4-6 hours (includes virtualizing both chapter and snippet lists, testing with large datasets)</p>

          <h4>2. Memoize Expensive List Rows and Editor Shell</h4>
          <p><strong>Problem</strong>: Passing anonymous callbacks and inline objects causes unnecessary re-renders:</p>
          <ul>
            <li>List rows re-render when parent re-renders (even if their data hasn't changed)</li>
            <li>Editor shell re-renders on every state update</li>
            <li>Anonymous callbacks create new function references on every render</li>
            <li>Deep prop drilling causes cascading re-renders</li>
          </ul>
          <p><strong>Solution</strong>: Use <code>React.memo</code>, <code>useMemo</code>, and <code>useCallback</code> strategically to prevent unnecessary re-renders.</p>
          <p><strong>Implementation Strategy</strong>:</p>
          <p><strong>A. Memoize List Row Components</strong>:</p>
          <pre style="background: rgba(0, 0, 0, 0.3); padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/components/editor/GroupRow.tsx
import React, { memo } from 'react';
import { Group } from '../../store/types';

interface GroupRowProps {
  group: Group;
  onSelect: (groupId: string) =&gt; void;
  onRename: (groupId: string, newTitle: string) =&gt; void;
  isActive: boolean;
  isCollapsed: boolean;
}

// Memoize the row component - only re-renders if props change
export const GroupRow = memo(function GroupRow({
  group,
  onSelect,
  onRename,
  isActive,
  isCollapsed,
}: GroupRowProps) {
  // Component implementation
}, (prevProps, nextProps) =&gt; {
  // Custom comparison function for better control
  return (
    prevProps.group.id === nextProps.group.id &amp;&amp;
    prevProps.group.title === nextProps.group.title &amp;&amp;
    prevProps.group.snippetIds.length === nextProps.group.snippetIds.length &amp;&amp;
    prevProps.isActive === nextProps.isActive &amp;&amp;
    prevProps.isCollapsed === nextProps.isCollapsed
  );
});</code></pre>
          <p><strong>B. Memoize Editor Shell</strong>:</p>
          <pre style="background: rgba(0, 0, 0, 0.3); padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/components/editor/Editor.tsx
import React, { memo, useCallback, useMemo } from 'react';
import { useStore } from '../../store/store';

export const Editor = memo(function Editor({ storyId }: { storyId: string }) {
  const activeSnippetId = useStore((state) =&gt; state.project.activeSnippetId);
  const snippet = useStore((state) =&gt; 
    activeSnippetId ? state.snippets[activeSnippetId] : null
  );
  
  // Memoize callbacks to prevent child re-renders
  const handleSave = useCallback((content: string) =&gt; {
    // Save logic
  }, []);
  
  const handleSnippetChange = useCallback((snippetId: string) =&gt; {
    // Change snippet logic
  }, []);
  
  // Memoize expensive computations
  const wordCount = useMemo(() =&gt; {
    return snippet ? countWords(snippet.body) : 0;
  }, [snippet?.body]);
  
  return (
    &lt;div className="editor-shell"&gt;
      {/* Editor content */}
    &lt;/div&gt;
  );
});</code></pre>
          <p><strong>C. Avoid Anonymous Callbacks in Deep Trees</strong>:</p>
          <pre style="background: rgba(0, 0, 0, 0.3); padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// ❌ DON'T DO THIS - creates new function on every render
&lt;GroupRow 
  group={group}
  onSelect={(id) =&gt; handleSelect(id)}  // Anonymous callback
  onClick={() =&gt; handleClick(group.id)} // Anonymous callback
/&gt;

// ✅ DO THIS - memoized callback
const handleSelect = useCallback((id: string) =&gt; {
  // Selection logic
}, []);

const handleGroupClick = useCallback((groupId: string) =&gt; {
  handleClick(groupId);
}, [handleClick]);

&lt;GroupRow 
  group={group}
  onSelect={handleSelect}  // Stable reference
  onClick={() =&gt; handleGroupClick(group.id)} // Still anonymous, but acceptable if group.id is stable
/&gt;

// ✅ EVEN BETTER - pass groupId directly
const handleGroupClick = useCallback((groupId: string) =&gt; {
  handleClick(groupId);
}, [handleClick]);

&lt;GroupRow 
  group={group}
  onSelect={handleSelect}
  onClick={handleGroupClick}  // Stable reference, groupId passed via closure
  groupId={group.id}  // Or pass as prop if needed
/&gt;</code></pre>
          <p><strong>When to Implement</strong>:</p>
          <ul>
            <li>Phase 4 (Editor - Tri-Pane Shell) - implement memoization from the start</li>
            <li>Review and optimize during Phase 7 (Accessibility, Performance &amp; Polish)</li>
          </ul>
          <p><strong>LOE</strong>: 3-4 hours (includes memoizing list rows, editor shell, and reviewing callback patterns)</p>

          <h4>3. Defer Non-Active Snippet Loads</h4>
          <p><strong>Problem</strong>: Loading all snippet content at once causes:</p>
          <ul>
            <li>Slow initial load</li>
            <li>High memory usage</li>
            <li>Unnecessary network requests</li>
            <li>Poor UX for large stories</li>
          </ul>
          <p><strong>Current Vanilla App Behavior</strong>:</p>
          <ul>
            <li>Loads active snippet immediately</li>
            <li>Background loads remaining snippets with throttling</li>
            <li>Uses <code>_contentLoaded</code> flag to track loaded state</li>
          </ul>
          <p><strong>Solution</strong>: Carry forward this pattern using React Query's prefetching and lazy loading capabilities.</p>
          <p><strong>Implementation</strong>:</p>
          <ul>
            <li>Use React Query's <code>useQuery</code> with <code>enabled: false</code> for non-active snippets</li>
            <li>Prefetch snippets in background using <code>prefetchQuery</code> (already planned in React Query section)</li>
            <li>Only load snippet content when:
              <ul>
                <li>Snippet becomes active (user clicks on it)</li>
                <li>Snippet is scrolled into view (for virtualized lists)</li>
                <li>Background prefetching (throttled, batched)</li>
              </ul>
            </li>
          </ul>
          <p><strong>Code Example</strong>:</p>
          <pre style="background: rgba(0, 0, 0, 0.3); padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/hooks/useSnippetContent.ts
import { useQuery, useQueryClient } from '@tanstack/react-query';
import { useStore } from '../store/store';
import { useDriveFile } from './useDriveQueries';

export function useSnippetContent(snippetId: string | null, loadImmediately = false) {
  const snippet = useStore((state) =&gt; 
    snippetId ? state.snippets[snippetId] : null
  );
  const activeSnippetId = useStore((state) =&gt; state.project.activeSnippetId);
  
  // Only load if:
  // 1. Load immediately (active snippet)
  // 2. Content already loaded (cached)
  // 3. Explicitly requested
  const shouldLoad = loadImmediately || 
                     snippet?._contentLoaded || 
                     snippetId === activeSnippetId;
  
  const { data, isLoading } = useDriveFile(
    shouldLoad &amp;&amp; snippet?.driveFileId ? snippet.driveFileId : null
  );
  
  return {
    content: data?.content || snippet?.body || '',
    isLoading: !snippet?._contentLoaded &amp;&amp; isLoading,
    isLoaded: !!snippet?._contentLoaded,
  };
}

// Background prefetching (throttled)
export function usePrefetchSnippets(snippetIds: string[], batchSize = 5, delay = 500) {
  const queryClient = useQueryClient();
  const snippets = useStore((state) =&gt; state.snippets);
  
  useEffect(() =&gt; {
    // Only prefetch snippets that haven't been loaded
    const unloadedSnippets = snippetIds.filter(
      (id) =&gt; !snippets[id]?._contentLoaded
    );
    
    // Prefetch in batches with delay
    unloadedSnippets.forEach((snippetId, index) =&gt; {
      const snippet = snippets[snippetId];
      if (!snippet?.driveFileId) return;
      
      setTimeout(() =&gt; {
        queryClient.prefetchQuery({
          queryKey: driveKeys.file(snippet.driveFileId),
          queryFn: () =&gt; readDriveFile({ fileId: snippet.driveFileId! }),
          staleTime: 5 * 60 * 1000,
        });
      }, Math.floor(index / batchSize) * delay);
    });
  }, [snippetIds, snippets, queryClient]);
}</code></pre>
          <p><strong>When to Implement</strong>:</p>
          <ul>
            <li>Phase 1 (Setup &amp; Infrastructure) - React Query setup already includes this</li>
            <li>Phase 6 (Lazy Loading, Conflict Resolution &amp; Exports) - integrate with editor component</li>
          </ul>
          <p><strong>LOE</strong>: Already included in React Query setup (Phase 1) and lazy loading (Phase 6)</p>

          <h4>Summary</h4>
          <table style="width: 100%; border-collapse: collapse; margin: var(--space-lg) 0;">
            <thead>
              <tr style="background: rgba(0, 0, 0, 0.2);">
                <th style="padding: var(--space-md); text-align: left; border: 1px solid rgba(255, 255, 255, 0.1);">Optimization</th>
                <th style="padding: var(--space-md); text-align: left; border: 1px solid rgba(255, 255, 255, 0.1);">Priority</th>
                <th style="padding: var(--space-md); text-align: left; border: 1px solid rgba(255, 255, 255, 0.1);">Phase</th>
                <th style="padding: var(--space-md); text-align: left; border: 1px solid rgba(255, 255, 255, 0.1);">LOE</th>
                <th style="padding: var(--space-md); text-align: left; border: 1px solid rgba(255, 255, 255, 0.1);">Status</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">Virtualize long lists</td>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">P2</td>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">Phase 4 or 5</td>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">4-6 hrs</td>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">Deferred until needed</td>
              </tr>
              <tr style="background: rgba(0, 0, 0, 0.1);">
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">Memoize list rows &amp; editor</td>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">P2</td>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">Phase 4</td>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">3-4 hrs</td>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">Implement from start</td>
              </tr>
              <tr>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">Defer non-active loads</td>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">P2</td>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">Phase 1 &amp; 6</td>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">Included</td>
                <td style="padding: var(--space-md); border: 1px solid rgba(255, 255, 255, 0.1);">Already planned</td>
              </tr>
            </tbody>
          </table>
          <p><strong>Total Additional LOE</strong>: 7-10 hours (virtualization + memoization)</p>
          <p><strong>Benefits</strong>:</p>
          <ol>
            <li><strong>Scalability</strong>: App performs well with 100+ chapters and 500+ snippets</li>
            <li><strong>Better UX</strong>: Faster initial load, smoother scrolling</li>
            <li><strong>Lower Memory</strong>: Only render visible items, load content on demand</li>
            <li><strong>Future-Proof</strong>: Normalized state + virtualization enables even larger projects</li>
          </ol>

          <h3>Accessibility</h3>
          <ul>
            <li>All Material UI components are accessible by default</li>
            <li>Test with screen readers</li>
            <li>Ensure keyboard navigation works</li>
            <li>Check color contrast</li>
          </ul>
        </section>

        <section class="docs-section" id="questions">
          <h2 id="questions-to-resolve">Questions to Resolve</h2>
          <ul>
            <li>✅ TypeScript from start or add later? ✅ <strong>TypeScript from the start</strong></li>
            <li>State management choice (Zustand vs Context)? <strong>Recommendation: Zustand</strong></li>
            <li>✅ Should we keep old code as reference? ✅ <strong>Yes - parallel deployment at /react</strong></li>
            <li>Timeline constraints?</li>
            <li>Team size and availability?</li>
            <li>Testing requirements?</li>
            <li>When to migrate users from root to /react? (or keep both?)</li>
            <li>How to handle shared Netlify Functions? (should work for both)</li>
            <li>TypeScript strict mode level? (recommend: strict)</li>
            <li>ESLint + TypeScript ESLint configuration preferences?</li>
          </ul>
        </section>

        <section class="docs-section" id="resources">
          <h2 id="resources-heading">Resources</h2>
          
          <h3>Documentation</h3>
          <ul>
            <li><a href="https://tiptap.dev/" target="_blank" rel="noopener">TipTap Documentation</a></li>
            <li><a href="https://mui.com/" target="_blank" rel="noopener">Material UI Documentation</a></li>
            <li><a href="https://docs.dndkit.com/" target="_blank" rel="noopener">@dnd-kit Documentation</a></li>
            <li><a href="https://reactrouter.com/" target="_blank" rel="noopener">React Router Documentation</a></li>
            <li><a href="https://github.com/pmndrs/zustand" target="_blank" rel="noopener">Zustand Documentation</a></li>
          </ul>

          <h3>Migration Guides</h3>
          <ul>
            <li><a href="https://react.dev/learn/start-a-new-react-project" target="_blank" rel="noopener">React Migration Guide</a></li>
            <li><a href="https://vitejs.dev/guide/" target="_blank" rel="noopener">Vite Migration Guide</a></li>
          </ul>
        </section>

        <section class="docs-section" id="technical-details">
          <h2 id="additional-technical-details">Additional Technical Details</h2>
          
          <h3>State Structure</h3>
          <p>The current global <code>state</code> object will be converted to <strong>normalized</strong> TypeScript interfaces. All entities are keyed by id, and selectors derive views:</p>
          <pre style="background: rgba(0, 0, 0, 0.3); padding: var(--space-lg); border-radius: var(--radius-md); overflow-x: auto;"><code>// src/store/types.ts
export interface Group {
  id: string;
  title: string;
  description?: string;
  color: string;
  snippetIds: string[]; // References to snippet ids
  position?: number;
}

export interface Snippet {
  id: string;
  title: string;
  body: string;
  description?: string;
  groupId?: string; // Reference to group id
  kind?: 'person' | 'place' | 'thing';
  color?: string;
  words: number;
  chars: number;
  driveFileId?: string;
  updatedAt?: string;
  lastKnownDriveModifiedTime?: string;
  _contentLoaded?: boolean;
}

export interface Note {
  id: string;
  title: string;
  body: string;
  description?: string;
  kind: 'person' | 'place' | 'thing';
  color?: string;
  words: number;
  chars: number;
  driveFileId?: string;
  updatedAt?: string;
}

export interface Story {
  id: string;
  title: string;
  description?: string;
  genre?: string;
  driveFolderId: string;
  goalId?: string; // Reference to goal id
  createdAt: string;
  updatedAt: string;
}

export interface Goal {
  id: string;
  target: number | null;
  deadline: string | null;
  mode: 'elastic' | 'strict';
  writingDays: number[];
  daysOff: string[];
}

export interface Project {
  storyId: string | null;
  groupIds: string[]; // Ordered list of group ids
  snippetIds: string[]; // Ordered list of snippet ids
  activeSnippetId: string | null;
  activeRightTab: 'people' | 'places' | 'things';
  filters: {
    search: string;
  };
}

// Normalized state structure - all entities keyed by id
export interface AppState {
  // Normalized entities - keyed by id
  stories: Record&lt;string, Story&gt;;
  groups: Record&lt;string, Group&gt;;
  snippets: Record&lt;string, Snippet&gt;;
  notes: Record&lt;string, Note&gt;; // People, Places, Things
  goals: Record&lt;string, Goal&gt;;
  
  // Denormalized views - derived via selectors (see src/store/selectors.ts)
  project: Project;
  
  // Drive state
  drive: {
    storyFolderId: string | null;
  };
  
  // UI state
  collapsedGroups: Set&lt;string&gt;;
  editing: {
    savingState: 'idle' | 'saving' | 'saved';
    lastSavedAt: string | null;
  };
}</code></pre>
          <p><strong>Note</strong>: Views (e.g., left-rail lists) are derived using selectors in <code>src/store/selectors.ts</code>, not stored directly in state. This keeps renders cheap and enables virtualized lists later.</p>

          <h3>Key Algorithms</h3>
          <ol>
            <li><strong>Word Counting</strong>: Custom function handling various text formats</li>
            <li><strong>Goal Calculation</strong>: Complex date/word math for daily targets</li>
            <li><strong>Conflict Detection</strong>: Compares local vs Drive modified times</li>
            <li><strong>Lazy Loading</strong>: Loads active snippet first, then batches remaining</li>
            <li><strong>Midnight Rollover</strong>: Detects day changes and recalculates goals</li>
          </ol>

          <h3>Performance Optimizations</h3>
          <ul>
            <li>Throttled updates during background loading</li>
            <li>Lazy content loading (only load when snippet is active)</li>
            <li>Batch background loading with delays</li>
            <li>Preserved order from saved data (no unnecessary sorting)</li>
            <li>Word count caching in snippet objects</li>
          </ul>

          <h3>Browser Compatibility</h3>
          <ul>
            <li><strong>Current</strong>: Works in modern browsers (Chrome, Firefox, Safari, Edge)</li>
            <li><strong>React</strong>: Same browser support expected</li>
            <li><strong>Mobile</strong>: Currently shows warning, not fully supported</li>
          </ul>
        </section>

        <section class="docs-section" id="changelog">
          <h2 id="changelog-heading">Changelog</h2>
          <ul>
            <li><strong>2025-01-XX</strong>: Initial plan created
              <ul>
                <li>Added implementation details section</li>
                <li>Added modal list (8 total)</li>
                <li>Added color system details</li>
                <li>Added export types breakdown</li>
                <li>Added goal system features</li>
                <li>Added code statistics</li>
                <li>Added technical details section</li>
                <li><strong>Added parallel deployment strategy</strong>: React app at <code>/react</code> path, existing app at root</li>
                <li>Added Netlify configuration for <code>/react</code> path deployment</li>
                <li>Added Vite and React Router base path configuration</li>
                <li>Added testing strategy for parallel deployment</li>
                <li><strong>Updated to require TypeScript</strong>: Changed from optional to required</li>
                <li>Added TypeScript configuration examples</li>
                <li>Updated file structure to show all <code>.tsx</code> and <code>.ts</code> files</li>
                <li>Added TypeScript type definitions for state structure</li>
                <li>Updated LOE estimates to include TypeScript setup time</li>
                <li>Updated decision points to make TypeScript mandatory</li>
                <li><strong>Added API Contract Formalization section (P1 Priority)</strong>:
                  <ul>
                    <li>Defined centralized API contract module with Zod schemas</li>
                    <li>Created typed API client wrapper with runtime validation</li>
                    <li>Documented all endpoints to be covered (auth, Drive, status)</li>
                    <li>Added example implementation code</li>
                    <li>Updated Phase 1 to include API contract setup</li>
                    <li>Added <code>zod</code> to dependencies</li>
                    <li>Updated file structure to show API contract files</li>
                    <li>Added API contract formalization to success criteria</li>
                  </ul>
                </li>
                <li><strong>Added Fetch/Caching Layer with TanStack Query section (P1 Priority)</strong>:
                  <ul>
                    <li>Adopted TanStack Query (React Query) as the fetch/caching layer for ALL Drive I/O</li>
                    <li>Replaced ad-hoc useEffect hooks with React Query hooks</li>
                    <li>Documented all Drive operations that must use React Query (read, write, list, delete, rename, check comments, create folder, etc.)</li>
                    <li>Added React Query setup and configuration</li>
                    <li>Created <code>useDriveQueries.ts</code> hook structure with examples</li>
                    <li>Updated lazy loading to use React Query prefetching and <code>useQueries</code></li>
                    <li>Added <code>@tanstack/react-query</code> to dependencies</li>
                    <li>Updated Phase 1 to include React Query setup</li>
                    <li>Updated Phase 6 to use React Query for lazy loading</li>
                    <li>Added React Query to success criteria</li>
                    <li><strong>Key change</strong>: ALL Drive I/O operations now use React Query, not just background loads</li>
                  </ul>
                </li>
                <li><strong>Added Editor Truth and Google Docs Round-Tripping section (P1 Priority)</strong>:
                  <ul>
                    <li>Constrained TipTap to plain text only (no rich formatting) to match Yarny's minimalist model</li>
                    <li>Established editor as authoritative while Yarny is open</li>
                    <li>Added reconciliation on window focus to detect external changes</li>
                    <li>Brought conflict detection forward to Phase 1/2 (early in migration)</li>
                    <li>Created text extraction utilities matching Google Docs API format</li>
                    <li>Updated TipTap configuration to use only Document, Paragraph, Text, HardBreak, History extensions</li>
                    <li>Added conflict detection and reconciliation hooks</li>
                    <li>Updated Phase 1 to include TipTap plain text configuration and early conflict detection</li>
                    <li>Updated Phase 2 to include reconciliation on window focus</li>
                    <li>Updated Phase 4 to integrate TipTap with conflict detection and test round-tripping</li>
                    <li>Added TipTap extension dependencies (individual extensions, not full starter-kit)</li>
                    <li>Added editor truth and round-tripping to success criteria</li>
                  </ul>
                </li>
                <li><strong>Added State Normalization section (P1 Priority)</strong>:
                  <ul>
                    <li>Normalize all entities (stories, groups, snippets, notes, tags, goals) keyed by id in Zustand store</li>
                    <li>Use selectors to derive views (e.g., left-rail lists) instead of storing nested objects</li>
                    <li>Keeps renders cheap and enables virtualized lists later</li>
                    <li>Updated state structure to show normalized form with entity references</li>
                    <li>Created selectors examples for derived views</li>
                    <li>Updated Phase 1 to include state normalization setup</li>
                    <li>Updated file structure to include <code>selectors.ts</code></li>
                    <li>Updated State Management Architecture section to explicitly call out normalization</li>
                  </ul>
                </li>
                <li><strong>Added Performance Guardrails for Big Projects section (P2 Priority)</strong>:
                  <ul>
                    <li>Virtualize long lists in the left rail using <code>@tanstack/react-virtual</code> when stories grow large (50+ chapters, 200+ snippets)</li>
                    <li>Memoize expensive list rows and editor shell using <code>React.memo</code>, <code>useMemo</code>, and <code>useCallback</code></li>
                    <li>Avoid passing anonymous callbacks into deep trees to prevent unnecessary re-renders</li>
                    <li>Defer non-active snippet loads using React Query's prefetching (carries forward vanilla app's lazy loading pattern)</li>
                    <li>Added code examples for virtualization, memoization, and lazy loading</li>
                    <li>Added <code>@tanstack/react-virtual</code> to dependencies</li>
                    <li>Updated Performance Considerations section with detailed implementation strategies</li>
                    <li>Total additional LOE: 7-10 hours (virtualization + memoization)</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>Document all major decisions and changes here</li>
          </ul>
        </section>

        <section class="docs-section" id="contact">
          <h2 id="contact-support">Contact & Support</h2>
          <p>For questions or updates to this plan, please document changes here and update the changelog.</p>
        </section>
      </div>
    </main>

    <footer class="shared-footer">
      <p>&copy; 2025 Yarny. Your personal writing tool.</p>
      <nav class="shared-footer-nav">
        <a href="/stories.html" id="footerStoriesLink" style="display: none;">My Stories</a>
        <a href="/docs.html">Docs</a>
        <a href="/migration-plan">Migration Plan</a>
        <a href="/" id="footerLoginLink">Back to Login</a>
      </nav>
    </footer>
  </div>
  <script>
    // Check if user is logged in
    function isTokenExpired(token) {
      if (!token) return true;
      
      try {
        const decoded = atob(token);
        const parts = decoded.split(':');
        
        if (parts.length !== 2) return true;
        
        const timestamp = parseInt(parts[1], 10);
        if (isNaN(timestamp)) return true;
        
        // Check if token is within 48 hours
        const SESSION_DURATION_MS = 48 * 60 * 60 * 1000;
        const now = Date.now();
        const age = now - timestamp;
        
        return age > SESSION_DURATION_MS;
      } catch (error) {
        console.error('Error checking token expiration:', error);
        return true;
      }
    }

    function checkAuthStatus() {
      const authToken = localStorage.getItem('yarny_auth');
      const isLoggedIn = authToken && !isTokenExpired(authToken);
      
      const storiesLink = document.getElementById('storiesNavLink');
      const loginLink = document.getElementById('loginNavLink');
      const footerStoriesLink = document.getElementById('footerStoriesLink');
      const footerLoginLink = document.getElementById('footerLoginLink');
      
      if (isLoggedIn) {
        if (storiesLink) storiesLink.style.display = 'inline-block';
        if (loginLink) loginLink.style.display = 'none';
        if (footerStoriesLink) footerStoriesLink.style.display = 'inline-block';
        if (footerLoginLink) footerLoginLink.style.display = 'none';
      } else {
        if (storiesLink) storiesLink.style.display = 'none';
        if (loginLink) loginLink.style.display = 'inline-block';
        if (footerStoriesLink) footerStoriesLink.style.display = 'none';
        if (footerLoginLink) footerLoginLink.style.display = 'inline-block';
      }
    }

    // Highlight active navigation item based on scroll position
    document.addEventListener('DOMContentLoaded', function() {
      // Check auth status on page load
      checkAuthStatus();
      
      const navLinks = document.querySelectorAll('.sidebar-nav .nav-link');
      const sections = document.querySelectorAll('.docs-section[id]');
      const sidebar = document.querySelector('.docs-sidebar');
      const header = document.querySelector('.docs-header');

      function updateActiveNav() {
        let current = '';
        const scrollPos = window.scrollY + 150; // Offset for header

        sections.forEach(section => {
          const sectionTop = section.offsetTop;
          const sectionHeight = section.offsetHeight;
          if (scrollPos >= sectionTop && scrollPos < sectionTop + sectionHeight) {
            current = section.getAttribute('id');
          }
        });

        navLinks.forEach(link => {
          link.classList.remove('active');
          if (link.getAttribute('href') === '#' + current) {
            link.classList.add('active');
          }
        });
      }

      // Mobile menu toggle
      const menuButton = document.querySelector('.mobile-menu-toggle') || document.createElement('button');
      const backdrop = document.querySelector('.sidebar-backdrop');
      
      if (!menuButton.parentNode) {
        menuButton.className = 'mobile-menu-toggle';
        menuButton.innerHTML = '☰';
        menuButton.setAttribute('aria-label', 'Toggle menu');
        header.appendChild(menuButton);
      }

      function toggleSidebar() {
        sidebar.classList.toggle('open');
        if (backdrop) {
          backdrop.classList.toggle('active');
        }
      }

      menuButton.addEventListener('click', function(e) {
        e.stopPropagation();
        toggleSidebar();
      });

      // Close sidebar when clicking backdrop
      if (backdrop) {
        backdrop.addEventListener('click', function() {
          sidebar.classList.remove('open');
          backdrop.classList.remove('active');
        });
      }

      // Close sidebar when clicking outside on mobile
      document.addEventListener('click', function(e) {
        if (window.innerWidth <= 900 && sidebar && sidebar.classList.contains('open')) {
          if (!sidebar.contains(e.target) && !e.target.classList.contains('mobile-menu-toggle')) {
            sidebar.classList.remove('open');
            if (backdrop) {
              backdrop.classList.remove('active');
            }
          }
        }
      });

      // Close sidebar when clicking a nav link on mobile
      navLinks.forEach(link => {
        link.addEventListener('click', function() {
          if (window.innerWidth <= 900) {
            sidebar.classList.remove('open');
            if (backdrop) {
              backdrop.classList.remove('active');
            }
          }
        });
      });

      window.addEventListener('scroll', updateActiveNav);
      window.addEventListener('resize', function() {
        // Only auto-close sidebar if we're above mobile breakpoint
        if (window.innerWidth > 900) {
          sidebar.classList.remove('open');
          if (backdrop) {
            backdrop.classList.remove('active');
          }
        }
      });

      updateActiveNav(); // Initial call
    });
  </script>
</body>
</html>
